{"meta":{"title":"郭大大的博客","subtitle":"生活就像海洋，只有意志坚强的人才能到达彼岸","description":"前端开发爱好者","author":"gershonv","url":"https://gershonv.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-01-03T14:17:53.314Z","updated":"2019-01-03T14:17:53.314Z","comments":false,"path":"/404.html","permalink":"https://gershonv.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-01-03T14:17:53.680Z","updated":"2019-01-03T14:17:53.680Z","comments":false,"path":"about/index.html","permalink":"https://gershonv.github.io/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425&#123; name: '郭少威', age: '22', sex: '男'， experience: '2018-01-01 至今', education: '本科', email: 'gershonv@163.com', github: 'https://github.com/gershonv', blog: 'gershonv.github.blog', description: '一个在前端浪潮中颠簸的人', character: '友好', skills: [ ['html', 'css', 'Javascript','ES6', 'Node'], ['webpack'], ['git'], ['eslint'], ['Vue 全家桶','element-ui','vux'] ], devTools: [ ['Visual Studio Code', 'Webstorm', 'Sublime Text'], ['Chrome DevTools'] ]&#125; blog1hexo + githubPage + '七牛云'"},{"title":"分类","date":"2019-01-03T14:17:53.694Z","updated":"2019-01-03T14:17:53.694Z","comments":false,"path":"categories/index.html","permalink":"https://gershonv.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-01-03T14:17:53.688Z","updated":"2019-01-03T14:17:53.688Z","comments":false,"path":"books/index.html","permalink":"https://gershonv.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-01-03T14:17:53.700Z","updated":"2019-01-03T14:17:53.700Z","comments":false,"path":"repository/index.html","permalink":"https://gershonv.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-06T08:15:28.000Z","updated":"2019-01-03T14:17:53.707Z","comments":true,"path":"tags/index.html","permalink":"https://gershonv.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Sequelize - CURD","slug":"sequelize-curd","date":"2019-01-10T14:45:06.000Z","updated":"2019-01-10T15:48:00.225Z","comments":true,"path":"2019/01/10/sequelize-curd/","link":"","permalink":"https://gershonv.github.io/2019/01/10/sequelize-curd/","excerpt":"","text":"Createcreate - 创建保存新实例 create(values, [options]) -&gt; Promise. 构建一个新的模型实例，并进行保存。与 build()方法不同的是，此方法除创建新实例外，还会将其保存到对应数据库表中。 1234567// 直接操作dbconst user = await UserModel.create(&#123; name: 'guodada', age: 23, sex: 1, score: 99&#125;) 名称 类型 说明 values Object 无 [options] Object 无 [options.raw=false] Boolean 设置为true时，值会忽略字段和虚拟设置器 [options.isNewRecord=true] Boolean 无 [options.fields] Array 如果设置后，只有列表中区别的列才会进行保存 [options.include] Array 用于构建prefetched/included模型，参见 set [options.onDuplicate] String 无 [options.transaction] Transaction 在事务中执行查询 [options.logging=false] Function 一个用于打印查询时所执行sql的函数 [options.searchPath=DEFAULT] String 指定schema的 search_path (仅 Postgres) [options.benchmark=false] Boolean 当打印SQL日志时同时输出查询执行时间（毫秒） build - 创建新实例 build(values, [options]) -&gt; Instance 123456789// build后对象只存在于内存中，调用save后才操作dbconst user = UserModel.build(&#123; name: 'guodada', age: 23, sex: 1, score: 99&#125;)const result = await user.save()console.log(user.get(&#123; plain: true &#125;)) 名称 类型 说明 values Object 无 [options] Object 无 [options.raw=false] Boolean 设置为true时，值会忽略字段和虚拟设置器 [options.isNewRecord=true] Boolean 无 [options.include] Array 用于构建prefetched/included模型，参见 set Updateupdate - 更新记录 update(values, options) -&gt; Promise.&lt;Array.&lt;affectedCount, affectedRows&gt;&gt; 更新所匹配的多个实例。promise 回调中会返回一个包含一个或两个元素的数组，第一个元素始终表示受影响的行数，第二个元素表示实际影响的行（仅 Postgreoptions.returning 为 true 时受支持） 1await UserModel.update(&#123; name: 'guoxiaoxiao', age: 18 &#125;, &#123; where: &#123; id: 1 &#125; &#125;) 名称 类型 说明 values Object 无 options Object 无 options.where Object 筛选条件 [options.fields] Array 要更新字段，默认为全部 [options.validate=true] Boolean 更新每条记录前进行验证 [options.hooks=true] Boolean 在执行更新前/后创建钩子 [options.individualHooks=false] Boolean 在执行更新前/后为每个实例创建钩子 [options.sideEffects=true] Boolean 是否更新任何虚拟设置 [options.returning=false] Boolean 返回受影响的行 (仅适用于 postgres) [options.limit] Number 要更新的行数 (仅适用于 mysql 和 mariadb) [options.transaction] Transaction 在事务中执行查询 [options.silent=false] Boolean 如果为true，updatedAt字段将不会更新 Read详见 Sequelize - 使用 model 查询数据 Deletedestroy - 删除记录 destroy(options) -&gt; Promise. 删除多个实例，或设置 deletedAt 的时间戳为当前时间（当启用 paranoid 时） 执行成功后返回被删除的行数 1234const deleteRowsCount = await UserModel.destroy(&#123; where: &#123; id: 2 &#125;&#125;)console.log(deleteRowsCount) // 执行成功后返回被删除的行数 名称 | 类型 | 说明| options | Object || ——————————- | ————- | ———————————————————————– || [options.where] | Object | 筛选条件 || [options.hooks=true] | Boolean | 在执行前/后创建钩子 || [options.individualHooks=false] | Boolean | 在执行前/后为每个实例创建钩子 || [options.limit] | Number | 要删除的行数 || [options.force=false] | Boolean | 删除而不是设置 deletedAt 为当前时间戳 (仅启用 paranoid 时适用) || [options.truncate=false] | Boolean | 设置为true时，会使用TRUNCATE代替DELETE FROM，这时会忽略where和limit选项 || [options.cascade=false] | Boolean | 仅适用于连接查询时的TRUNCATE操作，截断所有外键匹配的表 || [options.transaction] | Transaction | 在事务中执行查询 | findOrCreate - 查找或创建 findOrCreate(options) -&gt; Promise.&lt;Instance, created&gt; 查找一行记录，如果不存在则创建实例并保存到数据库中 在这个方法中，如果options对象中没有传入事务，那么会在内部自动创建一个新的事务，以防止在创建完成之前有新匹配查询进入。 12345678910// findOrCreate 返回一个包含已找到或创建的对象的数组，找到或创建的对象和一个布尔值UserModel.findOrCreate(&#123; defaults: &#123; name: 'guoxiaoxiao' &#125;, where: &#123; name: 'guoxiaoxiao' &#125;&#125;).spread((user, created) =&gt; &#123; console.log(user.name, created)&#125;)// 在上面的例子中，\".spread\" 将数组分成2部分，并将它们作为参数传递给回调函数，在这种情况下将它们视为 \"user\" 和 \"created\" 。// 所以“user”将是返回数组的索引0的对象，并且 \"created\" 将等于 \"true\"。） 名称 类型 说明 options Object 无 options.where Object 查询属性 [options.defaults] Object 用于创建新实例的默认值 [options.transaction] Transaction 在事务中执行查询 findCreateFind - 查找或创建 findCreateFind(options) -&gt; Promise.&lt;Instance, created&gt; 效率更高的 findOrCreate，不会在事务中执行。首先会尝试进行查询，如果为空则尝试创建，如果是唯一约束则尝试再次查找。 名称 类型 说明 options Object 无 options.where Object 查询属性 [options.defaults] Object 用于创建新实例的默认值 [options.transaction] Transaction 在事务中执行查询 ps: findOrInitialize - 查找或初始化: 查找一行记录，如果不存在则创建（不保存）实例 insertOrUpdate - 更新或创建 upsert(values, [options]) -&gt; Promise. 创建或更新一行。如果匹配到主键或唯一约束键时会进行更新。 12const isCreate = await TaskModel.insertOrUpdate(&#123; title: '11', content: 'adfadf' &#125;)// isCreate true 创建成功 false 修改成功~ 名称 类型 说明 values Object 无 [options] Object 无 [options.validate=true] Boolean 插入前进行验证 [options.fields=Object.keys(this.attributes)] Array 要插入/更新字段。默认全部 [options.transaction] Transaction 在事务中执行查询 bulkCreate - 创建多条记录 bulkCreate(records, [options]) -&gt; Promise.&lt;Array.&gt; 批量创建并保存多个实例。 处理成功后，会在回调函数中返回一个包含多个实例的数组。 12345 const users = await UserModel.bulkCreate([ &#123; name: 'guo', age: 22, sex: 1 &#125;, &#123; name: 'guo2', age: 12, sex: 0 &#125;, &#123; name: 'guo3', age: 32, sex: 1 &#125;]) 名称 类型 说明 records Array 要创建实例的对象（键/值 对）列表 [options] Object 无 [options.fields] Array 要插入的字段。默认全部 [options.validate=true] Boolean 插入每条记录前进行验证 [options.hooks=true] Boolean 在执行前/后创建钩子 [options.individualHooks=false] Boolean 在执行前/后为每个实例创建钩子 [options.ignoreDuplicates=false] Boolean 忽略重复主键（Postgres不支持） [options.updateOnDuplicate] Array 如果行键已存在是否更新（mysql &amp; mariadb支持）. 默认为更新 [options.transaction] Transaction 在事务中执行查询","categories":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/categories/Sequelize/"}],"tags":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/tags/Sequelize/"}]},{"title":"Sequelize - 使用 model 查询数据","slug":"sequelize-query","date":"2019-01-03T06:56:03.000Z","updated":"2019-01-10T15:51:16.343Z","comments":true,"path":"2019/01/03/sequelize-query/","link":"","permalink":"https://gershonv.github.io/2019/01/03/sequelize-query/","excerpt":"Sequelize 中有两种查询：使用 Model（模型）中的方法查询和使用 sequelize.query() 进行基于 SQL 语句的原始查询。","text":"Sequelize 中有两种查询：使用 Model（模型）中的方法查询和使用 sequelize.query() 进行基于 SQL 语句的原始查询。 下面是事先创建好的数据： 123456789101112mysql&gt; select * from users;+----+----------+------+------+-------+| id | name | age | sex | score |+----+----------+------+------+-------+| 1 | guodada0 | 15 | 0 | 60 || 2 | guodada1 | 16 | 1 | 80 || 3 | guodada2 | 17 | 0 | 55 || 4 | guodada3 | 18 | 1 | 87 || 5 | guodada4 | 19 | 0 | 73 || 6 | guodada5 | 20 | 1 | 22 |+----+----------+------+------+-------+6 rows in set (0.00 sec) 定义的 model 12345678910const UserModel = sequelize.define( 'user', &#123; name: Sequelize.STRING, age: Sequelize.INTEGER, sex: Sequelize.INTEGER, score: Sequelize.INTEGER &#125;, &#123; timestamps: false &#125;) 查询多项 (findAll)123456const result = await UserModel.findAll() // result 将是所有 UserModel 实例的数组// the same asconst result = await UserModel.all()//... 限制字段查询时，如果只需要查询模型的部分属性，可以在通过在查询选项中指定 attributes 实现。该选项是一个数组参数，在数组中指定要查询的属性即可，这些要查询的属性就表示要在数据库查询的字段： 123Model.findAll(&#123; attributes: ['foo', 'bar']&#125;) 字段重命名查询属性（字段）可以通过传入一个嵌套数据进行重命名： 12345Model.findAll(&#123; attributes: ['foo', ['bar', 'baz']]&#125;)// SELECT foo, bar AS baz ... demo 123456789const results = await UserModel.findAll(&#123; attributes: [['name', 'username'], 'age', 'score']&#125;)// [&#123;\"username\":\"guodada0\",\"age\":15,\"score\":60&#125;,&#123;\"username\":\"guodada1\",\"age\":16,\"score\":80&#125; ...]ctx.body = results// 访问查询结果 通过 instance.get('xxx')console.log(results[0]['username'], results[0].get('username')) // undefind, 'guodada0' 指定筛选条件 (where)在模型的 find/finAll 或 updates/destroys 操作中，可以指定一个 where 选项以指定筛选条件， where 是一个包含属性/值对对象，sequelize 会根据此对象生产查询语句的筛选条件。 123456789101112const results = await UserModel.findAll(&#123; where: &#123; age: 18, name: 'guodada3' &#125;&#125;) // SELECT * FROM `users` AS `user` WHERE `user`.`age` = 18 AND `user`.`name` = 'guodada3';await UserModel.destroy(&#123; where: &#123; name: 'guodada3' &#125;&#125;) // DELETE FROM `users` WHERE name = 'guodada3'// ... 复合过滤 / OR / NOT 查询123456789101112131415161718192021222324$and: &#123;a: 5&#125; // AND (a = 5)$or: [&#123;a: 5&#125;, &#123;a: 6&#125;] // (a = 5 OR a = 6)$gt: 6, // &gt; 6$gte: 6, // &gt;= 6$lt: 10, // &lt; 10$lte: 10, // &lt;= 10$ne: 20, // != 20$not: true, // IS NOT TRUE$between: [6, 10], // BETWEEN 6 AND 10$notBetween: [11, 15], // NOT BETWEEN 11 AND 15$in: [1, 2], // IN [1, 2]$notIn: [1, 2], // NOT IN [1, 2]$like: '%hat', // LIKE '%hat'$notLike: '%hat' // NOT LIKE '%hat'$iLike: '%hat' // ILIKE '%hat' (case insensitive) (PG only)$notILike: '%hat' // NOT ILIKE '%hat' (PG only)$like: &#123; $any: ['cat', 'hat']&#125; // LIKE ANY ARRAY['cat', 'hat'] - also works for iLike and notLike$overlap: [1, 2] // &amp;&amp; [1, 2] (PG array overlap operator)$contains: [1, 2] // @&gt; [1, 2] (PG array contains operator)$contained: [1, 2] // &lt;@ [1, 2] (PG array contained by operator)$any: [2,3] // ANY ARRAY[2, 3]::INTEGER (PG only)$col: 'user.organization_id' // = \"user\".\"organization_id\", with dialect specific column identifiers, PG in this example $like: 模糊查询 %锅 以 锅 结尾的。 %锅% 包含 锅 的 $in: [10, 11] - 值为 10 或 11 demo123456789101112131415161718// SELECT * FROM `users` AS `user` WHERE `user`.`age` &gt; 18 AND `user`.`name` LIKE '%5';const results = await UserModel.findAll(&#123; where: &#123; age: &#123; $gt: 18 &#125;, name: &#123; $like: '%5' &#125; &#125;&#125;)// SELECT * FROM `users` AS `user` WHERE (`user`.`age` &lt; 1000 OR `user`.`age` IS NULL) AND `user`.`name` LIKE '%5';const results = await UserModel.findAll(&#123; where: &#123; age: &#123; $in: [15, 20], $or: &#123; $lt: 1000, $eq: null &#125; &#125;, name: &#123; $like: '%5' &#125; &#125;&#125;) 分页与限制返回结果数查询进，我们可以使用 limit 限制返回结果条数，并可以通过 offset 来设置查询偏移（跳过）量，通过这两个属性我们可以实现分页查询的功能： 12345678// 获取 10 条数据（实例）UserModel.findAll(&#123; limit: 10 &#125;)// 跳过 8 条数据（实例）UserModel.findAll(&#123; offset: 8 &#125;)// 跳过 5 条数据并获取其后的 5 条数据（实例）UserModel.findAll(&#123; offset: 5, limit: 5 &#125;) 排序order 选项用于查询结果的排序数据。排序时应该传入一个包含属性-排序方向的元组/数组，以保证正确的转义： 12345678910111213141516const result = await UserModel.findAll(&#123; order: sequelize.literal('name DESC') // 降序&#125;)// demo2const result = await UserModel.findAll(&#123; order: [sequelize.literal('score DESC'), sequelize.literal('name DESC')]&#125;)// 按 max(age) DESC 排序[sequelize.fn('max', sequelize.col('age')), 'DESC'],// 按相关联的User 模型的 name 属性排序[ArticleModel, 'name', 'DESC']// ... 查询单项1234567891011121314151617181920// findconst result = await UserModel.find(&#123; where: &#123; id: 1 &#125;&#125;)console.log(result.name, result.get('name')) // guodada0 guodada0// findOneconst result = await UserModel.findOne(&#123; where: &#123; id: 1 &#125;&#125;)console.log(result.name, result.get('name')) // guodada0 guodada0// findByIdconst result = await UserModel.findById(1)console.log(result.name, result.get('name')) // guodada0 guodada0// findByPkconst result = await UserModel.findByPk(1)//... 查找并创建 (findOrCreate)findOrCreate 可用于检测一个不确定是否存在的元素，如果存在则返回记录，不存在时会使用提供的默认值新建记录。 1234567891011121314UserModel.findOrCreate(&#123; where: &#123; name: 'guodada' &#125;, defaults: &#123; age: 23, sex: 1, score: 99 &#125;&#125;).spread((user, created) =&gt; &#123; console.log(user.get('name')) // guodada console.log(created) // 是否创建&#125;)// INSERT INTO `users` (`id`,`name`,`age`,`sex`,`score`)// VALUES (DEFAULT,'guodada',23,1,99); 分页查询 (findAndCountAll)findAndCountAll - 结合了 findAll 和 count 处理程序成功将始终接收具有两个属性的对象： count - 一个整数，总数记录匹配 where 语句和关联的其它过滤器 rows - 一个数组对象，记录在 limit 和 offset 范围内匹配 where 语句和关联的其它过滤器 1234567891011121314const result = await UserModel.findAndCountAll(&#123; where: &#123; age: &#123; $gte: 18 // 大于等于18 &#125; &#125;, offset: 1, // 偏移量，可以理解为当前页数 limit: 15 // 可以理解为 pageSize , 一页有多少数据&#125;)// count 记录数 | row 记录console.log(result.count, result.rows[0].get())// SELECT * FROM `users` AS `user` WHERE `user`.`age` &gt;= 18 LIMIT 1, 15; 支持 include它支持 include。 只有标记为 required 的 include 将被添加到计数部分： 假设你想找 User 中 发布过 article 的记录 12345678910111213141516171819202122232425262728const UserModel = sequelize.define( 'user', &#123; name: Sequelize.STRING, age: Sequelize.INTEGER, sex: Sequelize.INTEGER, score: Sequelize.INTEGER &#125;, &#123; timestamps: false &#125;)const ArticleModel = sequelize.define('article', &#123; title: Sequelize.STRING, content: Sequelize.STRING&#125;)UserModel.hasMany(ArticleModel) // 关联模型ArticleModel.belongsTo(UserModel, &#123; constraints: false&#125;)const result = await UserModel.findAndCountAll(&#123; include: [&#123; model: ArticleModel, required: true &#125;], offset: 1, limit: 5&#125;)console.log(result.count) // 3 result.row: 123456789101112131415161718192021&#123; \"count\": 3, \"rows\": [ &#123; \"id\": 1, \"name\": \"guodada0\", \"age\": 15, \"sex\": 0, \"score\": 60, \"article\": &#123; \"id\": 1, \"title\": \"title1\", \"content\": \"aaa\", \"userId\": 1, \"createdAt\": \"2019-01-07T08:51:13.000Z\", \"updatedAt\": \"2019-01-07T08:51:13.000Z\" &#125; &#125; //... ]&#125; 因为 ArticleModel 的 include 有 required 设置，这将导致内部连接，并且只有具有 ArticleModel 的用户将被计数。如果我们从 include 中删除 required，那么有和没有 ArticleModel 的用户都将被计数。在 include 中添加一个 where 语句会自动使它成为 required： 1234567891011const result = await UserModel.findAndCountAll(&#123; include: [&#123; model: ArticleModel &#125;]&#125;)console.log(result.count) // 7const result = await UserModel.findAndCountAll(&#123; include: [&#123; model: ArticleModel, where: &#123; userId: 2 &#125; &#125;]&#125;)console.log(result.count) // 2 聚合查询SQL 中的分组查询mysql-聚合函数 SQL 查询中，通 GROUP BY 语名实现分组查询。GROUP BY 子句要和聚合函数配合使用才能完成分组查询，在 SELECT 查询的字段中，如果没有使用聚合函数就必须出现在 ORDER BY 子句中。分组查询后，查询结果为一个或多个列分组后的结果集。 12345SELECT 列名, 聚合函数(列名)FROM 表名WHERE 列名 operator valueGROUP BY 列名[HAVING 条件表达式] [WITH ROLLUP] 在以上语句中： 聚合函数 - 分组查询通常要与聚合函数一起使用，聚合函数包括： COUNT()-用于统计记录条数 SUM()-用于计算字段的值的总和 AVG()-用于计算字段的值的平均值 MAX-用于查找查询字段的最大值 MIX-用于查找查询字段的最小值 GROUP BY 子名-用于指定分组的字段 HAVING 子名-用于过滤分组结果，符合条件表达式的结果将会被显示 WITH ROLLUP 子名-用于指定追加一条记录，用于汇总前面的数据 sum(field, [options])Sequelize 提供了聚合函数，可以直接对模型进行聚合查询： aggregate(field, aggregateFunction, [options])-通过指定的聚合函数进行查询 sum(field, [options])-求和 count(options: Object)-统计查询结果数 max(field, [options])-查询最大值 min(field, [options])-查询最小值 以上这些聚合函数中，可以通过 options.attributes、options.attributes 属性指定分组相关字段，并可以通过 options.having 指定过滤条件，但没有直接指定 WITH ROLLUP 子句的参数。 使用.sum()查询订单数量大于 1 的用户订单额： 123456789101112const result = await OrderModel.sum('price', &#123; attributes: ['name', [sequelize.fn('COUNT', sequelize.col('price')), 'sum']], group: 'name', plain: false, // 执行的查询类型，sequelize会根据这个类型对返回结果格式化。 having: &#123; $and: [sequelize.literal('COUNT(name) &gt; 1')] &#125;&#125;)// SELECT `name`, SUM(`price`) AS `sum` FROM `orders` AS `order` GROUP BY `name` HAVING (COUNT(name) &gt; 1);// [ &#123; name: 'guo', sum: '44' &#125;, &#123; name: 'guo2', sum: '22' &#125; ] plain:执行的查询类型，sequelize 会根据这个类型对返回结果格式化 sequelize.literal: 创建一个字面量对象，该值不会转义 除直接使用聚合函数外，也可以在 findAll()等方法中，指定聚合查询相关参数实现聚合查询。查询时，同样可以通过通过 options.attributes、options.attributes 属性指定分组相关字段，并可以通过 options.having 指定过滤条件。与直接使用聚合函数查询不一样，通过参数构建聚合查询时，要以数组或对象形式设置 options.attributes 参数中的聚合字段，并需要通过 sequelize.fn()方法传入聚合函数。 12345678const result = await OrderModel.findAll(&#123; attributes: ['name', [sequelize.fn('SUM', sequelize.col('price')), 'sum']], group: 'name', having: &#123; $and: [sequelize.literal('COUNT(name) &gt; 1')] &#125;, raw: true // row 对查询结果进行格式化， false 返回 instance&#125;) sequelize.fn() - 函数调用 1sequelize.fn(fn, args) -&gt; Sequelize.fn 创建于一个相当于数据库函数的对象。该函数可用于搜索查询的 where 和 order 部分，以及做为列定义的默认值。如果想在列中引用你定义的函数，就要使用 sequelize.col，这样列就能正确的解析，而不是解析为字符串。如，将 username 字段值解析为大写形式： 123instance.updateAttributes(&#123; username: self.sequelize.fn('upper', self.sequelize.col('username'))&#125;) sequelize.col() - 列对象 创建一个相当于数据库列的对象。这个方法经常结合 sequelize.fn 使用，它可以保证将列名正确的传递给该方法，而不是经过转义。 count(options: Object)123const result = await OrderModel.count(&#123; where: &#123; price: 24 &#125;&#125;) max/min12345const result = await OrderModel.max('price', &#123; where: &#123; price: &#123; $lt: 23 &#125; &#125;&#125;) 原始查询原始查询 有时会使用原始查询或执行已准备好的 SQL 语句，这时可以用 Sequlize 提供的工具函数 sequelize.query 来实现。 1const result = await sequelize.query('SELECT * FROM users', &#123; model: UserModel &#125;) 查询参数替换原始查询中有两种替换查询参数的方法，以:开头的参数的形式替换或以不命名以?替换。在选项对象中传递参数： 如果传递一个数组，? 会按数组的顺序被依次替换 巢传递一个对象，:key 将会用对象的键替换。如果对象中未找到指定键，则会引发异常（反之亦然） 1234567891011121314sequelize .query('SELECT * FROM projects WHERE status = ?', &#123; replacements: ['active'], type: sequelize.QueryTypes.SELECT &#125;) .then(function(projects) &#123; console.log(projects) &#125;)sequelize .query('SELECT * FROM projects WHERE status = :status ', &#123; replacements: &#123; status: 'active' &#125;, type: sequelize.QueryTypes.SELECT &#125;) .then(function(projects) &#123; console.log(projects) &#125;) 参数绑定参数绑定类似于参数替换。尤其是参数替换会在发送到数据库前被 sequelize 转义和替换，而参数绑定会被发送到 SQL 查询文本外。 只有 SQLite 和 PostgreSQL 支持参数绑定，其它类型数据库都会将其插入到 SQL 查询，并以相同的方式进行参数替换。参数绑定可以使用$1、$2……或\\$key 的形式： 如果传入的是数组，\\$1 会绑定到数组听第 1 个参数 (bind[0]) 如果传入一个对象，$key 会绑定到 object[&#39;key&#39;]。每个 key 必须以非数字的字符开始。$1 不是个有效的 key，尽管 object[‘1’] 是存在的。 在使用\\$$时，不会被转义而是将$做为一个字面量使用。 传入的数组或对象必须包含所有绑定值，否则 Sequelize 会抛出异常。这同样适用于数据库可能会忽略绑定参数的情况下。 数据库可能会做进一步限制，绑定参数不能使用数据库关键字，也不能是表或列名，它在引用文本或数据时也可能被忽略。在 PostgreSQL 中，如果不能从上下文\\$1::varchar 中推断类型，那么也需要进行类型转换 1234567891011121314151617sequelize .query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $1', &#123; bind: ['active'], type: sequelize.QueryTypes.SELECT &#125;) .then(function(projects) &#123; console.log(projects) &#125;)sequelize .query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $status', &#123; bind: &#123; status: 'active' &#125;, type: sequelize.QueryTypes.SELECT &#125;) .then(function(projects) &#123; console.log(projects) &#125;)","categories":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/categories/Sequelize/"}],"tags":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/tags/Sequelize/"}]},{"title":"Sequelize - associations","slug":"sequelize-associations","date":"2019-01-03T06:36:03.000Z","updated":"2019-01-10T15:48:38.719Z","comments":true,"path":"2019/01/03/sequelize-associations/","link":"","permalink":"https://gershonv.github.io/2019/01/03/sequelize-associations/","excerpt":"本部分描述了 Sequelize 中的各种关联类型。 Sequelize 中有四种类型的关联 BelongsTo HasOne HasMany BelongsToMany 基本概念Source &amp; Target我们首先从一个基本概念开始，你将会在大多数关联中使用 source 和 target 模型。 假设您正试图在两个模型之间添加关联。 这里我们在 users 和 articles 之间添加一个 hasOne 关联。 123456789101112131415const UserModel = sequelize.define( 'user', &#123; name: Sequelize.STRING, age: Sequelize.INTEGER &#125;, &#123; timestamps: false &#125;)const ArticleModel = sequelize.define('article', &#123; title: Sequelize.STRING, content: Sequelize.STRING&#125;)UserModel.hasOne(ArticleModel)","text":"本部分描述了 Sequelize 中的各种关联类型。 Sequelize 中有四种类型的关联 BelongsTo HasOne HasMany BelongsToMany 基本概念Source &amp; Target我们首先从一个基本概念开始，你将会在大多数关联中使用 source 和 target 模型。 假设您正试图在两个模型之间添加关联。 这里我们在 users 和 articles 之间添加一个 hasOne 关联。 123456789101112131415const UserModel = sequelize.define( 'user', &#123; name: Sequelize.STRING, age: Sequelize.INTEGER &#125;, &#123; timestamps: false &#125;)const ArticleModel = sequelize.define('article', &#123; title: Sequelize.STRING, content: Sequelize.STRING&#125;)UserModel.hasOne(ArticleModel) 相当于： 1234567891011121314151617CREATE TABLE IF NOT EXISTS `users` ( `id` INTEGER NOT NULL auto_increment , `name` VARCHAR(255), `age` INTEGER, PRIMARY KEY (`id`)) ENGINE=InnoDB;CREATE TABLE IF NOT EXISTS `articles` ( `id` INTEGER NOT NULL auto_increment , `title` VARCHAR(255), `content` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `userId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB; UserModel（函数被调用的模型）是 source 。 ArticleModel 模型（作为参数传递的模型）是 target 。 即 articles 表的 userId 依赖于 users 表的 id 此时删除 users 表（source）, 就会报错了 Cannot drop table ‘users’ referenced by a foreign key constraint ‘articles_ibfk_1’ on table ‘articles’. 外键当您在模型中创建关联时，会自动创建带约束的外键引用。 下面是设置： 12345const TaskModel = sequelize.define('task', &#123; title: Sequelize.STRING &#125;)const UserModel = sequelize.define('user', &#123; name: Sequelize.STRING &#125;, &#123; timestamps: false &#125;)UserModel.hasMany(TaskModel) // 将会添加 userId 到 TaskModelTaskModel.belongsTo(UserModel) // 也将会添加 userId 到 TaskModel 将生成以下 SQL： 12345678910111213141516CREATE TABLE IF NOT EXISTS `users` ( `id` INTEGER NOT NULL auto_increment, `name` VARCHAR(255), PRIMARY KEY (`id`)) ENGINE = InnoDB;CREATE TABLE IF NOT EXISTS `tasks` ( `id` INTEGER NOT NULL auto_increment, `title` VARCHAR(255), `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `userId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE = InnoDB; tasks 和 users 模型之间的关系通过在 tasks 表上注入 userId 外键，并将其标记为对 users 表的引用。默认情况下，如果引用的用户被删除，userId 将被设置为 NULL，如果更新了 userId，则更新 userId。 这些选项可以通过将 onUpdate 和 onDelete 选项传递给关联调用来覆盖。验证选项是RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL。 对于 1:1 和 1:m 关联，默认选项是 SET NULL 用于删除，CASCADE 用于更新。对于 n:m，两者的默认值是 CASCADE。 这意味着，如果您从 n:m 关联的一侧删除或更新一行，则引用该行的连接表中的所有行也将被删除或更新。 循环依赖 &amp; 禁用约束在表之间添加约束意味着当使用 sequelize.sync 时，表必须以特定顺序在数据库中创建表。如果 Task 具有对 User 的引用，users 表必须在创建 tasks 表之前创建。这有时会导致循环引用，那么 sequelize 将无法找到要同步的顺序。想象一下文档和版本的场景。 一个文档可以有多个版本，并且为了方便起见，文档引用了它的当前版本。 12345678const Document = sequelize.define('document', &#123; author: Sequelize.STRING &#125;, &#123; timestamps: false &#125;)const Version = sequelize.define('version', &#123; timestamp: Sequelize.DATE &#125;)Document.hasMany(Version) // 这将 documentId 属性添加到 versionDocument.belongsTo(Version, &#123; as: 'Current', foreignKey: 'currentVersionId'&#125;) // 这将 currentVersionId 属性添加到 document 但是，上面的代码将导致以下错误: Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&gt; versions =&gt; documents. 为了缓解这一点，我们可以向其中一个关联传递 constraints: false： 123456Document.hasMany(Version)Document.belongsTo(Version, &#123; as: 'Current', foreignKey: 'currentVersionId', constraints: false&#125;) 这将可以让我们正确地同步表： 123456789101112131415161718CREATE TABLE IF NOT EXISTS `documents` ( `id` INTEGER NOT NULL auto_increment, `author` VARCHAR(255), `currentVersionId` INTEGER, PRIMARY KEY (`id`)) ENGINE = InnoDB;CREATE TABLE IF NOT EXISTS `versions` ( `id` INTEGER NOT NULL auto_increment, `timestamp` DATETIME, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `documentId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`documentId`) REFERENCES `documents` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE = InnoDB; 无限制地执行外键引用有时您可能想引用另一个表，而不添加任何约束或关联。 在这种情况下，您可以手动将参考属性添加到您的模式定义中，并标记它们之间的关系。 123456789101112131415161718192021222324252627282930313233343536373839const Trainer = sequelize.define('trainer', &#123; firstName: Sequelize.STRING, lastName: Sequelize.STRING&#125;)// Series 将有一个 trainerId = Trainer.id 外参考键// 之后我们调用 Trainer.hasMany(series)const Series = sequelize.define('series', &#123; title: Sequelize.STRING, subTitle: Sequelize.STRING, description: Sequelize.TEXT, // 用 `Trainer` 设置外键关系（hasMany） trainerId: &#123; type: Sequelize.INTEGER, references: &#123; model: Trainer, key: 'id' &#125; &#125;&#125;)// Video 将有 seriesId = Series.id 外参考键// 之后我们调用 Series.hasOne(Video)const Video = sequelize.define('video', &#123; title: Sequelize.STRING, sequence: Sequelize.INTEGER, description: Sequelize.TEXT, // 用 `Series` 设置关系(hasOne) seriesId: &#123; type: Sequelize.INTEGER, references: &#123; model: Series, // 既可以是表示表名的字符串，也可以是 Sequelize 模型 key: 'id' &#125; &#125;&#125;)Series.hasOne(Video)Trainer.hasMany(Series) 一对一关联一对一关联是通过单个外键连接的两个模型之间的关联。 BelongsToBelongsTo 关联是在 source model 上存在一对一关系的外键的关联。 一个简单的例子是 Player 通过 player 的外键作为 Team 的一部分。 1234const Player = sequelize.define('player', &#123;&#125;, &#123; timestamps: false &#125;)const Team = sequelize.define('team', &#123;&#125;, &#123; timestamps: false &#125;)Player.belongsTo(Team) // 将向 Player 添加一个 teamId 属性以保存 Team 的主键值 12345678910111213CREATE TABLE IF NOT EXISTS `teams` ( `id` INTEGER NOT NULL auto_increment, PRIMARY KEY (`id`)) ENGINE = InnoDB;CREATE TABLE IF NOT EXISTS `players` ( `id` INTEGER NOT NULL auto_increment, `teamId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`teamId`) REFERENCES `teams` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE = InnoDB; 外键/目标键默认情况下，将从目标模型名称和目标主键名称生成 belongsTo 关系的外键。 默认的样式是 camelCase（小驼峰），但是如果源模型配置为 underscored: true（下划线） ，那么将使用字段 snake_case 创建 foreignKey。 123456789const User = sequelize.define('user', &#123;&#125;, &#123; timestamps: false, underscored: true &#125;)const Company = sequelize.define('company', &#123; uuid: &#123; type: Sequelize.UUID, primaryKey: true &#125;&#125;)User.belongsTo(Company) // 将用字段 company_uuid 添加 companyUuid 到 user 在已定义 as 的情况下，将使用它代替目标模型名称。 1234const User = sequelize.define('user', &#123;&#125;, &#123; timestamps: false &#125;)const UserRole = sequelize.define('userRole', &#123;&#125;, &#123; timestamps: false &#125;)User.belongsTo(UserRole, &#123; as: 'role' &#125;) // 将 role 添加到 user 而不是 userRole 生成的 users 表 12345678CREATE TABLE IF NOT EXISTS `users` ( `id` INTEGER NOT NULL auto_increment, `roleId` INTEGER, PRIMARY KEY (`id`), FOREIGN KEY (`roleId`) REFERENCES `userRoles` (`id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE = InnoDB; 在所有情况下，默认外键可以用 foreignKey 选项覆盖。 当使用外键选项时，Sequelize 将按原样使用： 1234const User = sequelize.define('user', &#123;&#125;, &#123; timestamps: false &#125;)const Company = sequelize.define('company', &#123;&#125;, &#123; timestamps: false &#125;)User.belongsTo(Company, &#123; foreignKey: 'fk_company' &#125;) 目标键 1User.belongsTo(Company, &#123; foreignKey: 'fk_companyname', targetKey: 'id' &#125;) 效果： 123456789101112const User = sequelize.define( 'user', &#123; fk_companyname: &#123; references: &#123; model: Company, key: 'id' &#125; &#125; &#125;, &#123; timestamps: false &#125;) HasOneHasOne 关联是在 target model 上存在一对一关系的外键的关联。 12345678910111213141516171819const User = sequelize.define('user', &#123;&#125;, &#123; timestamps: false &#125;)const Project = sequelize.define('project', &#123;&#125;, &#123; timestamps: false &#125;)// 单向关联Project.hasOne(User)// the same asconst User = sequelize.define( 'user', &#123; projectId: &#123; references: &#123; model: Project, key: 'id' &#125; &#125; &#125;, &#123; timestamps: false &#125;) 1234567891011121314151617181920212223// 你也可以定义外键，例如 如果您已经有一个现有的数据库并且想要处理它：Project.hasOne(User, &#123; foreignKey: 'initiator_id' &#125;)// 因为Sequelize将使用模型的名称（define的第一个参数）作为访问器方法，// 还可以将特殊选项传递给hasOne：Project.hasOne(User, &#123; as: 'Initiator' &#125;)// 或者让我们来定义一些自己的参考const Person = sequelize.define('person', &#123;&#125;)Person.hasOne(Person, &#123; as: 'Father' &#125;) // 这会将属性 FatherId 添加到 Person// also possible:Person.hasOne(Person, &#123; as: 'Father', foreignKey: 'DadId' &#125;) // 这将把属性 DadId 添加到 Person// 在这两种情况下，你都可以：Person.setFatherPerson.getFather// 如果你需要联结表两次，你可以联结同一张表Team.hasOne(Game, &#123; as: 'HomeTeam', foreignKey: 'homeTeamId' &#125;)Team.hasOne(Game, &#123; as: 'AwayTeam', foreignKey: 'awayTeamId' &#125;)Game.belongsTo(Team) 即使它被称为 hasOne 关联，对于大多数 1：1 关系，您通常需要 BelongsTo 关联，因为 BelongsTo 将会在 hasOne 将添加到目标的源上添加 foreignKey。 源键源关键是源模型中的属性，它的目标模型指向外键属性。 默认情况下，hasOne 关系的源键将是源模型的主要属性。 要使用自定义属性，请使用 sourceKey 选项。 123456const User = sequelize.define('user', &#123;&#125;)const Company = sequelize.define('company', &#123;&#125;)// 将 companyName 属性添加到 User// 使用 Company 的 name 属性作为源属性Company.hasOne(User, &#123; foreignKey: 'companyName', sourceKey: 'name' &#125;) HasOne 和 BelongsTo 之间的区别在 Sequelize 1：1 关系中可以使用 HasOne 和 BelongsTo 进行设置。 它们适用于不同的场景。 让我们用一个例子来研究这个差异。 假设我们有两个表可以链接 Player 和 Team 。 让我们定义他们的模型。 12const Player = sequelize.define('player', &#123;&#125;, &#123; timestamps: false &#125;)const Team = sequelize.define('team', &#123;&#125;, &#123; timestamps: false &#125;) 当我们连接 Sequelize 中的两个模型时，我们可以将它们称为一对 source 和 target 模型。像这样 将 Player 作为 source 而 Team 作为 target 123Player.belongsTo(Team)//或Player.hasOne(Team) 将 Team 作为 source 而 Player 作为 target 123Team.belongsTo(Player)//OrTeam.hasOne(Player) HasOne 和 BelongsTo 将关联键插入到不同的模型中。 HasOne 在 target 模型中插入关联键，而 BelongsTo 将关联键插入到 source 模型中。 下是一个示例，说明了 BelongsTo 和 HasOne 的用法。 12345678910111213141516171819202122232425const Player = sequelize.define('player', &#123;&#125;, &#123; timestamps: false &#125;)const Team = sequelize.define('team', &#123;&#125;, &#123; timestamps: false &#125;)const Coach = sequelize.define('coach', &#123;&#125;, &#123; timestamps: false &#125;)Player.belongsTo(Team) // `teamId` 将被添加到 Player / Source 模型中Coach.hasOne(Team) // `coachId` 将被添加到 Team / Target 模型中// the same asconst Player = sequelize.define('player', &#123; teamId: &#123; references: &#123; model: Team, key: 'id' &#125; &#125;&#125;)const Team = sequelize.define('team', &#123; coachId: &#123; references: &#123; model: Coach, key: 'id' &#125; &#125;&#125;) 假设我们的 Player 模型有关于其团队的信息为 teamId 列。关于每个团队的 Coach 的信息作为 coachId 列存储在 Team 模型中。这两种情况都需要不同种类的 1：1 关系，因为外键关系每次出现在不同的模型上。 当关于关联的信息存在于 source 模型中时，我们可以使用 belongsTo。 在这种情况下，Player 适用于belongsTo，因为它具有 teamId 列。 当关于关联的信息存在于 target 模型中时，我们可以使用 hasOne。 在这种情况下， Coach 适用于 hasOne ，因为 Team 模型将其 Coach 的信息存储为 coachId 字段。 一对多关联 (hasMany)一对多关联将一个来源与多个目标连接起来。 而多个目标接到同一个特定的源。 123456const User = sequelize.define('user', &#123;&#125;, &#123; timestamps: false &#125;)const Project = sequelize.define('project', &#123;&#125;, &#123; timestamps: false &#125;)// 好。 现在，事情变得更加复杂（对用户来说并不真实可见）。// 首先我们来定义一个 hasMany 关联Project.hasMany(User, &#123; as: 'Workers' &#125;) 这会将 projectId 属性添加到 User。 根据您强调的设置，表中的列将被称为 projectId 或 project_id。 Project 的实例将获得访问器 getWorkers 和 setWorkers。 有时您可能需要在不同的列上关联记录，您可以使用 sourceKey 选项： 123456const City = sequelize.define('city', &#123; countryCode: Sequelize.STRING &#125;)const Country = sequelize.define('country', &#123; isoCode: Sequelize.STRING &#125;)// 在这里，我们可以根据国家代码连接国家和城市Country.hasMany(City, &#123; foreignKey: 'countryCode', sourceKey: 'isoCode' &#125;)City.belongsTo(Country, &#123; foreignKey: 'countryCode', targetKey: 'isoCode' &#125;) 到目前为止，我们解决了单向关联。 但我们想要更多！ 让我们通过在下一节中创建一个多对多的关联来定义它。 多对多关联 (BelongsToMany)多对多关联用于将源与多个目标相连接。 此外，目标也可以连接到多个源。 12Project.belongsToMany(User, &#123; through: 'UserProject' &#125;)User.belongsToMany(Project, &#123; through: 'UserProject' &#125;) 这将创建一个名为 UserProject 的新模型，具有等效的外键 projectId 和 userId。 属性是否为 camelcase 取决于由表（在这种情况下为 User 和 Project）连接的两个模型。 123456789CREATE TABLE IF NOT EXISTS `UserProject` ( `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, `projectId` INTEGER, `userId` INTEGER, PRIMARY KEY (`projectId`, `userId`), FOREIGN KEY (`projectId`) REFERENCES `projects` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY (`userId`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE = InnoDB; 定义 through 为 required。 Sequelize 以前会尝试自动生成名称，但并不总是导致最合乎逻辑的设置。 这将添加方法 getUsers,setUsers, addUser, addUsers 到 Project, 还有 getProjects, setProjects, addProject, 和 addProjects 到 User. 有时，您可能需要在关联中使用它们时重命名模型。 让我们通过使用别名（as）选项将 users 定义为 workers 而 projects 定义为 t asks。 我们还将手动定义要使用的外键： 12User.belongsToMany(Project, &#123; as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId' &#125;)Project.belongsToMany(User, &#123; as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' &#125;) foreignKey 将允许你在 through 关系中设置 source model 键。 otherKey 将允许你在 through 关系中设置 target model 键。 1User.belongsToMany(Project, &#123; as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId' &#125;) 当然你也可以使用 belongsToMany 定义自我引用： 12Person.belongsToMany(Person, &#123; as: 'Children', through: 'PersonChildren' &#125;)// 这将创建存储对象的 ID 的表 PersonChildren。 如果您想要连接表中的其他属性，则可以在定义关联之前为连接表定义一个模型，然后再说明它应该使用该模型进行连接，而不是创建一个新的关联： 12345678const User = sequelize.define('user', &#123;&#125;)const Project = sequelize.define('project', &#123;&#125;)const UserProjects = sequelize.define('userProjects', &#123; status: DataTypes.STRING&#125;)User.belongsToMany(Project, &#123; through: UserProjects &#125;)Project.belongsToMany(User, &#123; through: UserProjects &#125;) 要向 user 添加一个新 project 并设置其状态，您可以将额外的 options.through 传递给 setter，其中包含连接表的属性 1user.addProject(project, &#123; through: &#123; status: 'started' &#125; &#125;) 默认情况下，上面的代码会将 projectId 和 userId 添加到 UserProjects 表中， 删除任何先前定义的主键属性 - 表将由两个表的键的组合唯一标识，并且没有其他主键列。 要在 UserProjects 模型上强添加一个主键，您可以手动添加它。 12345678const UserProjects = sequelize.define('userProjects', &#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true &#125;, status: DataTypes.STRING&#125;) 使用多对多你可以基于 through 关系查询并选择特定属性。 例如通过 through 使用 findAll 1234567891011User.findAll(&#123; include: [ &#123; model: Project, through: &#123; attributes: ['createdAt', 'startedAt', 'finishedAt'], where: &#123; completed: true &#125; &#125; &#125; ]&#125;) 参考 模型（表）之间的关系/关联 Associations - 关联","categories":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/categories/Sequelize/"}],"tags":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/tags/Sequelize/"}]},{"title":"Sequelize - model definition","slug":"sequelize-modelDefinition","date":"2019-01-03T06:35:03.000Z","updated":"2019-01-08T12:34:04.390Z","comments":true,"path":"2019/01/03/sequelize-modelDefinition/","link":"","permalink":"https://gershonv.github.io/2019/01/03/sequelize-modelDefinition/","excerpt":"Model definition - 模型定义Sequelize 使用 define 方法定义模型和表之间的映射，Sequelize 将默认添加 createdAt 和 updatedAt 属性。因此，您将能够知道数据库条目何时进入数据库以及最后一次更新时。model 定义格式为 sequelize.define(&#39;name&#39;, {attributes}, {configuration})： 12const User = sequelize.define('user')User.sync(&#123; force: true &#125;) 上式代码在数据库中的执行命令为： 12345678DROP TABLE IF EXISTS `users`;CREATE TABLE IF NOT EXISTS `users` ( `id` INTEGER NOT NULL auto_increment , `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB;","text":"Model definition - 模型定义Sequelize 使用 define 方法定义模型和表之间的映射，Sequelize 将默认添加 createdAt 和 updatedAt 属性。因此，您将能够知道数据库条目何时进入数据库以及最后一次更新时。model 定义格式为 sequelize.define(&#39;name&#39;, {attributes}, {configuration})： 12const User = sequelize.define('user')User.sync(&#123; force: true &#125;) 上式代码在数据库中的执行命令为： 12345678DROP TABLE IF EXISTS `users`;CREATE TABLE IF NOT EXISTS `users` ( `id` INTEGER NOT NULL auto_increment , `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; base demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const Bar = sequelize.define('bar', &#123;&#125;)const Foo = sequelize.define('foo', &#123; id: &#123; type: Sequelize.INTEGER, field: 'fooId', // 存入数据库中的字段，model 中还是使用 id =&gt; foo.id autoIncrement: true, // 是否自增 primaryKey: true // 是否为主键 &#125;, age: &#123; type: Sequelize.INTEGER, defaultValue: 18, // 默认值 allowNull: true, // 是否为空 unique: true, // 是否唯一 onUpdate: 'NO ACTION', // 当被引用的键更新时的操作 String - 可选值是：['CASCADE', 'RESTRICT', 'SET DEFAULT', 'SET NULL', 'NO ACTION'] onDelete: 'NO ACTION', // 当被引用的键删除时的操作 String - 同上 // 验证器 validate: &#123; isNumeric: true, // 只允许数字 max: 100, min: 1, // 自定义验证 isEven(value) &#123; if (parseInt(value) % 2 != 0) &#123; throw new Error('Only even values are allowed!') // 我们也在模型的上下文中，所以如果它存在的话, // this.otherField会得到otherField的值。 &#125; &#125; &#125;, // getters 为列自定义一个访问器 使用this.getDataValue(String)时调用的值 get() &#123; const age = this.getDataValue('age') // 可以对该列进行操作... return age &#125;, // setters 为列自定义一个设置器 使用this.setDataValue(String, Value)时调用的值 set(value) &#123; const newValue = value + 3 this.setDataValue('age', newValue) &#125; &#125;, uId: &#123; type: Sequelize.INTEGER, references: &#123; model: Bar, // 这是引用另一个模型 key: 'id' // 引用的字段（注意是在数据中存在的字段名）比如引用 foos 表要引用 fooId 而不是 id &#125; &#125;&#125;)Bar.sync().then(() =&gt; &#123; Foo.sync(&#123; force: true &#125;).then(async () =&gt; &#123; try &#123; const foo = await Foo.create(&#123; age: 21 &#125;) // 触发 setters const foos = await Foo.findAll() // 触发 getters &#125; catch (err) &#123; console.log(err) &#125; &#125;)&#125;) 上式代码在数据库中的执行命令为： 1234567891011121314151617181920212223CREATE TABLE IF NOT EXISTS `bars` ( `id` INTEGER NOT NULL auto_increment , `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;DROP TABLE IF EXISTS `foos`;CREATE TABLE IF NOT EXISTS `foos` ( `fooId` INTEGER auto_increment , `age` INTEGER DEFAULT 18 UNIQUE, `uId` INTEGER, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL, PRIMARY KEY (`fooId`), FOREIGN KEY (`uId`) REFERENCES `bars` (`id`)) ENGINE=InnoDB;INSERT INTO `foos` (`fooId`,`age`,`createdAt`,`updatedAt`) VALUES (DEFAULT,24,'2019-01-03 07:34:12','2019-01-03 07:34:12');SELECT `fooId` AS `id`, `age`, `uId`, `createdAt`, `updatedAt` FROM `foos` AS `foo`; Attributes1234567891011121314151617181920const User = sequelize.define('user', &#123; column: &#123; type: xxx, // DataType或字符串，表示列的数据类型 【见下文】 allowNull: true, // 是否设置 NOT NULL（非空）约束 defaultValue: xxx // 默认值 unique: false, // 设置为true时，会为列添加唯一约束 primaryKey: false, // 指定是否是主键 field: xxx, // String - 设置在数据库中的字段名。设置后会，Sequelize会将属性名映射到数据库中的不同名称 autoIncrement: false, // 是否自增 references: &#123; // 引用对象 model: xxx, // 如果列引用到另一个表，可以通过这个属性设置模型或字符串。 key: 'id' // 该列表示到表外键列的引用 &#125;, onUpdate: 'NO ACTION', // 当被引用的键更新时的操作 String - 可选值是：['CASCADE', 'RESTRICT', 'SET DEFAULT', 'SET NULL', 'NO ACTION'] onDelete: 'NO ACTION', // 当被引用的键删除时的操作，可选值同上 get()&#123;&#125;, // 为列自定义一个访问器 使用this.getDataValue(String)时调用的值 【见下文】 set(value)&#123;&#125;, // 为列自定义一个设置器 使用this.setDataValue(String, Value)时调用的值 【见下文】 validate: &#123;&#125; // 模型每次保存时调用的验证对象。可是validator.js中的验证函数(参见 DAOValidator)、或自定义的验证函数 【见下文】 &#125;&#125;) Attributes - DataTypes以下是 Sequelize 支持的一些数据类型。 有关完整和更新的列表, 参阅 DataTypes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Sequelize.STRING // VARCHAR(255)Sequelize.STRING(1234) // VARCHAR(1234)Sequelize.STRING.BINARY // VARCHAR BINARYSequelize.TEXT // TEXTSequelize.TEXT('tiny') // TINYTEXTSequelize.INTEGER // INTEGERSequelize.BIGINT // BIGINTSequelize.BIGINT(11) // BIGINT(11)Sequelize.FLOAT // FLOATSequelize.FLOAT(11) // FLOAT(11)Sequelize.FLOAT(11, 12) // FLOAT(11,12)Sequelize.REAL // REAL 仅限于PostgreSQL.Sequelize.REAL(11) // REAL(11) 仅限于PostgreSQL.Sequelize.REAL(11, 12) // REAL(11,12) 仅限于PostgreSQL.Sequelize.DOUBLE // DOUBLESequelize.DOUBLE(11) // DOUBLE(11)Sequelize.DOUBLE(11, 12) // DOUBLE(11,12)Sequelize.DECIMAL // DECIMALSequelize.DECIMAL(10, 2) // DECIMAL(10,2)Sequelize.DATE // DATETIME 针对 mysql / sqlite, TIMESTAMP WITH TIME ZONE 针对 postgresSequelize.DATE(6) // DATETIME(6) 针对 mysql 5.6.4+. 小数秒支持多达6位精度Sequelize.DATEONLY // DATE 不带时间.Sequelize.BOOLEAN // TINYINT(1)Sequelize.ENUM('value 1', 'value 2') // 一个允许具有 “value 1” 和 “value 2” 的 ENUMSequelize.ARRAY(Sequelize.TEXT) // 定义一个数组。 仅限于 PostgreSQL。Sequelize.ARRAY(Sequelize.ENUM) // 定义一个 ENUM 数组. 仅限于 PostgreSQL。Sequelize.JSON // JSON 列. 仅限于 PostgreSQL, SQLite and MySQL.Sequelize.JSONB // JSONB 列. 仅限于 PostgreSQL .Sequelize.BLOB // BLOB (PostgreSQL 二进制)Sequelize.BLOB('tiny') // TINYBLOB (PostgreSQL 二进制. 其他参数是 medium 和 long)Sequelize.UUID // PostgreSQL 和 SQLite 的 UUID 数据类型, CHAR(36) BINARY 针对于 MySQL (使用默认值: Sequelize.UUIDV1 或 Sequelize.UUIDV4 来让 sequelize 自动生成 ID)Sequelize.CIDR // PostgreSQL 的 CIDR 数据类型Sequelize.INET // PostgreSQL 的 INET 数据类型Sequelize.MACADDR // PostgreSQL 的 MACADDRSequelize.RANGE(Sequelize.INTEGER) // 定义 int4range 范围. 仅限于 PostgreSQL.Sequelize.RANGE(Sequelize.BIGINT) // 定义 int8range 范围. 仅限于 PostgreSQL.Sequelize.RANGE(Sequelize.DATE) // 定义 tstzrange 范围. 仅限于 PostgreSQL.Sequelize.RANGE(Sequelize.DATEONLY) // 定义 daterange 范围. 仅限于 PostgreSQL.Sequelize.RANGE(Sequelize.DECIMAL) // 定义 numrange 范围. 仅限于 PostgreSQL.Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // 定义 tstzrange 范围的数组. 仅限于 PostgreSQL.Sequelize.GEOMETRY // 空间列. 仅限于 PostgreSQL (具有 PostGIS) 或 MySQL.Sequelize.GEOMETRY('POINT') // 具有几何类型的空间列. 仅限于 PostgreSQL (具有 PostGIS) 或 MySQL.Sequelize.GEOMETRY('POINT', 4326) // 具有几何类型和SRID的空间列. 仅限于 PostgreSQL (具有 PostGIS) 或 MySQL. Attributes - getters/setters可以在模型上定义’对象属性’ getter 和 setter 函数，这些可以用于映射到数据库字段的“保护”属性，也可以用于定义“伪”属性。 Getters 和 Setters 可以通过两种方式定义（您可以混合使用这两种方式）： 作为属性定义的一部分 作为模型参数的一部分 注意: 如果在两个地方定义了 getter 或 setter，那么在相关属性定义中找到的函数始终是优先的。 定义为属性定义的一部分12345678910111213141516171819202122232425const Employee = sequelize.define('employee', &#123; name: &#123; type: Sequelize.STRING, allowNull: false, get() &#123; const title = this.getDataValue('title') // 'this' 允许你访问实例的属性 return this.getDataValue('name') + ' (' + title + ')' &#125; &#125;, title: &#123; type: Sequelize.STRING, allowNull: false, set(val) &#123; this.setDataValue('title', val.toUpperCase()) &#125; &#125;&#125;)Employee.sync(&#123; force: true &#125;).then(() =&gt; &#123; Employee.create(&#123; name: 'John Doe', title: 'senior engineer' &#125;).then(employee =&gt; &#123; console.log(employee.get('name')) // John Doe (SENIOR ENGINEER) console.log(employee.get('title')) // SENIOR ENGINEER &#125;)&#125;) 定义为模型参数的一部分以下是在模型参数中定义 getter 和 setter 的示例。fullName getter，是一个说明如何在模型上定义伪属性的例子 - 这些属性实际上不是数据库模式的一部分。 事实上，伪属性可以通过两种方式定义：使用模型 getter，或者使用虚拟数据类型的列。 虚拟数据类型可以有验证，而虚拟属性的 getter 则不能。 请注意，fullName getter 函数中引用的 this.firstname 和 this.lastname 将触发对相应 getter 函数的调用。 如果你不想那样使用getDataValue()方法来访问原始值（见下文）。 1234567891011121314151617181920212223242526272829303132const Foo = sequelize.define( 'foo', &#123; firstname: Sequelize.STRING, lastname: Sequelize.STRING &#125;, &#123; getterMethods: &#123; fullName() &#123; return this.firstname + ' ' + this.lastname &#125; &#125;, setterMethods: &#123; fullName(value) &#123; const names = value.split(' ') this.setDataValue('firstname', names.slice(0, -1).join(' ')) this.setDataValue('lastname', names.slice(-1).join(' ')) &#125; &#125; &#125;)Foo.sync(&#123; force: true &#125;).then(async () =&gt; &#123; try &#123; await Foo.create(&#123; firstname: 'guo', lastname: 'dada' &#125;) const Foos = await Foo.findAll() console.log(Foos[0]['fullName']) // guo dada &#125; catch (err) &#123; console.log(err) &#125;&#125;) Attributes - Validations模型验证，允许您为模型的每个属性指定格式/内容/继承验证。 验证会自动运行在 create ， update 和 save 上。 你也可以调用 validate() 手动验证一个实例。 验证由 validator.js 实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const ValidateMe = sequelize.define('foo', &#123; foo: &#123; type: Sequelize.STRING, validate: &#123; is: [\"^[a-z]+$\",'i'], // 只允许字母 is: /^[a-z]+$/i, // 与上一个示例相同,使用了真正的正则表达式 not: [\"[a-z]\",'i'], // 不允许字母 isEmail: true, // 检查邮件格式 (foo@bar.com) isUrl: true, // 检查连接格式 (http://foo.com) isIP: true, // 检查 IPv4 (129.89.23.1) 或 IPv6 格式 isIPv4: true, // 检查 IPv4 (129.89.23.1) 格式 isIPv6: true, // 检查 IPv6 格式 isAlpha: true, // 只允许字母 isAlphanumeric: true, // 只允许使用字母数字 isNumeric: true, // 只允许数字 isInt: true, // 检查是否为有效整数 isFloat: true, // 检查是否为有效浮点数 isDecimal: true, // 检查是否为任意数字 isLowercase: true, // 检查是否为小写 isUppercase: true, // 检查是否为大写 notNull: true, // 不允许为空 isNull: true, // 只允许为空 notEmpty: true, // 不允许空字符串 equals: 'specific value', // 只允许一个特定值 contains: 'foo', // 检查是否包含特定的子字符串 notIn: [['foo', 'bar']], // 检查是否值不是其中之一 isIn: [['foo', 'bar']], // 检查是否值是其中之一 notContains: 'bar', // 不允许包含特定的子字符串 len: [2,10], // 只允许长度在2到10之间的值 isUUID: 4, // 只允许uuids isDate: true, // 只允许日期字符串 isAfter: \"2011-11-05\", // 只允许在特定日期之后的日期字符串 isBefore: \"2011-11-05\", // 只允许在特定日期之前的日期字符串 max: 23, // 只允许值 &lt;= 23 min: 23, // 只允许值 &gt;= 23 isCreditCard: true, // 检查有效的信用卡号码 // 也可以自定义验证: isEven(value) &#123; if (parseInt(value) % 2 != 0) &#123; throw new Error('Only even values are allowed!') // 我们也在模型的上下文中，所以如果它存在的话, // this.otherField会得到otherField的值。 &#125; &#125; &#125; &#125;&#125;) 请注意，如果需要将多个参数传递给内置的验证函数，则要传递的参数必须位于数组中。 但是，如果要传递单个数组参数，例如isIn的可接受字符串数组，则将被解释为多个字符串参数，而不是一个数组参数。 要解决这个问题，传递一个单一长度的参数数组，比如[[&#39;one&#39;，&#39;two&#39;]]。 要使用自定义错误消息而不是 validator.js 提供的错误消息，请使用对象而不是纯值或参数数组，例如不需要参数的验证器可以被给定自定义消息: 123isInt: &#123; msg: \"Must be an integer number of pennies\"&#125; 或者如果还需要传递参数，请添加一个 args 属性： 1234isIn: &#123; args: [['en', 'zh']], msg: \"Must be English or Chinese\"&#125; 当使用自定义验证器函数时，错误消息将是抛出的 Error 对象所持有的任何消息。 有关内置验证方法的更多详细信息，请参阅the validator.js project 。 验证器 与 allowNull如果模型的特定字段设置为允许null（使用 allowNull：true ），并且该值已设置为 null ，则其验证器不会运行。 这意味着，您可以有一个字符串字段，该字段验证其长度至少为5个字符，但也允许为 null。 你可以通过设置 notNull 验证器来自定义 allowNull 错误消息, 像这样 1234567891011const User = sequelize.define('user', &#123; name: &#123; type: Sequelize.STRING, allowNull: false, validate: &#123; notNull: &#123; msg: 'Please enter your name' &#125; &#125; &#125;&#125;) 模型验证验证器也可以在特定字段验证器之后用来定义检查模型。例如，你可以确保纬度和经度都不设置，或者两者都设置，如果设置了一个而另一个未设置则验证失败。 模型验证器方法与模型对象的上下文一起调用，如果它们抛出错误，则认为失败，否则通过。 这与自定义字段特定的验证器一样。 所收集的任何错误消息都将与验证结果对象一起放在字段验证错误中，这个错误使用在 validate 参数对象中以失败的验证方法的键来命名。即便在任何一个时刻，每个模型验证方法只能有一个错误消息，它会在数组中显示为单个字符串错误，以最大化与字段错误的一致性。 一个例子: 123456789101112131415161718192021222324const Pub = Sequelize.define('pub', &#123; name: &#123; type: Sequelize.STRING &#125;, address: &#123; type: Sequelize.STRING &#125;, latitude: &#123; type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: &#123; min: -90, max: 90 &#125; &#125;, longitude: &#123; type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: &#123; min: -180, max: 180 &#125; &#125;,&#125;, &#123; validate: &#123; bothCoordsOrNone() &#123; if ((this.latitude === null) !== (this.longitude === null)) &#123; throw new Error('Require either both latitude and longitude or neither') &#125; &#125; &#125;&#125;) 在这种简单情况下，如果给定纬度或经度，而不是同时包含两者，则验证失败。 如果我们尝试构建一个超范围的纬度和经度，那么 raging_bullock_arms.validate() 可能会返回 1234&#123; 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Require either both latitude and longitude or neither']&#125; configuration你还可以修改 Sequelize 处理列名称的方式： 1234567891011121314151617181920212223242526272829const Bar = sequelize.define( 'bar', &#123; /* bla */ &#125;, &#123; // 不添加时间戳属性 (updatedAt, createdAt) timestamps: false, // 不删除数据库条目，但将新添加的属性deletedAt设置为当前日期（删除完成时）。 // paranoid 只有在启用时间戳时才能工作 paranoid: true, // 将自动设置所有属性的字段选项为下划线命名方式。 // 不会覆盖已经定义的字段选项 underscored: true, // 禁用修改表名; 默认情况下，sequelize将自动将所有传递的模型名称（define的第一个参数）转换为复数。 如果你不想这样，请设置以下内容 freezeTableName: true, // 定义表的名称 tableName: 'my_very_custom_table_name', // 启用乐观锁定。 启用时，sequelize将向模型添加版本计数属性， // 并在保存过时的实例时引发OptimisticLockingError错误。 // 设置为true或具有要用于启用的属性名称的字符串。 version: true &#125;) 如果你希望 sequelize 处理时间戳，但只想要其中一部分，或者希望您的时间戳被称为别的东西，则可以单独覆盖每个列： 1234567891011121314151617181920const Foo = sequelize.define( 'foo', &#123; /* bla */ &#125;, &#123; // 不要忘记启用时间戳！ timestamps: true, // 我不想要 createdAt createdAt: false, // 我想 updateAt 实际上被称为 updateTimestamp updatedAt: 'updateTimestamp', // 并且希望 deletedAt 被称为 destroyTime（请记住启用paranoid以使其工作） deletedAt: 'destroyTime', paranoid: true &#125;) 您也可以更改数据库引擎，例如 变更到到 MyISAM, 默认值是 InnoDB。 12345678const Person = sequelize.define('person', &#123; /* attributes */ &#125;, &#123; engine: 'MYISAM'&#125;)// 或全局的const sequelize = new Sequelize(db, user, pw, &#123; define: &#123; engine: 'MYISAM' &#125;&#125;) 最后，您可以为 MySQL 和 PG 中的表指定注释 123const Person = sequelize.define('person', &#123; /* attributes */ &#125;, &#123; comment: \"I'm a table comment!\"&#125;) 数据库同步当开始一个新的项目时，你还不会有一个数据库结构，并且使用 Sequelize 你也不需要它。 只需指定您的模型结构，并让库完成其余操作。 目前支持的是创建和删除表： 1234567891011121314151617// 创建表:Project.sync()Task.sync()// 强制创建!Project.sync(&#123;force: true&#125;) // 这将先丢弃表，然后重新创建它// 删除表:Project.drop()Task.drop()// 事件处理:Project.[sync|drop]().then(() =&gt; &#123; // 好吧...一切都很好！&#125;).catch(error =&gt; &#123; // oooh，你输入了错误的数据库凭据？&#125;) 因为同步和删除所有的表可能要写很多行，你也可以让 Sequelize 来为做这些： 123456789101112131415// 同步所有尚未在数据库中的模型sequelize.sync()// 强制同步所有模型sequelize.sync(&#123;force: true&#125;)// 删除所有表sequelize.drop()// 广播处理:sequelize.[sync|drop]().then(() =&gt; &#123; // woot woot&#125;).catch(error =&gt; &#123; // whooops&#125;) 因为 .sync({ force: true }) 是具有破坏性的操作，可以使用 match 参数作为附加的安全检查。 match 参数可以通知 Sequelize，以便在同步之前匹配正则表达式与数据库名称 - 在测试中使用 force：true 但不使用实时代码的情况下的安全检查。 12// 只有当数据库名称以'_test'结尾时，才会运行.sync（）sequelize.sync(&#123; force: true, match: /_test$/ &#125;); sequelize.import您还可以使用 import 方法将模型定义存储在单个文件中。 返回的对象与导入文件的功能中定义的完全相同。 例如 models/author.js: 12345module.exports = (sequelize, DataTypes) =&gt; &#123; return sequelize.define('author', &#123; username: DataTypes.STRING(50) &#125;)&#125; app.js 12345678910const AuthorModel = sequelize.import('./models/author.js')AuthorModel.sync(&#123; force: true &#125;).then(async () =&gt; &#123; try &#123; const author = AuthorModel.findById(1) console.log(author) &#125; catch (err) &#123; console.log(err) &#125;&#125;) 同时导入多个 model再建立多一个 model models/article.js 12345678910111213module.exports = (sequelize, DataTypes) =&gt; &#123; return sequelize.define('article', &#123; title: DataTypes.STRING(50), content: DataTypes.STRING, from: &#123; type: DataTypes.INTEGER, references: &#123; model: 'authors', key: 'id' &#125; &#125; &#125;)&#125; app.js: 12345678910111213141516const fs = require('fs')const path = require('path')const Sequelize = require('sequelize')const MODELS_PATH = path.join(__dirname, 'models')fs.readdirSync(MODELS_PATH).forEach(file =&gt; &#123; sequelize.import(path.join(MODELS_PATH, file))&#125;)sequelize.sync().then(() =&gt; &#123; const &#123; author: AuthorModel, article &#125; = sequelize.models AuthorModel.create(&#123; username: 'guodada' &#125;).then(author =&gt; &#123; console.log(author.username) // guodada &#125;)&#125;) 扩展模型Sequelize 模型是ES6类。 您可以轻松添加自定义实例或类级别的方法。 1234567891011const User = sequelize.define('user', &#123; firstname: Sequelize.STRING &#125;)// 添加一个类级别的方法User.classLevelMethod = function() &#123; return 'foo'&#125;// 添加实例级别方法User.prototype.instanceLevelMethod = function() &#123; return 'bar'&#125; 当然，您还可以访问实例的数据并生成虚拟的 getter: 12345678const User = sequelize.define('user', &#123; firstname: Sequelize.STRING, lastname: Sequelize.STRING &#125;)User.prototype.getFullname = function() &#123; return [this.firstname, this.lastname].join(' ')&#125;// 例子:User.build(&#123; firstname: 'foo', lastname: 'bar' &#125;).getFullname() // 'foo bar' 索引Sequelize 支持在 Model.sync() 或 sequelize.sync 中创建的模型定义中添加索引。 12345678910111213141516171819202122232425262728293031323334353637sequelize.define( 'user', &#123;&#125;, &#123; indexes: [ // 在 email 上创建一个唯一索引 &#123; unique: true, fields: ['email'] &#125;, // 在使用 jsonb_path_ops 的 operator 数据上创建一个 gin 索引 &#123; fields: ['data'], using: 'gin', operator: 'jsonb_path_ops' &#125;, // 默认的索引名将是 [table]_[fields] // 创建多列局部索引 &#123; name: 'public_by_author', fields: ['author', 'status'], where: &#123; status: 'public' &#125; &#125;, // 具有有序字段的BTREE索引 &#123; name: 'title_index', method: 'BTREE', fields: ['author', &#123; attribute: 'title', collate: 'en_US', order: 'DESC', length: 5 &#125;] &#125; ] &#125;) 相关 models-definition models-definition 中文版","categories":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/categories/Sequelize/"}],"tags":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/tags/Sequelize/"}]},{"title":"Sequelize - quick start","slug":"sequelize-quickStart","date":"2019-01-03T03:52:37.000Z","updated":"2019-01-08T12:34:04.395Z","comments":true,"path":"2019/01/03/sequelize-quickStart/","link":"","permalink":"https://gershonv.github.io/2019/01/03/sequelize-quickStart/","excerpt":"在 Node.js 社区中，sequelize 是一个广泛使用的 ORM 框架，它支持 MySQL、PostgreSQL、SQLite 和 MSSQL 等多个数据源。 有数据库基础或者使用过 ORM 操作数据库的经验会更容易上手哦，笔者这里用的以 mysql 为主 安装1npm i sequelize mysql2 --registry=https://registry.npm.taobao.org 记得提前启动 mysql 数据库，创建本例中使用的 demo 数据库 12345mysql.server start // mac (windows net start mysql)mysql -uroot -pCREATE DATABASE IF NOT EXISTS demo;","text":"在 Node.js 社区中，sequelize 是一个广泛使用的 ORM 框架，它支持 MySQL、PostgreSQL、SQLite 和 MSSQL 等多个数据源。 有数据库基础或者使用过 ORM 操作数据库的经验会更容易上手哦，笔者这里用的以 mysql 为主 安装1npm i sequelize mysql2 --registry=https://registry.npm.taobao.org 记得提前启动 mysql 数据库，创建本例中使用的 demo 数据库 12345mysql.server start // mac (windows net start mysql)mysql -uroot -pCREATE DATABASE IF NOT EXISTS demo; 建立连接Sequelize 将在初始化时设置连接池，所以如果从单个进程连接到数据库，你最好每个数据库只创建一个实例。 如果要从多个进程连接到数据库，则必须为每个进程创建一个实例，但每个实例应具有“最大连接池大小除以实例数”的最大连接池大小。因此，如果您希望最大连接池大小为 90，并且有 3 个工作进程，则每个进程的实例应具有 30 的最大连接池大小。 12345678910111213141516const sequelize = new Sequelize('database', 'username', 'password', &#123; host: 'localhost', dialect: 'mysql' | 'mariadb' | 'sqlite' | 'postgres' | 'mssql', pool: &#123; max: 5, min: 0, idle: 10000 &#125;, // 仅 SQLite 适用 storage: 'path/to/database.sqlite'&#125;)// 或者可以简单的使用一个连接 uriconst sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') 测试连接您可以使用 .authenticate() 函数来测试连接。 12345678sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.') &#125;) .catch(err =&gt; &#123; console.error('Unable to connect to the database:', err) &#125;) modelSequelize 使用 define 方法定义模型和表之间的映射。大白话就是 我们可以通过 model 去建立表, 添加字段约束等。 12345678910111213const User = sequelize.define('user', &#123; firstName: Sequelize.STRING lastName: &#123; type: Sequelize.STRING &#125;&#125;)// 通过 sync 可以链接模型到数据库中// force: true 如果表已经存在，将会丢弃表// force 效果： DROP TABLE IF EXISTS `User` =&gt; CREATE TABLE IF NOT EXISTS `USER`...User.sync(&#123; force: true &#125;).then(function() &#123; //...&#125;) 上面的代码执行后我们可以发现 demo 数据库中创建了一个 users 的表 model 操作数据库demo 就简单创建数据和查询数据吧 Sequelize 使用 Bluebird promise 来控制异步控制流程。 链式写法 1234567891011User.sync(&#123; force: true &#125;).then(function() &#123; User.create(&#123; firstName: 'John', lastName: 'Hancock' &#125;).then(user =&gt; &#123; console.log(user.firstName, user.lastName) // John Hancock User.findAll().then(users =&gt; &#123; console.log('you find: ', users[0]['firstName'], users[0]['lastName']) // you find: John Hancock &#125;) &#125;)&#125;) async/await 写法 12345678910User.sync(&#123; force: true &#125;).then(async () =&gt; &#123; try &#123; const user = await User.create(&#123; firstName: 'John', lastName: 'Hancock' &#125;) const users = await User.findAll() console.log(user.firstName, user.lastName) // John Hancock console.log('you find: ', users[0]['firstName'], users[0]['lastName']) // you find: John Hancock &#125; catch (err) &#123; console.log(err) &#125;&#125;) 完整 demo123456789101112131415161718192021222324252627282930313233343536373839404142const Sequelize = require('sequelize')/** * @params ('database', 'username', 'password', options) */const sequelize = new Sequelize('demo', 'root', '123456', &#123; host: 'localhost', // 连接的 host 地址 dialect: 'mysql', // 连接到 mysql port: 3306, // 数据库服务器端口 pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000 &#125;&#125;)const User = sequelize.define('user', &#123; firstName: Sequelize.STRING, lastName: &#123; type: Sequelize.STRING &#125;&#125;)sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully') User.sync(&#123; force: true &#125;).then(async () =&gt; &#123; try &#123; const user = await User.create(&#123; firstName: 'John', lastName: 'Hancock' &#125;) const users = await User.findAll() console.log(user.firstName, user.lastName) // John Hancock console.log('you find: ', users[0]['firstName'], users[0]['lastName']) // you find: John Hancock &#125; catch (err) &#123; console.log(err) &#125; &#125;) &#125;) .catch(err =&gt; &#123; console.error('Unable to connect to the database:', err) &#125;) sequelize - getting started sequelize - 中文版入门","categories":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/categories/Sequelize/"}],"tags":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://gershonv.github.io/tags/Sequelize/"}]},{"title":"mysql - 聚合函数","slug":"mysql-聚合函数","date":"2018-12-31T08:19:35.000Z","updated":"2019-01-04T14:14:13.307Z","comments":true,"path":"2018/12/31/mysql-聚合函数/","link":"","permalink":"https://gershonv.github.io/2018/12/31/mysql-聚合函数/","excerpt":"聚合函数（aggregation function） 聚合函数（aggregation function）—也就是组函数，在一个行的集合（一组行）上进行操作，对每个组给一个结果。 常用的组函数： function return AVG([distinct] expr) 求平均值 COUNT({* [distinct] } expr) 统计行的数量 MAX([distinct] expr) 求最大值 MIN([distinct] expr) 求最小值 SUM([distinct] expr) 求累加和","text":"聚合函数（aggregation function） 聚合函数（aggregation function）—也就是组函数，在一个行的集合（一组行）上进行操作，对每个组给一个结果。 常用的组函数： function return AVG([distinct] expr) 求平均值 COUNT({* [distinct] } expr) 统计行的数量 MAX([distinct] expr) 求最大值 MIN([distinct] expr) 求最小值 SUM([distinct] expr) 求累加和 每个组函数接收一个参数 默认情况下，组函数忽略列值为null的行，不参与计算 有时，会使用关键字distinct剔除字段值重复的条数 注意： 当使用组函数的 select 语句中没有 group by 子句时，中间结果集中的所有行自动形成一组，然后计算组函数； 组函数不允许嵌套，例如：count(max(…))； 组函数的参数可以是列或是函数表达式； 一个 SELECT 子句中可出现多个聚集函数。 123456789mysql&gt; select * from users;+----+----------+------+---------------------+---------------------+| id | name | age | createdAt | updatedAt |+----+----------+------+---------------------+---------------------+| 1 | guodada | 18 | 2019-10-04 05:56:52 | 2019-10-04 05:56:52 || 2 | guodada2 | 18 | 2019-10-04 05:57:01 | 2019-10-04 05:57:01 || 3 | guodada3 | NULL | 2019-10-04 05:58:00 | 2019-10-04 05:58:00 |+----+----------+------+---------------------+---------------------+3 rows in set (0.00 sec) count 函数① count(*)：返回表中满足 where 条件的行的数量 1SELECT COUNT(*) AS count FROM users WHERE age &gt; 10 -- count 3 ② count(列)：返回列值非空的行的数量 1SELECT COUNT(age) AS count FROM users -- count 2 ③ count(distinct 列)：返回列值非空的、并且列值不重复的行的数量 1SELECT COUNT(distinct age) AS count FROM users -- count 1 ④ count(expr)：根据表达式统计数据 1SELECT COUNT(age=18) AS count FROM users; -- count 2 max 和 min 函数—统计列中的最大最小值12SELECT MAX(age) as maxAge FROM users -- maxAge 18SELECT MIN(age) as minAge FROM users -- minAge 18 注意：如果统计的列中只有 NULL 值，那么 MAX 和 MIN 就返回 NULL sum 和 avg 函数—求和与求平均！！表中列值为 null 的行不参与计算 12SELECT AVG(age) as avgAge FROM users -- avgAge 18SELECT SUM(age) as snmAge FROM users -- sumAge 36 注意：要想列值为 NULL 的行也参与组函数的计算，必须使用 IFNULL 函数对 NULL 值做转换。 分组聚合查询分组 SELECT 的基本格式： select [聚合函数] 字段名 from 表名 [where 查询条件] [group by 字段名] [having 过滤条件] 12345678mysql&gt; select name, count(*) as count from users where age &gt; 10 group by name;+----------+-------+| name | count |+----------+-------+| guodada | 1 || guodada2 | 1 |+----------+-------+2 rows in set (0.00 sec) 通过 select 在返回集字段中，这些字段要么就要包含在 group by 语句后面，作为分组的依据，要么就要被包含在聚合函数中。我们可以将 group by 操作想象成如下的一个过程：首先系统根据 select 语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成了一条记录。这个时候剩下的那些不存在与 group by 语句后面作为分组依据的字段就很有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这个时候就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是前面讲到的聚合函数，这也就是为什么这些函数叫聚合函数了。 MySQL最常用分组聚合函数","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/tags/MySQL/"}]},{"title":"mysql - column 的增删改查","slug":"mysql-3","date":"2018-12-30T10:37:33.000Z","updated":"2019-01-03T15:00:29.431Z","comments":true,"path":"2018/12/30/mysql-3/","link":"","permalink":"https://gershonv.github.io/2018/12/30/mysql-3/","excerpt":"创建数据 12345678910-- DROP TABLE users; 创建过 users 表可以使用这个语句删除-- 创建表CREATE TABLE IF NOT EXISTS users( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, password VARCHAR(32) NOT NULL, age TINYINT UNSIGNED NOT NULL DEFAULT 10, sex TINYINT);","text":"创建数据 12345678910-- DROP TABLE users; 创建过 users 表可以使用这个语句删除-- 创建表CREATE TABLE IF NOT EXISTS users( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, password VARCHAR(32) NOT NULL, age TINYINT UNSIGNED NOT NULL DEFAULT 10, sex TINYINT); 插入数据 INSERT INTO 表名 VALUE INSERT INTO 表名 set 列名 = xxx (可以进行子查询) INSERT INTO 表名 SELECT ,,,,,,, (将查询结果插入指定的表中) 12345678-- 插入数据INSERT users VALUES (NULL, 'TOM', '1234', 22, 1); -- 一个列都不能漏-- 插入多条数据INSERT users VALUES (NULL, 'TOM', '1234', 22, 1), (DEFAULT, 'Jhon', '4321', DEFAULT, 1);-- set方法 与第一种方式的区别是，此方法可以使用子查询，但是一次性只能插入一条记录。INSERT users SET username='BEN',password='569'; --其余字段有默认值或者允许为空 更新数据UPDATA 表名 SET 字段名=值|表达式 WHERE 判断条件 (如省略 where 筛选,则更新所有记录) 12345UPDATE users SET age = age + 5;UPDATE users SET age=age-id,sex=0;UPDATE users SET age=age+10 where id % 2 =0; 删除数据1DELETE FROM tbl_name [WHERE where_condition] 查找记录1234567891011查找记录：SELECT select_expr [,select_expr ……][FROM table_referrnces [WHERE where_condition][GROUP BY&#123;col_name | position&#125; [ASC | DESCI],……][HAVING where_condition][ORDER BY &#123;col_name |expr |position&#125; [ASC | DESCI],……]-- demoSELECT id, username FROM users;-- 别名SELECT id AS userId, username AS name FROM users; 查询分组1SELECT sex FROM users GROUP BY sex -- 数据库多条记录会被合并，譬如这里只有 1, null 分组条件 [HAVING where_condotion] having 后的条件必须为聚合函数或者出现在 select 所选择的字段中。 123456SELECT sex FROM users GROUP BY sex -- 对所有记录分组-- 报错 having 后的条件必须为聚合函数或者出现在 select 所选择的字段中。SELECT sex FROM users GROUP by sex having age&gt;35;SELECT sex FROM users GROUP BY sex HAVING count(id) &gt; 2; 排序 12-- 首先按照age升序排列（asc），其次按照id降序排列（desc）SELECT * FROM users ORDER BY age,id DESC; 限制返回的数据的数量 select _ from users limit 2 意思为从取前两条记录。 select _ from users limit 3,2 意思为从第 4 条记录开始取两条，而不是从第三条记录开始。 … 子查询与链接123456789101112131415161718192021use test;CREATE TABLE IF NOT EXISTS tb4( goodsId SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, goodsName VARCHAR(20) NOT NULL, price FLOAT UNSIGNED);INSERT tb4 VALUES (NULL, 'goods1', 12.8), (NULL, 'goods2', 95.8), (NULL, 'goods3', 15.8), (NULL, 'goods2', 50.5);-- 查找平均值select avg(price) from tb4;-- 对平均值四舍五入select round(avg(price), 2) from tb4; -- 保留两位小数-- 使用比较select goodsId, goodsName, price from tb4 where price &gt;= 20;-- 查找大于平均价格的select goodsId, goodsName, price from tb4 where price &gt;= (select round(avg(price), 2) from tb4); 运算符/关键字 ANY SOME ALL &gt;、&gt;= 最小值 最小值 最大值 &lt;、&lt;= 最大值 最大值 最小值 = 任意值 任意值 &lt;&gt;、!= 任意值 使用[NOT]EXISTS 的子查询：如果子查询返回任何行，EXISTS 将返回 TURE；否则返回 FALSE. 1select * from tb4 where price &gt;= all (select round(avg(price), 2) from tb4); -- 任意大于平均价格的记录 数据增删改查-demo（单表）INSERT12345678910111213141516171819CREATE TABLE IF NOT EXISTS goods ( id SMALLINT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) NOT NULL, price FLOAT UNSIGNED, origin VARCHAR(20) DEFAULT 'CHINA');-- 插入单条记录INSERT goods VALUES(NULL, 'oppo', 5399, DEFAULT);-- 插入多条记录INSERT goods VALUES(NULL, 'iphone', 8999, 'US'), (NULL, 'meizu', 6999, DEFAULT);-- SET 插入INSERT goods SET name='xiaomi', price=999;-- SET 插入多条INSERT INTO goods (goodsName, price) VALUES('ss',25),('bb',125); SELECT12345SELECT * FROM goods;SELECT goodsName, price FROM goods;SELECT goodsName, price FROM goods WHERE price &gt; 1000; -- 加条件筛选 UPDATE12-- 找到 iphone , 修改名字为 iphonX, 价格 9999UPDATE goods SET goodsName='iphonX', price=9999 WHERE goodsName='iphone'; DELETE1DELETE FROM goods WHERE goodsName='ss'; -- DELETE FROM goods 删除所有 多表有 left join 、 inner 等等，这里不再讲述。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/tags/MySQL/"}]},{"title":"mysql - 对 table 的操作","slug":"mysql-2","date":"2018-12-30T05:15:47.000Z","updated":"2019-01-03T15:00:58.981Z","comments":true,"path":"2018/12/30/mysql-2/","link":"","permalink":"https://gershonv.github.io/2018/12/30/mysql-2/","excerpt":"创建表12345678910mysql.server start // net start mysqlmysql -uroot -p // loginuse test // 进入数据库CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type, // ...)","text":"创建表12345678910mysql.server start // net start mysqlmysql -uroot -p // loginuse test // 进入数据库CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type, // ...) demo1创建 tb1 表 123456789CREATE TABLE IF NOT EXISTS tb1 ( username VARCHAR(20) NOT NULL, age TINYINT UNSIGNED, salary FLOAT(8, 2) UNSIGNED);SHOIW TABLES; --查看数据库中的表SHOW COLUMNS FROM tb1; --查看数据表中的结构 Field Type Null Key Default Extra username varchar(20) YES null age tinyint(3) unsigned YES null salary float(8,2) unsigned YES null username: 用户的名字往往是字符型，字符数据量小，所以数据类型定为 VARCHAR(20), NOT NULL 不能为空 age: 年龄不能为负值且为整型，数据类型定为 TINYINT salary: FLOAT(8, 2) 整数八位 - 小数有两位，非负值 demo2123456789CREATE TABLE IF NOT EXISTS tb3( id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM ('1','2','3') DEFAULT '3');-- AUTO_INCREMENT: 自增字段，必须为主键 `PRIMARY KEY`，保证记录的唯一性.-- UNIQUE KEY: 唯一-- DEFAULT: 默认 Field Type Null Key Default Extra id smallint(5) NO PRI null auto_increment username varchar(20) NO null sex enum(‘1’,’2’,’3’) YES 3 约束 约束保证数据的完整性和一致性。 约束表现为表级约束和列级约束。 约束类型包括 NOT NULL 非空 PRIMARY KEY 主键 UNIQUE 唯一 DEFAULT 默认 FOREIGN KEY 外键 (foreign key) 外键约束：保持数据一致性，完整性，实现一对多或者多对一的关系 表级约束：针对两个或者两个以上的字段来使用 列级约束：只针对某一个字段来使用 外键约束 父表和子表必须使用相同的存储引擎，而且禁止使用临时表 数据表的存储引擎只能为 InnoDB 外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL 将自动创建索引。 1234567891011121314151617181920-- 身份表CREATE TABLE IF NOT EXISTS provinces ( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, pname VARCHAR(20) NOT NULL);-- 用户表CREATE TABLE IF NOT EXISTS users ( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED, FOREIGN KEY(pid) REFERENCES provinces(id) -- 设置 pid 外键 references provinces 表的 id);-- 外键列和参照列必须具有相似的数据类型: pid BIGINT， 是创建不成功的。保证数据类型相同是第一步-- 数字的长度或是否有符号位必须相同：pid SMALLINT, 同样创建不成功。有符号位位必须相同。pid SMALLINT UNSIGNED 就满足条件了-- 外键列和参照列必须创建索引:, 我们没有创建，MySQL 自动创建了索引。-- 主键在创建的同时，会自动创建索引。SHOW INDEXES FROM provinces\\G; -- Seq_in_index: 1 我们创建了父表 provinces, 子表 users 外键列：pid , 参照列 id 对 table column 的操作列的增加、删除，约束的添加、约束的删除。 12345678910111213141516-- 添加单列alter table tbl_name add [column] col_name col_difinition[first|after col_name]-- 解释：first 插入第一列，after col_name 插入某一列后面。省略不写，加在最后列-- 添加多列alter table tbl_name add [column] (col_name col_difinition,...)-- 删除列alter table tbl_name drop[column] col_name1,col_name2;-- demoALTER TABLE users ADD age TINYINT NOT NULL DEFAULT 10;ALTER TABLE users ADD password VARCHAR(32) NOT NULL AFTER username;ALTER TABLE users DROP password, DROP username; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-- 修改数据表【添加或删除约束】：ALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type](index_col_name,...) -- 这是添加主键约束(只能有一个)ALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX/KEY] [index_name] [index_type] (index_col_name,...); --这是添加唯一约束(可以有多个)ALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition; --这是添加外键约束(可以有多个)ALTER TABLE table_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal(这个literal的意思是加上的default)/DROP DEFAULT&#125; --添加或删除默认约束ALTER TABLE table_name DROP PRIMARY KEY; -- 删除主键约束ALTER TABLE table_name DROP &#123;INDEX/KEY&#125; index_name; --删除唯一约束ALTER TABLE table_name DROP FOREIGN KEY fk_symbol; --删除外键约束-- demoCREATE TABLE IF NOT EXISTS users2 ( username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED);ALTER TABLE users2 ADD id SMALLINT UNSIGNED;-- 添加主键约束ALTER TABLE users2 ADD CONSTRAINT PRIMARY KEY(id);-- 添加唯一约束ALTER TABLE users2 ADD UNIQUE (username);-- 添加外键ALTER TABLE users2 ADD FOREIGN KEY (pid) REFERENCES provinces (id);-- 添加默认约束ALTER TABLE users2 ADD age TINYINT UNSIGNED NOT NULL;ALTER TABLE users2 ALTER age SET DEFAULT 22;-- 删除默认约束ALTER TABLE users2 ALTER age DROP DEFAULT;-- 删除主键约束ALTER TABLE users2 DROP PRIMARY KEY;-- 删除唯一约束ALTER TABLE users2 DROP INDEX username;-- 删除外键约束SHOW CREATE TABLE users2 -- CONSTRAINT `users2_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `provinces` (`id`)ALTER TABLE users2 DROP FOREIGN key users2_ibfk_1;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/tags/MySQL/"}]},{"title":"mysql - 数据库操作和数据属性","slug":"mysql-1","date":"2018-12-29T02:18:35.000Z","updated":"2019-01-03T15:01:08.846Z","comments":true,"path":"2018/12/29/mysql-1/","link":"","permalink":"https://gershonv.github.io/2018/12/29/mysql-1/","excerpt":"数据库操作启动 mysql, mac 可通过 brew 安装 mysql 后启动。 window 需要手动配置 1234567891011121314// macmysql.server start// windownet start mysql// 登录 -u 用户名 root 超级用户 -p 密码mysql -uroot -p// 退出mysql &gt; \\q// 切换到 learn 数据库mysql &gt; use learn","text":"数据库操作启动 mysql, mac 可通过 brew 安装 mysql 后启动。 window 需要手动配置 1234567891011121314// macmysql.server start// windownet start mysql// 登录 -u 用户名 root 超级用户 -p 密码mysql -uroot -p// 退出mysql &gt; \\q// 切换到 learn 数据库mysql &gt; use learn MySQL 语句规范 关键字与函数名称全部大写 数据库名称，表名称，字段名称全部小写 SQL 语句必须以分号结尾 1234567891011121314// 创建数据库 默认编码 utf-8CREATE DATABASE IF NOT EXISTS t1;// 创建 gbk 编码的数据库CREATE DATABASE IF NOT EXISTS t2 CHARACTER SET gbk;//显示创建数据库 t1 的指令SHOW CREATE DATABASE t1;// 查看数据库SHOW DATABASES;// 删除数据库DROP DATABASE IF EXISTS t1; 数据类型整型 MySQL 数据类型 含义 （有符号） tinyint(m) 1 个字节 范围(-128~127) smallint(m) 2 个字节 范围(-32768~32767) mediumint(m) 3 个字节 范围(-8388608~8388607) int(m) 4 个字节 范围(-2147483648~2147483647) bigint(m) 8 个字节 范围(+-9.22*10 的 18 次方) 比如我们存储年龄，范围为 0-100 ，此时我们可以使用 TINYINT 存储 浮点型(float和double) MySQL数据类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数，d小数位 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200. 字符串(char,varchar,_text) MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char和varchar： 1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)， 所以varchar(4),存入3个字符将占用4个字节。 3.char类型的字符串检索速度要比varchar类型的快。varchar和text： 1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字 节。 2.text类型不能有默认值。 3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。 5.二进制数据(_Blob) 1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 2._BLOB存储的数据只能整体读出。 3._TEXT可以指定字符集，_BLO不用指定字符集。 日期时间类型 MySQL数据类型 含义 date 日期 ‘2008-12-2’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2008-12-2 22:06:44’ timestamp 自动存储记录修改时间 数据类型的属性 MySQL关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://gershonv.github.io/tags/MySQL/"}]},{"title":"随笔 - 如何用es6+写出优雅的js代码","slug":"随笔-如何用es6+写出优雅的js代码","date":"2018-12-12T01:59:21.000Z","updated":"2019-01-03T15:05:02.621Z","comments":true,"path":"2018/12/12/随笔-如何用es6+写出优雅的js代码/","link":"","permalink":"https://gershonv.github.io/2018/12/12/随笔-如何用es6+写出优雅的js代码/","excerpt":"兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令","text":"兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 好处就是：解决了访问多层嵌套的对象或数组的命名，减少代码量 声明多个变量: 12let [age, name, sex] = [22, 'guodada', 1]console.log(age, name, sex) // 22, guodada, 1 使用在对象中： 123456789101112const obj = &#123; name: &#123; firstName: 'guo', lastName: 'dada' &#125;&#125;// 如果我们多处使用 firstName， 那就不必要每个地方都写 obj.name.firstName, 这样极大提升coding效率const &#123; firstName, lastName &#125; = obj.name// 等同于const firstName = obj.name.firstNameconst lastName = obj.name.lastName 使用在函数中: 1234567// 在参数中结构赋值，获取参数, 当参数多的使用时候十分方便function Destructuring(&#123; name, age &#125;) &#123; return &#123; name, age &#125; // 相当于 &#123; name: name, age: age &#125; , 可以简写&#125;const params = &#123; name: 'guodada', age: 22 &#125;Destructuring(params) 更多用法见 变量的解构赋值 ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 12345678910function f(x, y) &#123; return &#123; x, y &#125;&#125;// 等同于function f(x, y) &#123; return &#123; x: x, y: y &#125;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 扩展符的运用es6 扩展符有很多用法，他可以使你的代码更加简洁，易懂。这里就举例常用的用法 在对象中的用法： 123456789101112131415let obj = &#123; name: 'guodada', age: 22, sex: 1&#125;// 复制对象。扩展符为浅复制！！！const copy = &#123; ...obj &#125;// 修改对象属性值(生成新对象) 相当于 Object.assgin(&#123;&#125;, obj, &#123; age: 18 &#125;)const newObj = &#123; ...obj, age: 18 &#125;// 结合结构赋值let &#123; sex, ...z &#125; = objz // &#123; name: 'guodada', age: 22 &#125; 在数组中的用法： 1234567891011121314const arr = [1, 2, 3]const arr2 = [4, 5, 6, 4]// 复制数组。扩展符为浅复制！！！const newArr = [...arr] // ...[1, 2, 3] =&gt; 相当于展开数组：1, 2, 3// 合并数组const conbineArr = [...arr, ...arr2]// 结合求最大值函数Math.max(...arr)// 结合 Set 实现数组去重。注意：json 等对象数组不可用[...new Set(arr2)] // [4, 5, 6] 扩展符的其他用法请自行查资料。 数组用法1234567891011121314const arr = [1, 2, 3, 4]Array.isArray(arr) // 判断是否为数组arr.includes(2) // true 判断数组中是否包含某项arr.findIndex(d =&gt; d === 3) // 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1arr.find(d =&gt; d === 3) // 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined// es5 其他还有 filter map forEach 等，这里不做举例。arr.every(d =&gt; d &gt; 2) // false 每一项都满足条件则返回 truearr.some(d =&gt; d &gt; 2) // true 只要有一项满足条件则返回 true find/findIndex : 找出第一个符合条件的数组成员之后不再匹配，一定程度下优化查找。includes: 返回 true/false, 相较于 indexOf, 实用多了 flat() : 扁平化数组，常用于将数组转化为一维数组 12345678const arr = [1, 2, [3, 4]]arr.flat() // [1, 2, 3, 4] 扁平化数组, 默认展开一层。const arr2 = [1, 2, [3, 4, [5, 6]]]arr2.flat() // [1, 2, 3, 4, [5, 6]]arr2.flat(2) // [1, 2, 3, 4, 5, 6] flat(3) 也是展开两层... flatMap(): 在数组执行 map 方法后执行 flat, 用的不多，其实可以写 map 后写 flat 更好懂点。 123;[2, 3, 4].flatMap(x =&gt; [x, x * 2]) // [ 2, 4, 3, 6, 4, 8 ]// 1. [2, 3, 4].map(d =&gt; [d, d * 2]) =&gt; [[2, 4], [3, 6], [4, 8]]// 2. [[2, 4], [3, 6], [4, 8]].flat() 补充常用的对象转数组的用法： 12345const obj = &#123; name: 'guodada' &#125;Object.keys(obj) // ['name']Object.values(obj) // ['guodada']Object.entries(obj) // [['name', 'guodada']] 模板字符串用的挺多的，注意不兼容 IE ! 123456const name = 'guodada'const newStr = `welcome $&#123;name&#125;` // welcome guodada// the same asconst newStr = 'welcome ' + name 使用 async / awaitasync/await 实际上就是 generator 的语法糖, 主要用来解决异步问题，具体网上很多文章都有介绍，这里就不做多的解释吧。 123456789101112131415161718async function test() &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data)&#125;// 等同于function test() &#123; axios.get('https://randomuser.me/api/').then(res =&gt; console.log(res)) // axios 也是 promise 对象&#125;// 结合try/catchasync function test() &#123; try &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data) &#125; catch (err) &#123; console.log(err) &#125;&#125; ps 虽然好用，但是有时候适用场景不好，比如我们在拉取列表和用户信息需要同时进行时，await 后才执行下一条语句，这不是我们希望看到的。解决方法如下： 12// 结合 Promise.allawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) 传送门：async 函数 利用 class 封装代码主要是抽离代码逻辑，使得代复用性加强。同时，class 的形式会让结构变得更加清晰，譬如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyForm &#123; /** * @func defaultLimit - 默认表单输入限制条件, value 为空时返回 true * @param &#123;Number&#125; type - 代表表单类型的节点！ * @param &#123;String&#125; value - 需要被验证的值 * @return Boolean * * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 * 4 0≤x≤10 */ static defaultLimit(type, value) &#123; const typeLimitMap = &#123; 1: /^(\\d|[1-4]\\d|50)$/g, 2: /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/, 3: /^[1-9]\\d*$/, 4: value =&gt; value &lt;= 10 &amp;&amp; value &gt;= 0 // 0≤ x ≤ 10 可以为小数 &#125; if (!typeLimitMap[type] || !value) return true if (typeof typeLimitMap[type] === 'function') return typeLimitMap[type](value) else return typeLimitMap[type].test(value) &#125; /** * @func translateLimit - 转换操作符 * @param &#123;String&#125; operator - 运算符 * @param &#123;*&#125; value - 被匹配的值 * @param &#123;*&#125; compareValue - 匹配的值 * @return Boolean * 'eq': '=' * 'ne': '≠' * 'gt': '&gt;' * 'lt': '&lt;' * 'ge': '≥' * 'le': '≤' */ static translateLimit(operator, value, compareValue) &#123; const type = &#123; eq: value === compareValue, ne: value !== compareValue, gt: value &gt; compareValue, lt: value &lt; compareValue, ge: value &gt;= compareValue, le: value &lt;= compareValue &#125; if (!Object.keys(type).includes(operator) || !value || value === '-') return true return type[operator] &#125; // ...&#125;export default MyForm 使用： 123import MyForm from './MyForm'MyForm.defaultLimit(1, 20) static ：静态属性，类可以直接调用 constructor : 实例化类的时候调用，即 new MyForm(), 这里没用到 更多知识请阅 Class 的基本语法 优化 if/else 语句 当逻辑或||时，找到为 true 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。 当逻辑与&amp;&amp;时，找到为 false 的分项就停止处理，并返回该分项的值。 12345const a = 0 || null || 3 || 4console.log(a) // 3const b = 3 &amp;&amp; 4 &amp;&amp; null &amp;&amp; 0console.log(b) // null 减少 if / else地狱般的调用 1234567891011121314151617const [age, name, sex] = [22, 'guodada', 1]if (age &gt; 10) &#123; if (name === 'guodada') &#123; if (sex &gt; 0) &#123; console.log('all right') &#125; &#125;&#125;// 使用 &amp;&amp;if (age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0) &#123; console.log('all right')&#125;// 或者(太长了不推荐)age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0 &amp;&amp; console.log('all right') 提一下 react 的坑点, 在 render 中 12345678910render()&#123; const arr = [] return arr.length &amp;&amp; null&#125;// 渲染出 0 ！// Boolean / undefind / null / NaN 等才不会渲染。我们可以使用 !! 强制转化为 boolean 解决这个问题return !!arr.length &amp;&amp; null// 使用 &amp;&amp; 控制组件的渲染this.state.visible &amp;&amp; &lt;Modal /&gt; 使用 Array.includes 来处理多重条件： 12345678910const ages = [18, 20, 12]if (age === 18 || age === 12) &#123; console.log('match')&#125;// betterif ([18, 12].includes(age)) &#123; console.log('match')&#125; 如果是较少的判断逻辑则可以使用三元运算符： 1234const age = 22const isAdult = age &gt;= 18 ? true : false // 这里可以简写为 const isAdult = age &gt; 18const type = age &gt;= 18 ? 'adult' : 'child' 优化 switch/case 语句switch/case 比 if/else 代码结构好点，但也和它一样有时十分冗长。 这里以自己实际项目中代码举例：有时我们可能需要对不同类型的字段进行不一样的正则验证，防止用户错误地输入。譬如 12345678910111213141516171819202122232425262728293031323334353637const [type, value] = [1, '20']/** * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 */function func1(type, value) &#123; if (type === 1) &#123; return /^(\\d|[1-4]\\d|50)$/.test(value) &#125; else if (type === 2) &#123; return /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/.test(value) &#125; else if (type === 3) &#123; return /^[1-9]\\d*$/.test(value) &#125; else &#123; return true &#125;&#125;func1(type, value)// 使用 switch/casefunction fun2(type, value) &#123; switch (type) &#123; case 1: return /^(\\d|[1-4]\\d|50)$/.test(value) case 2: return /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/.test(value) case 3: return /^[1-9]\\d*$/.test(value) default: return true &#125;&#125;func2(type, value) 我们如何巧妙的解决这个代码冗长的问题呢，如下： 12345678function func3(type, value) &#123; const limitMap = &#123; 1: /^(\\d|[1-4]\\d|50)$/g, 2: /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/, 3: /^[1-9]\\d*$/ &#125; return limitMap[type].test(value)&#125; 利用对象去匹配属性值，可以减少你的代码量，也使你的代码看起来更加简洁。你也可以使用 Map 对象去匹配。 12345function func4(type, value) &#123; const mapArr = [[1, /^(\\d|[1-4]\\d|50)$/g], [2, /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/], [3, /^[1-9]\\d*$/]] const limitMap = new Map(mapArr) return limitMap.get(type).test(value)&#125; Map 是一种键值对的数据结构对象，它的匹配更加严格。它会区分开你传递的是字符串还是数字，譬如： 12limitMap.get(1) // /^(\\d|[1-4]\\d|50)$/glimitMap.get('1') // undefined 更多详见 Set 和 Map 数据结构 其他 函数参数默认值 12345function func(name, age = 22) &#123;&#125;// 等同于function func(name, age) &#123; age = age || 22&#125; 使用 === 代替 ==。其实大家都懂这个的。。。 箭头函数，es6 最常用的语法。 return boolean1234const a = 1return a === 1 ? true : false// 多此一举了，其实就等于return a === 1 敬请各位补充。交流才能进步，相视一笑，嘿嘿。 github - star 一下人生更美好 blog - 欢迎交流","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://gershonv.github.io/categories/开发随笔/"}],"tags":[]},{"title":"react - hooks(v16.7)","slug":"react-hooks","date":"2018-12-03T07:30:32.000Z","updated":"2019-01-03T15:05:20.503Z","comments":true,"path":"2018/12/03/react-hooks/","link":"","permalink":"https://gershonv.github.io/2018/12/03/react-hooks/","excerpt":"前言本文不做概念性的解析，旨在实操 hooks，相关资源可以自行谷歌。以下提供相关参考资料： Introducing Hooks 理解 React Hooks React Hooks 实用指南 - 大都借鉴这篇文章 Hooks 一览","text":"前言本文不做概念性的解析，旨在实操 hooks，相关资源可以自行谷歌。以下提供相关参考资料： Introducing Hooks 理解 React Hooks React Hooks 实用指南 - 大都借鉴这篇文章 Hooks 一览 useState useState 可以让您的函数组件也具备类组件的 state 功能。 12345/** * @state - state的值 * @setState - 更新state的函数, 接受一个参数值来更新 state */const [state, setState] = useState(initialState) 案例12345678910111213import React, &#123; useState &#125; from 'react'function Base() &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; )&#125;export default Base 值得注意的是，state 是对象的话， setState 接收什么参数，就更新对象下的所有属性，而不是更新单个属性。 12345678910111213141516import React, &#123; useState &#125; from 'react'function Demo2() &#123; const [info, setInfo] = useState(&#123; name: 'guodada', age: 22 &#125;) return ( &lt;div&gt; &lt;p&gt;name: &#123;info.name&#125;&lt;/p&gt; &lt;p&gt;age: &#123;info.age&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setInfo(&#123; name: 'Sam' &#125;)&#125;&gt;setInfo&lt;/button&gt; &lt;/div&gt; )&#125; click button =&gt; info = { name: &#39;Sam&#39; }，age 丢失。 根据业务需求，我们可以在函数组件中使用多个 useState，这里不再进行演示。 useEffectEffect Hook: 它与 React Class 中的 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途。模拟的是生命周期 12345/** * @didUpdate - function * @[] - 参数2为数组，不加参数或者不写的话任何state 的变化都会执行 didUpdate 函数 */useEffect(didUpdate, []) 案例12345678910111213141516171819202122class Example extends React.Component &#123; state = &#123; count: 0 &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 等同于 12345678910111213141516import &#123; useState, useEffect &#125; from 'react'function Example() &#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times` &#125;) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; )&#125; 添加第二个参数进行控制12345678910111213141516171819import React, &#123; useState, useEffect &#125; from 'react'function Example() &#123; const [count, setCount] = useState(0) const [count2, setCount2] = useState(0) useEffect(() =&gt; &#123; console.log('run useEffect') &#125;, [count]) // 只有count 变化时才执行这个 useEffect 函数 return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;p&gt;You clicked &#123;count2&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; )&#125; useContext useReducer 是 useState 的代提方案。当你有一些更负责的数据时可以使用它。（组件本地的redux） 使用语法如下： 1234567/** * @state =&gt; your state * @dispatch * @param &#123;state&#125; * @param &#123;action&#125; **/const [state, dispatch] = useReducer(reducer, initialState) 案例12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component, useReducer &#125; from 'react'function TestUseReducer() &#123; const [state, dispatch] = useReducer( (state, action) =&gt; &#123; switch (action.type) &#123; case 'update': return &#123; name: action.payload &#125; default: return state &#125; &#125;, &#123; name: '' &#125; ) const handleNameChange = e =&gt; &#123; dispatch(&#123; type: 'update', payload: e.target.value &#125;) &#125; return ( &lt;div&gt; &lt;p&gt;你好：&#123;state.name&#125;&lt;/p&gt; &lt;input onChange=&#123;handleNameChange&#125; /&gt; &lt;/div&gt; )&#125;class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;TestUseReducer /&gt; &lt;/div&gt; ) &#125;&#125;export default App useCallback useCallback 和 useMemo 有些相似。它接收一个内联函数和一个数组，它返回的是一个记忆化版本的函数。 使用语法如下： 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a), [a]) 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component, useCallback &#125; from 'react'function TestUseCallback(&#123; num &#125;) &#123; const memoizedCallback = useCallback( () =&gt; &#123; console.log('这里监听 num 值的更新重新做一些操作和计算') num.forEach(item =&gt; item++ ) return num &#125;, [num] ) console.log('记忆 num &gt; ', memoizedCallback()) console.log('原始 num &gt; ', num) return null&#125;const num1 = [1, 2, 3]const num2 = [4, 5, 6]class App extends Component &#123; state = &#123; num: num1, count: 0 &#125; componentDidMount() &#123; setInterval(() =&gt; &#123; this.setState(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125;, 3000) &#125; handleChangeNum = () =&gt; &#123; this.setState(&#123; num: num2 &#125;) &#125; render() &#123; const &#123; num &#125; = this.state return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;button onClick=&#123;this.handleChangeNum&#125;&gt;修改传入的Num值&lt;/button&gt; &lt;TestUseCallback num=&#123;num&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App useRef123456789101112131415161718192021import React, &#123; useRef &#125; from 'react'function TestUseRef() &#123; const inputEl = useRef(null) const onButtonClick = () =&gt; &#123; inputEl.current.focus() // 设置useRef返回对象的值 &#125; return ( &lt;div&gt; &lt;p&gt;TestUseRef&lt;/p&gt; &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;input聚焦&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default TestUseRef","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react - lazy(v16.6)","slug":"react-lazy","date":"2018-11-26T09:31:09.000Z","updated":"2019-01-03T15:05:50.648Z","comments":true,"path":"2018/11/26/react-lazy/","link":"","permalink":"https://gershonv.github.io/2018/11/26/react-lazy/","excerpt":"动态 import在 Code-Splitting 部分，提出拆分组件的最佳方式（best way） 是使用动态的 import 方式。 比如下面两种使用方式的对比： 123456789// 之前import &#123; add &#125; from './math'console.log(add(16, 26))// 之后import('./math').then(math =&gt; &#123; console.log(math.add(16, 26))&#125;) 可以发现动态 import 提供了 Promise 规范的 API，比如 .then()","text":"动态 import在 Code-Splitting 部分，提出拆分组件的最佳方式（best way） 是使用动态的 import 方式。 比如下面两种使用方式的对比： 123456789// 之前import &#123; add &#125; from './math'console.log(add(16, 26))// 之后import('./math').then(math =&gt; &#123; console.log(math.add(16, 26))&#125;) 可以发现动态 import 提供了 Promise 规范的 API，比如 .then() demo动态 import 主要应用场景是延迟加载方法，对于组件来说，并不是很适用，但是 React.lazy 对于组件的加载则是有比较大的帮助。 React.lazy 和 suspense 并不适用于服务端渲染 12345678910111213141516import React, &#123; Component, lazy, Suspense &#125; from 'react'const MyComponent = lazy(() =&gt; import('./MyComponent'))class App extends Component &#123; render() &#123; // lazy 需要配合 Suspense 使用 // Suspense 使用的时候，fallback 一定是存在且有内容的， 否则会报错。 return ( &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;MyComponent /&gt; &lt;/Suspense&gt; ) &#125;&#125;export default App 实现 lazy-load12345678910111213141516171819202122232425import React from 'react'import NProgress from 'nprogress'export default loadComponent =&gt; class AsyncComponent extends React.Component &#123; state = &#123; Component: null &#125; async componentDidMount() &#123; if (this.state.Component !== null) return NProgress.start() try &#123; const &#123; default: Component &#125; = await loadComponent() this.setState(&#123; Component &#125;) &#125; catch (err) &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`) throw err &#125; NProgress.done() &#125; render() &#123; const &#123; Component &#125; = this.state return Component ? &lt;Component &#123;...this.props&#125; /&gt; : null &#125; &#125; react-loadable （router4 推荐）react-router - [译] Code Splitting 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom'import Loadable from 'react-loadable'const NoFound = Loadable(&#123; loader: () =&gt; import('./components/NoFound'), loading: &lt;div&gt;loading&lt;/div&gt;&#125;)class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route component=&#123;NoFound&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ) &#125;&#125;export default App","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react - Portals","slug":"react-Portals","date":"2018-11-26T09:00:32.000Z","updated":"2019-01-03T15:06:20.228Z","comments":true,"path":"2018/11/26/react-Portals/","link":"","permalink":"https://gershonv.github.io/2018/11/26/react-Portals/","excerpt":"Portals 指定挂载组件到某个节点，适用于 modal、toolTip… 我们不希望 modal 组件的节点出现在 root 根节点中。。。。 1ReactDOM.createPortal(child, container) child : The first argument (child) is any renderable React child，such as an element, string, or fragment即可渲染的 react 组件 container : a DOM element","text":"Portals 指定挂载组件到某个节点，适用于 modal、toolTip… 我们不希望 modal 组件的节点出现在 root 根节点中。。。。 1ReactDOM.createPortal(child, container) child : The first argument (child) is any renderable React child，such as an element, string, or fragment即可渲染的 react 组件 container : a DOM element 用法通常，如果你的组件的 render 方法返回一个元素时，它作为最接近的父节点的子节点挂载到 DOM 中： 12345678render() &#123; // React mounts a new div and renders the children into it return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; )&#125; 但是，有时候要把子节点插入 DOM 中的不同位置时，是有用的： 12345678render() &#123; // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode, )&#125; 使用 portals 的典型场景是如果一个父组件有一个 overflow:hidden 或者是 z-index 的样式，但是你需要子节点在视觉上 break out （打破）这个父容器，比如 对话框，选项卡或者提示工具等 下面代码实现一个 model 组件 App.jsx1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react'import Modal from './Modal'class App extends Component &#123; state = &#123; show: false &#125; showModal = () =&gt; &#123; this.setState(&#123; show: !this.state.show &#125;) &#125; closeModal = () =&gt; &#123; this.setState(&#123; show: false &#125;) &#125; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; show: true &#125;)&#125;&gt;open Modal&lt;/button&gt; &lt;Modal show=&#123;this.state.show&#125; onClose=&#123;this.closeModal&#125;&gt; This message is from Modal &lt;/Modal&gt; &lt;/div&gt; ) &#125;&#125;export default App Modal.jsx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React, &#123; Component &#125; from 'react'import ReactDOM from 'react-dom'const backdropStyle = &#123; position: 'fixed', top: 0, bottom: 0, left: 0, right: 0, backgroundColor: 'rgba(0, 0, 0, 0.3)', padding: 50&#125;const modalStyle = &#123; backgroundColor: '#fff', borderRadius: 5, border: '1px solid #eee', maxWidth: 500, minHeight: 300, maring: '0 auto', padding: 30, position: 'relative'&#125;const footerStyle = &#123; position: 'absolute', bottom: 20&#125;// 在此前，页面需要创建一个 dom 元素 其中 id 为modal-rootconst modalRoot = document.getElementById('modal-root')class Modal extends Component &#123; constructor(props) &#123; super(props) this.el = document.createElement('div') &#125; onKeyUp = e =&gt; &#123; // 鼠标信息 http://keycode.info/ // 按下 esc if (e.which === 27 &amp;&amp; this.props.show) &#123; this.props.onClose() &#125; &#125; componentDidMount() &#123; document.addEventListener('keyup', this.onKeyUp) modalRoot.appendChild(this.el) &#125; componentWillUnmount() &#123; document.removeEventListener('keyup', this.onKeyUp) modalRoot.removeChild(this.el) &#125; render() &#123; if (!this.props.show) return null const modalUI = ( &lt;div style=&#123;backdropStyle&#125;&gt; &lt;div style=&#123;modalStyle&#125;&gt; &#123;this.props.children&#125; &lt;div style=&#123;footerStyle&#125;&gt; &lt;button onClick=&#123;this.props.onClose&#125;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) // createPortal 挂载到 this.el 的元素中 return ReactDOM.createPortal(modalUI, this.el) &#125;&#125;export default Modal","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react - PureComponent 和 memo","slug":"react-purecomponent && memo","date":"2018-11-26T07:58:36.000Z","updated":"2019-01-03T15:06:40.897Z","comments":true,"path":"2018/11/26/react-purecomponent && memo/","link":"","permalink":"https://gershonv.github.io/2018/11/26/react-purecomponent && memo/","excerpt":"setState 数据无改变， 组件会重新 render1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'class MyComponent extends Component &#123; render() &#123; console.log('render') return null &#125;&#125;class App extends Component &#123; state = &#123; num: 1 &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: 1 &#125;) // setState 但是不改变 num &#125; render() &#123; return ( &lt;div&gt; &lt;MyComponent num=&#123;this.state.num&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App 点击按钮，setState 后 num 并未发生改变， 但是组件 MyComponent 仍然会重新渲染，这就会导致一部分性能的消耗。 我们可以使用 shouldComponentUpdate(nextProps, nextState) 来决定组件的渲染与否，也可以使用 react 提供的两个 API","text":"setState 数据无改变， 组件会重新 render1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'class MyComponent extends Component &#123; render() &#123; console.log('render') return null &#125;&#125;class App extends Component &#123; state = &#123; num: 1 &#125; handleClick = () =&gt; &#123; this.setState(&#123; num: 1 &#125;) // setState 但是不改变 num &#125; render() &#123; return ( &lt;div&gt; &lt;MyComponent num=&#123;this.state.num&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App 点击按钮，setState 后 num 并未发生改变， 但是组件 MyComponent 仍然会重新渲染，这就会导致一部分性能的消耗。 我们可以使用 shouldComponentUpdate(nextProps, nextState) 来决定组件的渲染与否，也可以使用 react 提供的两个 API React.PureComponentpure 是纯的意思， PureComponent 也就是纯组件, 只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能。 PureComponent 主要作用于类组件，而 memo 主要作用于函数组件。 React.PureComponent 使用 prop 和 state 的浅比较来决定是否 render 组件。（我们就不需要在 shouldComponentUpdate 中写一大段代码了！） 使用方法极其简单（以上面的代码为例）： 12345678910import React, &#123; Component, PureComponent &#125; from 'react'class MyComponent extends PureComponent &#123; render() &#123; console.log('render') return null &#125;&#125;// ... App 注意在不可变数据类型（数组、对象等等）PureComponent 是不生效的！因为它的引用地址并未发生改变。做一个 demo: 12345678910111213141516171819202122232425262728import React, &#123; Component, PureComponent &#125; from 'react'class MyComponent extends PureComponent &#123; render() &#123; console.log('render') return this.props.nums &#125;&#125;class App extends Component &#123; state = &#123; nums: [1, 2, 3] &#125; handleClick = () =&gt; &#123; const &#123; nums &#125; = this.state nums.pop() this.setState(&#123; nums &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;MyComponent nums=&#123;this.state.nums&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App 这里无论如何点击按钮，MyComponent 也不会重新渲染。具体比较过程是这样的： 1234567891011class MyComponent extends Component &#123; shouldComponentUpdate(nextProps, nextState) &#123; // nums 引用是一样的，所以 this.props.nums 等于 nextProps.nums，结果永远返回 false，组件不会重新渲染！ return this.props.nums !== nextProps.nums &#125; render() &#123; console.log('render') return this.props.nums &#125;&#125; React.memoReact.memo 是一个高阶组件。它与 React.PureComponent 类似，但是对于函数组件而不是类。 12345678import React, &#123; Component, memo &#125; from 'react'const MyComponent = memo(props =&gt; &#123; console.log('redner') return null&#125;)// ... App 如果你的函数组件在给定相同的道具的情况下呈现相同的结果，则可以 React.memo 通过记忆结果将其包装在一些调用中以提高性能。这意味着 React 将跳过渲染组件，并重用最后渲染的结果。 默认情况下，它只会浅显比较 props 对象中的复杂对象。如果要控制比较，还可以提供自定义比较功能作为第二个参数。 1234567891011function MyComponent(props) &#123; /* render using props */&#125;function areEqual(prevProps, nextProps) &#123; /* return true if passing nextProps to render would return the same result as passing prevProps to render, otherwise return false */&#125;export default React.memo(MyComponent, areEqual) 此方法仅作为性能优化存在。不要依赖它来“防止”渲染，因为这可能导致错误。","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react - Ref","slug":"react-ref","date":"2018-11-26T05:36:56.000Z","updated":"2019-01-03T15:07:07.248Z","comments":true,"path":"2018/11/26/react-ref/","link":"","permalink":"https://gershonv.github.io/2018/11/26/react-ref/","excerpt":"什么时候使用 Refs下面是几个使用 Refs 的示例： 管理焦点状态(focus)、文本选择(text selection)、或者是媒体播放(media) 强制触发动画 与第三方的 DOM 库集成 在任何能够通过直接声明完成的事情中应当避免使用 Refs。例如，对于一个 Dialog 组件，应当提供一个 isOpen 的 prop 来控制它，而不是暴露open()和 close()两个方法去操作。 使用方法： Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。","text":"什么时候使用 Refs下面是几个使用 Refs 的示例： 管理焦点状态(focus)、文本选择(text selection)、或者是媒体播放(media) 强制触发动画 与第三方的 DOM 库集成 在任何能够通过直接声明完成的事情中应当避免使用 Refs。例如，对于一个 Dialog 组件，应当提供一个 isOpen 的 prop 来控制它，而不是暴露open()和 close()两个方法去操作。 使用方法： Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。 在 DOM 元素中使用 当在 refHTML 元素上使用该属性时，ref 在构造函数中创建的属性将 React.createRef()接收底层 DOM 元素作为其 current 属性。 123456789101112131415161718import React, &#123; Component &#125; from 'react'class App extends Component &#123; constructor(props) &#123; super(props) this.inputRef = React.createRef() &#125; componentDidMount() &#123; this.inputRef.current.focus() &#125; render() &#123; return &lt;input type=\"text\" ref=&#123;this.inputRef&#125; /&gt; &#125;&#125;export default App 在类组件中使用 在 ref 自定义类组件上使用该属性时，该 ref 对象将接收组件的已安装实例作为其 current。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'class MyComponent extends Component &#123; state = &#123; name: 'guodada' &#125; render() &#123; return null &#125;&#125;class App extends Component &#123; constructor(props) &#123; super(props) this.myRef = React.createRef() &#125; componentDidMount() &#123; const MyComponent = this.myRef.current // MyComponent 实例 : MyComponent.state = &#123; name: 'guodada' &#125; &#125; render() &#123; return &lt;MyComponent ref=&#123;this.myRef&#125; /&gt; &#125;&#125;export default App 在函数组件中使用 您可能无法 ref 在函数组件上使用该属性，因为它们没有实例。 123456789101112131415161718import React from 'react'function MyFunctionComponent() &#123; return &lt;input /&gt;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props) this.textInput = React.createRef() &#125; render() &#123; // This will *not* work! return &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt; &#125;&#125;export default Parent 但是，只要引用 DOM 元素或类组件，就可以在函数组件中使用该 ref 属性： 123456789101112131415161718import React, &#123; Component &#125; from 'react'function MyFunctionComponent() &#123; let textInput = React.createRef() function handleClick() &#123; textInput.current.focus() &#125; return ( &lt;div&gt; &lt;input ref=&#123;textInput&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default MyFunctionComponent Callback Refs （推荐使用） React 还支持另一种设置名为 callback refs 的引用的方法，它可以在设置和取消设置引用时提供更细粒度的控制。 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react'class MyComponent extends Component &#123; state = &#123; name: 'guodada' &#125; render() &#123; return null &#125;&#125;class App extends Component &#123; componentDidMount() &#123; this.inputRef.focus() // 注意 这里没使用 current console.log(this.myRef.state) // 同理这里也不使用 current &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;el =&gt; this.inputRef = el&#125; /&gt; &lt;MyComponent ref=&#123;el =&gt; this.myRef = el&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App Ref forwarding（转发 ref） Ref forwarding 是一种自动将 ref 通过组件传递给其子节点的技术。对于应用程序中的大多数组件，这通常不是必需的。但是，它对某些类型的组件很有用，特别是在可重用的组件库中。 123456789101112131415161718192021222324import React from 'react'const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;))class App extends React.Component &#123; constructor(props) &#123; super(props) this.buttonRef = React.createRef() &#125; componentDidMount() &#123; const FancyButton = this.buttonRef.current // 访问到 button 的 dom &#125; render() &#123; return &lt;FancyButton ref=&#123;this.buttonRef&#125;&gt;click&lt;/FancyButton&gt; &#125;&#125;export default App 第二个 ref 参数仅在使用 React.forwardRef 调用定义组件时才存在。常规函数或类组件不接收 ref 参数，并且在 props 中也不提供 ref。Ref 转发不仅限于 DOM 组件。您也可以将 refs 转发给类组件实例。","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react - PropTypes","slug":"react-proptypes","date":"2018-11-26T02:30:00.000Z","updated":"2019-01-03T14:17:53.528Z","comments":true,"path":"2018/11/26/react-proptypes/","link":"","permalink":"https://gershonv.github.io/2018/11/26/react-proptypes/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'class MyComponent extends Component &#123; // static propTypes = &#123;&#125; 第二种写法 // static defaultProps = &#123;&#125;&#125;// default propsMyComponent.defaultProps = &#123; name: 'Stranger'&#125;MyComponent.PropTypes = &#123; // 声明的prop可以是一个特殊的JS基础变量，默认情况下，下面都是可选的 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 下面示例能够渲染任何元素: numbers, strings, elements ，array, fragment optionalNode: PropTypes.node, // 需要是 React 元素 optionalElement: PropTypes.element, // 可以声明 prop 是某个类的示例 optionalMessage: PropTypes.instanceOf(Message), // 可以声明 prop 在某个 enum 中的一个 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 用来验证prop对象中的每一个属性 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 验证 prop 数组的每个子元素的类型 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 检查 prop 对象的属性的类型 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 用来检查 prop 对象的每个属性的类型 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 检查 prop 是必须存在的（required） requiredFunc: PropTypes.func.isRequired, // 用来检查任意的数值都必须存在 requiredAny: PropTypes.any.isRequired, // 你可以通过自定义验证器的方法来进行验证。 // 自定义验证器应当返回一个抛出错误的Error对象。 // 不要使用`console.warn`或者throw抛出错误，因为无法再 oneOfType 中使用 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 你也可以为'arrayOf'和'objectOf'提供自定义验证器 // 如果验证失败，应该返回一个Error对象 // 数组或者对象的每一个key都会被调用这个验证器。 // 此验证器的前面两个参数是数组或者是对象本身以及当前遍历的index(如数组下标或对象属性key) customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"HTTP - 浏览器输入 url 后 http 请求返回的完整过程","slug":"http-url-to-render","date":"2018-11-23T08:08:53.000Z","updated":"2019-01-03T15:11:54.822Z","comments":true,"path":"2018/11/23/http-url-to-render/","link":"","permalink":"https://gershonv.github.io/2018/11/23/http-url-to-render/","excerpt":"示意图 检查缓存 缓存就是把你之前访问的 web 资源，比如一些 js，css，图片什么的保存在你本机的内存或者磁盘当中。 浏览器获取了这个 url，当然就去解析了，它先去缓存当中看看有没有，从 浏览器缓存-系统缓存-路由器缓存 当中查看，如果有从缓存当中显示页面， 如果没有缓存则进行 DNS 解析 浏览器缓存相关链接：HTTP - 缓存机制 这里重点介绍 浏览器中 HTTP - 缓存机制， 因为个人对系统缓存以及路由器缓存认识较少 缓存是否到时: Cache-Control: max-age=xxx 缓存是否过期：Expires （如果设置） 资源是否发生修改: ETag If-None-Match =&gt; 304 未修改 文件的修改时间: Last-Modified If-Modified-Since =&gt; 304 未修改","text":"示意图 检查缓存 缓存就是把你之前访问的 web 资源，比如一些 js，css，图片什么的保存在你本机的内存或者磁盘当中。 浏览器获取了这个 url，当然就去解析了，它先去缓存当中看看有没有，从 浏览器缓存-系统缓存-路由器缓存 当中查看，如果有从缓存当中显示页面， 如果没有缓存则进行 DNS 解析 浏览器缓存相关链接：HTTP - 缓存机制 这里重点介绍 浏览器中 HTTP - 缓存机制， 因为个人对系统缓存以及路由器缓存认识较少 缓存是否到时: Cache-Control: max-age=xxx 缓存是否过期：Expires （如果设置） 资源是否发生修改: ETag If-None-Match =&gt; 304 未修改 文件的修改时间: Last-Modified If-Modified-Since =&gt; 304 未修改 DNS 解析 在发送 http 之前，需要进行 DNS 解析即域名解析。DNS 解析:域名到 IP 地址的转换过程。域名的解析工作由 DNS 服务器完成。解析后可以获取域名相应的 IP 地址 根据 URL 找到对应的 IP 地址。这一步通常被称为 DNS 轮询，这里面是有缓存机制的。缓存的顺序依次为：浏览器缓存-&gt;操作系统缓存-&gt;路由器缓存-&gt;DNS 提供商缓存-&gt;DNS 提供商轮询。 创建 TCP 链接TCP 三次握手四次挥手 第一次握手： client =&gt; server SYN = 1 （SYN 代表发起一个新连接）； Sequence Number = 1 （请求的标记） 第二次握手：server =&gt; client SYN = 1 （SYN 代表发起一个新连接）；Sequence Number = Y （请求的标记） acknowledgment number = 1 （确认序号，只有 ACK 标志位为 1 时，确认序号字段才有效） ACK = 1 确认序号字段有效 第三次握手：client =&gt; server acknowledgment number = Y + 1 =&gt; 确认序号为 Y + 1 ACK = 1 确认序号字段有效 这样 TCP 连接就建立了。在此之后，浏览器开始向服务器发送 http 请求，请求数据包。请求信息包含一个头部和一个请求体。 发送请求相关链接：HTTP - 导学 响应请求浏览器对于每一种请求类型的处理方式是不一样的，像 text/html、application/JavaScript、text/plain 等等这些是可以直接呈现的，而对于不能呈现的类型，浏览器会将该资源下载到本地。 那么浏览器在确认这个 response 的状态不是 301（跳转）或者 401（未授权）或其它需要做特殊处理的状态，之后开始进入呈现过程。 Renderer 进程开始解析 css rule tree 和 dom tree，这两个过程是并行的，所以一般我会把 link 标签放在页面顶部。 解析绘制过程中，当浏览器遇到 link 标签或者 script`、img ` 等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。 css rule tree 和 dom tree 生成完了之后，开始合成 render tree，这个时候浏览器会进行 layout，开始计算每一个节点的位置，然后进行绘制。 绘制结束后，关闭 TCP 连接，过程有四次挥手。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/tags/HTTP/"}]},{"title":"HTTP - keep-alive","slug":"http-长连接","date":"2018-11-23T06:16:16.000Z","updated":"2019-01-03T15:11:26.655Z","comments":true,"path":"2018/11/23/http-长连接/","link":"","permalink":"https://gershonv.github.io/2018/11/23/http-长连接/","excerpt":"HTTP 协议是无状态的HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。 什么是长连接、短连接？在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就要经过三次握手建立一次连接，但任务结束就中断连接。 客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等；当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。但从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头有加入这行代码： 1'Connection': 'keep-alive'","text":"HTTP 协议是无状态的HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。 什么是长连接、短连接？在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就要经过三次握手建立一次连接，但任务结束就中断连接。 客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等；当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。但从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头有加入这行代码： 1'Connection': 'keep-alive' 实战 test.html 123456789101112&lt;body&gt; &lt;img src=\"/test1.jpg\" alt=\"\" /&gt; &lt;img src=\"/test2.jpg\" alt=\"\" /&gt; &lt;img src=\"/test3.jpg\" alt=\"\" /&gt; &lt;img src=\"/test4.jpg\" alt=\"\" /&gt; &lt;img src=\"/test5.jpg\" alt=\"\" /&gt; &lt;img src=\"/test6.jpg\" alt=\"\" /&gt; &lt;img src=\"/test7.jpg\" alt=\"\" /&gt; &lt;img src=\"/test11.jpg\" alt=\"\" /&gt; &lt;img src=\"/test12.jpg\" alt=\"\" /&gt; &lt;img src=\"/test13.jpg\" alt=\"\" /&gt; &lt;img src=\"/test14.jpg\" alt=\"\" /&gt; &lt;img src=\"/test15.jpg\" alt=\"\" /&gt; &lt;img src=\"/test16.jpg\" alt=\"\" /&gt; &lt;img src=\"/test17.jpg\" alt=\"\" /&gt; &lt;img src=\"/test111.jpg\" alt=\"\" /&gt; &lt;img src=\"/test112.jpg\" alt=\"\" /&gt; &lt;img src=\"/test113.jpg\" alt=\"\" /&gt; &lt;img src=\"/test114.jpg\" alt=\"\" /&gt; &lt;img src=\"/test115.jpg\" alt=\"\" /&gt; &lt;img src=\"/test116.jpg\" alt=\"\" /&gt;&lt;/body&gt; server.js 12345678910111213141516171819202122232425const http = require('http')const fs = require('fs')http .createServer(function(request, response) &#123; console.log('request come', request.url) const html = fs.readFileSync('test.html', 'utf8') const img = fs.readFileSync('test.jpg') if (request.url === '/') &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;) response.end(html) &#125; else &#123; response.writeHead(200, &#123; 'Content-Type': 'image/jpg', Connection: 'keep-alive' // or close HTTP/1.1 起 默认 keep-alive &#125;) response.end(img) &#125; &#125;) .listen(8888)console.log('server listening on 8888')","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/tags/HTTP/"}]},{"title":"HTTP - 缓存机制","slug":"http-cache","date":"2018-11-23T01:23:23.000Z","updated":"2019-01-03T15:12:14.367Z","comments":true,"path":"2018/11/23/http-cache/","link":"","permalink":"https://gershonv.github.io/2018/11/23/http-cache/","excerpt":"缓存实现的步骤 首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。 如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜 如果缓存新鲜，则会直接返回缓存副本给客户端。 如果缓存不新鲜了，则表示强缓存失败，将会进入到协商缓存。 协商缓存将判断是否存在 Etag 和 Last-Modified 首部 如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端 否则的话表示协商缓存未命中，服务器会返回新的资源。 强缓存 服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。 强缓存是通过 Expires 首部或 Cache-Control: max-age 来实现的。 Expires: 响应头，代表该资源的过期时间。 Cache-Control: 请求/响应头，缓存控制字段，精确控制缓存策略。","text":"缓存实现的步骤 首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。 如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜 如果缓存新鲜，则会直接返回缓存副本给客户端。 如果缓存不新鲜了，则表示强缓存失败，将会进入到协商缓存。 协商缓存将判断是否存在 Etag 和 Last-Modified 首部 如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端 否则的话表示协商缓存未命中，服务器会返回新的资源。 强缓存 服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。 强缓存是通过 Expires 首部或 Cache-Control: max-age 来实现的。 Expires: 响应头，代表该资源的过期时间。 Cache-Control: 请求/响应头，缓存控制字段，精确控制缓存策略。 server.js - demo 12345678910111213const http = require('http')http .createServer(function(request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Conche-Control': 'max-age=2000, public' // 缓存时间 2000s；public: 资源允许被中间服务器缓存 &#125;) response.end(\"console.log('script loaded')\") &#125;) .listen(3301)console.log('http://127.0.0.1:3301') Expires(HTTP/1.0)Expires 和 Cache-Control: max-age 都是用来标识资源的过期时间的首部。 由于 expires 是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在 http1.1 中我们有了 expires 的完全替代首部 cache-control：max-age Cache-Control(HTTP/1.1)除了可以设置 max-age 相对过期时间以外，还可以设置成如下几种值： public，资源允许被中间服务器缓存。 浏览器请求服务器时，如果缓存时间没到，中间服务器直接返回给浏览器内容，而不必请求源服务器。 private，资源不允许被中间代理服务器缓存 浏览器请求服务器时，中间服务器都要把浏览器的请求透传给服务器。 no-cache，浏览器不做缓存检查。 每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存（304）。 no-store，浏览器和中间代理服务器都不能缓存资源。 每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源。 must-revalidate，可以缓存，但是使用之前必须先向源服务器确认。 proxy-revalidate，要求缓存服务器针对缓存资源向源服务器进行确认。 s-maxage：缓存服务器对资源缓存的最大时间。 Cache-Control 对缓存的控制粒度更细，包括缓存代理服务器的缓存控制。 协商缓存 由服务端决定并告知客户端是否使用缓存。 协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。协商缓存是通过请求头 Last-Modified 或 Etag 来实现的。 Last-Modified 标识的是文档最后修改时间 Etag 则是以文档内容来进行编码的。 Last-Modified 响应头，资源最近修改时间，由服务器告诉浏览器。 Last-Modified （上次修改时间）主要配合 If-Modified-Since 或者 If-Unmodified-Since 使用， 对比上次修改时间以验证资源是否需要更新 If-Modified-Since: 请求头 首次请求资源时，服务器在返回资源的同时，会在 Response Headers 中写入 Last-Modified 首部，表示该资源在服务器上的最后修改时间。 当再次请求该资源时，会在 Request Headers 中写入 If-Modified-Since 首部，此时的 If-Modified-Since 的值是首次请求资源时所返回的 Last-Modified 的值。 服务器接收到请求后，会根据 If-Modified-Since 的值判断资源在该日期之后是否发生过变化。 如果没有，则会返回 304 Not Modified;如果变化了，则会返回变化过后的资源，同时更新 Last-Modified 的值。 资源未更新 network 面板截图 资源发生更新 network 面板截图可以看到 Last-Modified 和 If-Modified-Since 标识的时间不一样 server.js - demo 1234567891011121314const http = require('http')http .createServer(function(request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Conche-Control': 'max-age=2000, public', // 缓存时间 2000s；public: 资源允许被中间服务器缓存 'Last-Modified': '123' &#125;) response.end(\"console.log('script loaded')\") &#125;) .listen(3301)console.log('http://127.0.0.1:3301') Etag 响应头，资源标识，由服务器告诉浏览器。 Etag 和 If-None-Match 配合使用， （文件内容对比）对比资源的签名来决定是否使用缓存。 server.js - demo 123456789101112131415161718192021222324252627const http = require('http')http .createServer(function(request, response) &#123; const etag = request.headers['if-none-match'] if (etag === '777') &#123; response.writeHead(304, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=120, no-cache', // 缓存时间 120s；no-cache: 浏览器不做缓存检查 'Last-Modified': '123', Etag: '777' &#125;) response.end() &#125; else &#123; // etag change response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Conche-Control': 'max-age=120, no-cache', // 缓存时间 120s；no-cache: 浏览器不做缓存检查 'Last-Modified': '123', Etag: '777' &#125;) response.end(\"console.log('script loaded')\") &#125; &#125;) .listen(3301)console.log('http://127.0.0.1:3301') 总结与缓存方案 服务器和浏览器约定资源过期时间 Cache-Control: expires=xxx 服务器告诉浏览器资源上次修改时间 Last-Modified 增加相对时间的控制 Cache-Control: max-age=xxx 增加文件内容对比，引入Etag 缓存优先级 Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified 参考与相关链接： 浅谈 HTTP 缓存 面试精选之 http 缓存","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/tags/HTTP/"}]},{"title":"HTTP - 跨域","slug":"http-跨域","date":"2018-11-22T06:10:57.000Z","updated":"2019-01-03T15:11:41.699Z","comments":true,"path":"2018/11/22/http-跨域/","link":"","permalink":"https://gershonv.github.io/2018/11/22/http-跨域/","excerpt":"什么是跨域 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。 我们可以简单的重现浏览器的跨域问题： server.js 模拟客户端： 12345678910111213const http = require('http')const fs = require('fs')http .createServer(function(request, response) &#123; console.log('request come', request.url) const html = fs.readFileSync('demo.html', 'utf8') response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;) response.end(html) &#125;) .listen(3300) // http://127.0.0.1:3300 demo.html 展示的页面： 12345678&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.open('GET', 'http://127.0.0.1:6060') xhr.send() &lt;/script&gt;&lt;/body&gt; server2.js 模拟服务端： 12345678910const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.end('server2 response') &#125;) .listen(6060)console.log('server listening on 6060') 打开 http://127.0.0.1:3300 即可看到 Access to XMLHttpRequest at ‘http://127.0.0.1:6060/‘ from origin ‘http://127.0.0.1:3300‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 后续将讲到如何去解决这个问题。","text":"什么是跨域 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。 我们可以简单的重现浏览器的跨域问题： server.js 模拟客户端： 12345678910111213const http = require('http')const fs = require('fs')http .createServer(function(request, response) &#123; console.log('request come', request.url) const html = fs.readFileSync('demo.html', 'utf8') response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;) response.end(html) &#125;) .listen(3300) // http://127.0.0.1:3300 demo.html 展示的页面： 12345678&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.open('GET', 'http://127.0.0.1:6060') xhr.send() &lt;/script&gt;&lt;/body&gt; server2.js 模拟服务端： 12345678910const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.end('server2 response') &#125;) .listen(6060)console.log('server listening on 6060') 打开 http://127.0.0.1:3300 即可看到 Access to XMLHttpRequest at ‘http://127.0.0.1:6060/‘ from origin ‘http://127.0.0.1:3300‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 后续将讲到如何去解决这个问题。 常见的跨域场景 所谓的同源是指，域名、协议、端口均为相同。 1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域的解决方法如下 JSONP HTML 标签里，一些标签比如 script、img 这样的获取资源的标签是没有跨域限制的 jsonp 原生的实现方式（以前面的代码为例） demo.html 123456789101112&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; // 1. 动态创建 script，并引入地址；2. 插入html中；3.通过callback 回调得到数据 let script = document.createElement('script') script.src = 'http://127.0.0.1:6060/login?username=guodada&amp;callback=onBack' document.body.appendChild(script) function onBack(res) &#123; console.log(res) &#125; &lt;/script&gt;&lt;/body&gt; server2.js 服务端： 1234567891011121314151617const http = require('http')const url = require('url')http .createServer(function(request, response) &#123; console.log('request come', request.url) const data = &#123; name: 'guodada' &#125; // 需要传递的数据 const &#123; callback &#125; = url.parse(request.url, true).query // 处理 get 请求, 拿到callback response.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;) const jsonpCallback = callback + `($&#123;JSON.stringify(data)&#125;)` // 相当于 onBack(&#123;\"name\":\"guodada\"&#125;) response.end(jsonpCallback) &#125;) .listen(6060)console.log('server listening on 6060') 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现 get 请求 CORS简介因为是目前主流的跨域解决方案。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。IE8+：IE8/9 需要使用 XDomainRequest 对象来支持 CORS。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。 请求方式为 HEAD、POST 或者 GET HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。 下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个 Origin 字段。 server2.js 1234567891011121314151617const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.writeHead(200, &#123; 'Access-Control-Allow-Origin': 'http://127.0.0.1:3300', // 只有 http://127.0.0.1:3300 才能访问 'Access-Control-Allow-Credentials': true, // 允许携带 cookie 'Content-Type': 'text/html; charset=utf-8' &#125;) response.end('hello cors') &#125;) .listen(6060)console.log('server listening on 6060') demo.html 1234567891011&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.withCredentials = true // server: 'Access-Control-Allow-Credentials': true xhr.open('GET', 'http://127.0.0.1:6060') xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') xhr.send() &lt;/script&gt;&lt;/body&gt; Access-Control-Allow-Origin : 该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个*，表示接受任意域名的请求 Access-Control-Allow-Credentials: 表示是否允许发送 Cookie Access-Control-Expose-Headers: CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。 withCredentials 属性上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials 字段。 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略 withCredentials 设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials。 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 demo.html 1234567// 部分代码const xhr = new XMLHttpRequest()xhr.withCredentials = true // 允许携带 cookiexhr.open('PUT', 'http://127.0.0.1:6060') // 使用 put 请求，server：'Access-Control-Request-Method': 'PUT'xhr.setRequestHeader('X-Test-Cors', '123') // 设置预检头xhr.send() server2.js 1234567891011121314151617const http = require('http')http .createServer(function(request, response) &#123; response.writeHead(200, &#123; 'Access-Control-Allow-Origin': 'http://127.0.0.1:3300', // 只有 http://127.0.0.1:3300 才能访问 'Access-Control-Allow-Credentials': true, // 允许携带 cookie 'Access-Control-Allow-Headers': 'X-Test-Cors', // 预检 'Access-Control-Allow-Methods': 'POST, PUT, DELETE', // 支持 'Access-Control-Max-Age': '1000' // 指定本次预检请求的有效期，单位为秒 &#125;) response.end('hello cors') &#125;) .listen(6060)console.log('server listening on 6060') Access-Control-Allow-Methods: 返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers: 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。 Access-Control-Max-Age: 用来指定本次预检请求的有效期，单位为秒。 CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 postMessage…. 略 window.name + iframe…. 略 参考 正确面对跨域，别慌","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/tags/HTTP/"},{"name":"跨域","slug":"跨域","permalink":"https://gershonv.github.io/tags/跨域/"}]},{"title":"HTTP - TCP 三次握手四次挥手","slug":"http-TCP","date":"2018-11-21T01:47:17.000Z","updated":"2019-01-03T15:12:01.262Z","comments":true,"path":"2018/11/21/http-TCP/","link":"","permalink":"https://gershonv.github.io/2018/11/21/http-TCP/","excerpt":"TCP 的三次握手 HTTP 请求与 TCP 链接之间的关系，在客户端向服务端请求和返回的过程中，是需要去创建一个 TCP connection，因为 HTTP 是不存在链接这样一个概念的，它只有请求和响应这样一个概念，请求和响应都是一个数据包，中间要通过一个传输通道，这个传输通道就是在 TCP 里面创建了一个从客户端发起和服务端接收的一个链接，TCP 链接在创建的时候是有一个三次握手(三次网络传输)这样一个消耗在的。 下面是 TCP 报文格式图： ↓↓↓↓ 有几个字段需要重点介绍下： Seq 序号: sequeence number，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：acknowledgment number，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。","text":"TCP 的三次握手 HTTP 请求与 TCP 链接之间的关系，在客户端向服务端请求和返回的过程中，是需要去创建一个 TCP connection，因为 HTTP 是不存在链接这样一个概念的，它只有请求和响应这样一个概念，请求和响应都是一个数据包，中间要通过一个传输通道，这个传输通道就是在 TCP 里面创建了一个从客户端发起和服务端接收的一个链接，TCP 链接在创建的时候是有一个三次握手(三次网络传输)这样一个消耗在的。 下面是 TCP 报文格式图： ↓↓↓↓ 有几个字段需要重点介绍下： Seq 序号: sequeence number，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：acknowledgment number，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 第一次握手 客户端发送一个 TCP 的 SYN 标志位置 1 的包指明客户打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 简单记忆： 建立连接，等待服务器确认 Sequeence Number = X =&gt; 标识字节流字段为 X SYN = 1 =&gt; 发起一个新连接，序号为 1 第二次握手 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1 同时，将确认序号(Acknowledgement Number)设置为客户的 I S N 加 1 以.即 X+1。 简单记忆： 服务器收到请求后确认联机 Sequeence Number = Y =&gt; 标识字节流字段为 Y acknowledgment number = X + 1 =&gt; 确认序号为 X + 1 SYN = 1 =&gt; 发起一个新连接，序号为 1 ACK = 1 =&gt; 确认序号有效 第三次握手 客户端再次发送确认包(ACK)SYN 标志位为 0,ACK 标志位为 1.并且把服务器发来 ACK 的序号字段+1,放在确定字段中发送给对方.并且在数据段放写 ISN 的+1 简单记忆：检查 ACK 是否正确, 若正确则建立连接。 acknowledgment number = Y + 1 =&gt; 确认序号为 Y + 1 ACK = 1 =&gt; 确认序号有效 TCP 四次挥手TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/tags/HTTP/"}]},{"title":"HTTP - 导学","slug":"http-导学","date":"2018-11-20T11:31:23.000Z","updated":"2019-01-03T15:11:49.161Z","comments":true,"path":"2018/11/20/http-导学/","link":"","permalink":"https://gershonv.github.io/2018/11/20/http-导学/","excerpt":"经典五层网络模型 在每一台电脑，每个服务器都有这这几个网络模型层级来维护整个网络数据传输过程。 一张图了解 TCP/IP 五层网络模型 物理层：将信息编码成电流脉冲或其它信号用于网上传输；（电线、光缆等） 数据链路层：数据链路层通过物理网络链路供数据传输。可以简单的理解为：规定了 0 和 1 的分包形式，确定了网络数据包的形式。 网络层：网络层负责在源和终点之间建立连接;（路由器等） 传输层： 敲重点！ 传输层向用户提供可靠的端对端(End-to-End)服务。 常用的（TCP／IP）协议 、UDP 协议； 应用层：敲重点！ 为应用软件提供了很多服务，帮我们实现了 HTTP 协议，我们只要按照规则去使用 HTTP 协议；它构建于 TCP 协议之上；屏蔽了网络传输相关细节。 重点在 应用层 和 传输层 上：http 是在应用层上去实现的，而 http 协议基于传输层的 TCP UDP 协议。","text":"经典五层网络模型 在每一台电脑，每个服务器都有这这几个网络模型层级来维护整个网络数据传输过程。 一张图了解 TCP/IP 五层网络模型 物理层：将信息编码成电流脉冲或其它信号用于网上传输；（电线、光缆等） 数据链路层：数据链路层通过物理网络链路供数据传输。可以简单的理解为：规定了 0 和 1 的分包形式，确定了网络数据包的形式。 网络层：网络层负责在源和终点之间建立连接;（路由器等） 传输层： 敲重点！ 传输层向用户提供可靠的端对端(End-to-End)服务。 常用的（TCP／IP）协议 、UDP 协议； 应用层：敲重点！ 为应用软件提供了很多服务，帮我们实现了 HTTP 协议，我们只要按照规则去使用 HTTP 协议；它构建于 TCP 协议之上；屏蔽了网络传输相关细节。 重点在 应用层 和 传输层 上：http 是在应用层上去实现的，而 http 协议基于传输层的 TCP UDP 协议。 HTTP 发展历史HTTP/0.9 HTTP/0.9 只支持一种方法—— Get，请求只有一行 没有 header 等描述数据的信息 服务器发送完毕，就关闭 TCP 连接 HTTP/1.0 请求与响应支持 header，增加了状态码，响应对象的一开始是一个响应状态行 协议版本信息需要随着请求一起发送，支持 HEAD，POST 方法 HTTP/1.1在 HTTP/1.0 上增加了一些功能来优化网络链接的过程： 持久连接 HTTP/1.0 版本里一个 HTTP 请求就要在客户端和服务端之间创建一次 TCP 连接，在服务器返回完内容后就关闭了。相对来说消耗比较高。 pipeline 我们可以在同个连接里发送多个请求，但是服务端要对这些请求都是要按照顺序进行内容的返回。前一个请求等待时间较长，后一个请求处理较快，后一个请求也不能进行内容响应，需要等前一个请求完成后才可响应下次请求，这也是串行/并行的概念，而这个在 HTTP/2.0 中做了优化 host 和其他一些命令 有了 host 之后可以在同一台服务器（物理服务器）同时跑多个不同的 web 服务 ，比如说 node.js 的服务、java 的服务。 引入更多缓存控制机制：如 etag，cache-control … HTTP/2.0 使用二进制分帧层 在 HTTP/1.1 中大部分的数据传输都是以字符串方式进行的，HTTP/2.0 则在应用层与传输层之间增加一个二进制分帧层。同样因为这个好处，pipeline 在同个连接里发送多个请求不再需要按照顺序来返回处理。 头部压缩 头信息压缩：在 HTTP/1.1 里面，我们每次发送和返回请求 http header 都是必须要进行完整的发送和返回的，占用带宽。使用首部表来跟踪和存储之前发送的键值对，对于相同的内容，不会再每次请求和响应时发送。 服务端推送 在 HTTP/2.0 中，服务器可以向客户发送请求之外的内容，比如正在请求一个页面时，服务器会把页面相关的 logo，CSS 等文件直接推送到客户端，而不会等到请求来的时候再发送，因为服务器认为客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源。 … HTTP 的三次握手http-tcp 的三次握手四次挥手 URI-URL 和 URN URI : Uniform Resource Identifier/统一资源标志符 URL 和 URN 都是 URI 的子集 统一资源标识符（URI）提供了一个简单、可扩展的资源标识方式。 URL : Uniform Resource Locator/统一资源定位器 URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上。 采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。123456;`http://user:pass@host.com:80/path?query=string#hash` // @example url 的组成/** * http:// ===&gt; 协议，类似的还有 ftp、https 等 * user:pass@host.com:80 ===&gt; 存有该资源的主机IP地址（有时也包括端口号） * /path ===&gt; 主机资源的具体地址。如目录和文件名等。 */ URN : 永久统一资源定位符 在资源移动之后还能被找到 HTTP 报文请求行 声明 请求方法 、主机域名、资源路径 &amp; 协议版本 请求行的组成 = 请求方法 + 请求路径 + 协议版本 12GET /test/hi-there.txt HTTP/1.0// 请求行的组成 = 请求方法 + 请求路径 + 协议版本 请求头 声明 客户端、服务器 / 报文的部分信息 请求和响应报文的通用 Header 常见请求 Header 请求体 存放 需发送给服务器的数据信息 除此外还有响应报文，略 创建一个简单的 http 服务12345678const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.end('123') &#125;) .listen(8888)","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://gershonv.github.io/tags/HTTP/"}]},{"title":"[转] JavaScript深入之继承的多种方式和优缺点","slug":"js-深入之继承的多种方式和优缺点","date":"2018-11-15T06:18:41.000Z","updated":"2019-01-03T15:09:17.768Z","comments":true,"path":"2018/11/15/js-深入之继承的多种方式和优缺点/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之继承的多种方式和优缺点/","excerpt":"写在前面本文讲解 JavaScript 各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript 高级程序设计》写得真是太好了！ 1.原型链继承123456789101112131415function Parent() &#123; this.name = 'kevin'&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child1 = new Child()console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 1234567891011121314151617function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child()console.log(child2.names) // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向 Parent 传参","text":"写在前面本文讲解 JavaScript 各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript 高级程序设计》写得真是太好了！ 1.原型链继承123456789101112131415function Parent() &#123; this.name = 'kevin'&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child1 = new Child()console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 1234567891011121314151617function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child()console.log(child2.names) // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向 Parent 传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123; Parent.call(this)&#125;var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child()console.log(child2.names) // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent(name) &#123; this.name = name&#125;function Child(name) &#123; Parent.call(this, name)&#125;var child1 = new Child('kevin')console.log(child1.name) // kevinvar child2 = new Child('daisy')console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()var child1 = new Child('kevin', '18')child1.colors.push('black')console.log(child1.name) // kevinconsole.log(child1.age) // 18console.log(child1.colors) // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20')console.log(child2.name) // daisyconsole.log(child2.age) // 20console.log(child2.colors) // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person)var person2 = createObj(person)person1.name = 'person1'console.log(person2.name) // kevinperson1.firends.push('taylor')console.log(person2.friends) // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = object.create(o) clone.sayName = function() &#123; console.log('hi') &#125; return clone&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()var child1 = new Child('kevin', '18')console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent() 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18') 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name) 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 123456789101112131415161718192021222324function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;// 关键的三步var F = function() &#123;&#125;F.prototype = Parent.prototypeChild.prototype = new F()var child1 = new Child('kevin', '18')console.log(child1) 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;// 当我们使用的时候：prototype(Child, Parent) 引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接 《JavaScript 深入之从原型到原型链》 《JavaScript 深入之 call 和 apply 的模拟实现》 《JavaScript 深入之 new 的模拟实现》 《JavaScript 深入之创建对象》 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] JavaScript深入之创建对象的多种方式以及优缺点 ","slug":"js-深入之创建对象的多种方式以及优缺点","date":"2018-11-15T06:16:31.000Z","updated":"2019-01-03T15:10:05.555Z","comments":true,"path":"2018/11/15/js-深入之创建对象的多种方式以及优缺点/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之创建对象的多种方式以及优缺点/","excerpt":"写在前面这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意： 这篇文章更像是笔记，因为《JavaScript 高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object() o.name = name o.getName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = createPerson('kevin') 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) &#123; this.name = name this.getName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person('kevin') 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次","text":"写在前面这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意： 这篇文章更像是笔记，因为《JavaScript 高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object() o.name = name o.getName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = createPerson('kevin') 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) &#123; this.name = name this.getName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person('kevin') 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 2.1 构造函数模式优化12345678910function Person(name) &#123; this.name = name this.getName = getName&#125;function getName() &#123; console.log(this.name)&#125;var person1 = new Person('kevin') 优点：解决了每个方法都要被重新创建的问题 缺点：这叫啥封装…… 3. 原型模式12345678function Person(name) &#123;&#125;Person.prototype.name = 'keivn'Person.prototype.getName = function() &#123; console.log(this.name)&#125;var person1 = new Person() 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 3.1 原型模式优化12345678910function Person(name) &#123;&#125;Person.prototype = &#123; name: 'kevin', getName: function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person() 优点：封装性好了一点 缺点：重写了原型，丢失了 constructor 属性 3.2 原型模式优化1234567891011function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'kevin', getName: function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person() 优点：实例可以通过 constructor 属性找到所属构造函数 缺点：原型模式该有的缺点还是有 4. 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person() 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 4.1 动态原型模式12345678910function Person(name) &#123; this.name = name if (typeof this.getName != 'function') &#123; Person.prototype.getName = function() &#123; console.log(this.name) &#125; &#125;&#125;var person1 = new Person() 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name if (typeof this.getName != 'function') &#123; Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name) &#125; &#125; &#125;&#125;var person1 = new Person('kevin')var person2 = new Person('daisy')// 报错 并没有该方法person1.getName()// 注释掉上面的代码，这句是可以执行的。person2.getName() 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) &#123; this.name = name if (typeof this.getName != 'function') &#123; Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name) &#125; &#125; return new Person(name) &#125;&#125;var person1 = new Person('kevin')var person2 = new Person('daisy')person1.getName() // kevinperson2.getName() // daisy 5.1 寄生构造函数模式12345678910111213function Person(name) &#123; var o = new Object() o.name = name o.getName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = new Person('kevin')console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改 Array 构造函数，我们可以这样写： 123456789101112131415161718192021function SpecialArray() &#123; var values = new Array() for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]) &#125; values.toPipedString = function() &#123; return this.join('|') &#125; return values&#125;var colors = new SpecialArray('red', 'blue', 'green')var colors2 = SpecialArray('red2', 'blue2', 'green2')console.log(colors)console.log(colors.toPipedString()) // red|blue|greenconsole.log(colors2)console.log(colors2.toPipedString()) // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个 new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i])&#125; 可以替换成： 1values.push.apply(values, arguments) 5.2 稳妥构造函数模式1234567891011121314151617function person(name) &#123; var o = new Object() o.sayName = function() &#123; console.log(name) &#125; return o&#125;var person1 = person('kevin')person1.sayName() // kevinperson1.name = 'daisy'person1.sayName() // kevinconsole.log(person1.name) // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。 下一篇文章JavaScript 深入之继承的多种方式和优缺点 相关链接 《JavaScript 深入之从原型到原型链》 《JavaScript 深入之 new 的模拟实现》 《JavaScript 深入之 call 和 apply 的模拟实现》 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转]  JavaScript深入之类数组对象与arguments","slug":"js-深入之类数组对象与arguments","date":"2018-11-15T06:14:44.000Z","updated":"2019-01-03T15:09:23.438Z","comments":true,"path":"2018/11/15/js-深入之类数组对象与arguments/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之类数组对象与arguments/","excerpt":"类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array = ['name', 'age', 'sex']var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]) // nameconsole.log(arrayLike[0]) // namearray[0] = 'new name'arrayLike[0] = 'new name'","text":"类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array = ['name', 'age', 'sex']var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]) // nameconsole.log(arrayLike[0]) // namearray[0] = 'new name'arrayLike[0] = 'new name' 长度12console.log(array.length) // 3console.log(arrayLike.length) // 3 遍历123456for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 1arrayLike.push('4') 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用 Function.call 间接调用： 1234567891011var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;Array.prototype.join.call(arrayLike, '&amp;') // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0) // [\"name\", \"age\", \"sex\"]// slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item) &#123; return item.toUpperCase()&#125;)// [\"NAME\", \"AGE\", \"SEX\"] 类数组转对象在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;// 1. sliceArray.prototype.slice.call(arrayLike) // [\"name\", \"age\", \"sex\"]// 2. spliceArray.prototype.splice.call(arrayLike, 0) // [\"name\", \"age\", \"sex\"]// 3. ES6 Array.fromArray.from(arrayLike) // [\"name\", \"age\", \"sex\"]// 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 Arguments 对象接下来重点讲讲 Arguments 对象。 Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments)&#125;foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和 length 属性之外，还有一个 callee 属性，接下来我们一个一个介绍。 length 属性Arguments 对象的 length 属性，表示实参的长度，举个例子： 12345678910function foo(b, c, d) &#123; console.log('实参的长度为：' + arguments.length)&#125;console.log('形参的长度为：' + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee 属性Arguments 对象的 callee 属性，通过它可以调用函数自身。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = []for (var i = 0; i &lt; 3; i++) &#123; ;(data[i] = function() &#123; console.log(arguments.callee.i) &#125;).i = i&#125;data[0]()data[1]()data[2]()// 0// 1// 2 接下来讲讲 arguments 对象的几个注意要点： arguments 和对应参数的绑定1234567891011121314151617181920212223242526function foo(name, age, sex, hobbit) &#123; console.log(name, arguments[0]) // name name // 改变形参 name = 'new name' console.log(name, arguments[0]) // new name new name // 改变arguments arguments[1] = 'new age' console.log(age, arguments[1]) // new age new age // 测试未传入的是否会绑定 console.log(sex) // undefined sex = 'new sex' console.log(sex, arguments[2]) // new sex undefined arguments[3] = 'new hobbit' console.log(hobbit, arguments[3]) // undefined new hobbit&#125;foo('name', 'age') 传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123; bar.apply(this, arguments)&#125;function bar(a, b, c) &#123; console.log(a, b, c)&#125;foo(1, 2, 3) 强大的 ES6使用 ES6 的 … 运算符，我们可以轻松转成数组。 12345function func(...arguments) &#123; console.log(arguments) // [1, 2, 3]&#125;func(1, 2, 3) 应用arguments 的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载… 欢迎留言回复。 下一篇文章JavaScript 深入之创建对象的多种方式以及优缺点 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] Javascript深入之new的模拟实现","slug":"js-深入之new的模拟实现","date":"2018-11-15T06:10:59.000Z","updated":"2019-01-03T15:10:42.012Z","comments":true,"path":"2018/11/15/js-深入之new的模拟实现/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之new的模拟实现/","excerpt":"new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子： 12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku(name, age) &#123; this.name = name this.age = age this.habit = 'Games'&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60Otaku.prototype.sayYourName = function() &#123; console.log('I am ' + this.name)&#125;var person = new Otaku('Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName() // I am Kevin","text":"new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子： 12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku(name, age) &#123; this.name = name this.age = age this.habit = 'Games'&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60Otaku.prototype.sayYourName = function() &#123; console.log('I am ' + this.name)&#125;var person = new Otaku('Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName() // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () &#123; ……&#125;// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们可以尝试着写第一版了： 1234567891011// 第一版代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype Constructor.apply(obj, arguments) return obj&#125; 在这一版中，我们： 用 new Object() 的方式新建了一个对象 obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj 更多关于： 原型与原型链，可以看《JavaScript 深入之从原型到原型链》 apply，可以看《JavaScript 深入之 call 和 apply 的模拟实现》 经典继承，可以看《JavaScript 深入之继承》 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku(name, age) &#123; this.name = name this.age = age this.habit = 'Games'&#125;Otaku.prototype.strength = 60Otaku.prototype.sayYourName = function() &#123; console.log('I am ' + this.name)&#125;function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype Constructor.apply(obj, arguments) return obj&#125;var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName() // I am Kevin []~(￣ ▽ ￣)~** 返回值效果实现接下来我们再来看一种情况，假如构造函数有返回值，举个例子： 12345678910111213141516function Otaku(name, age) &#123; this.strength = 60 this.age = age return &#123; name: name, habit: 'Games' &#125;&#125;var person = new Otaku('Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku(name, age) &#123; this.strength = 60 this.age = age return 'handsome boy'&#125;var person = new Otaku('Kevin', '18')console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再来看第二版的代码，也是最后一版的代码： 1234567891011// 第二版的代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype var ret = Constructor.apply(obj, arguments) return typeof ret === 'object' ? ret : obj&#125; 下一篇文章JavaScript 深入之类数组对象与 arguments 相关链接 《JavaScript 深入之从原型到原型链》 《JavaScript 深入之 call 和 apply 的模拟实现》 《JavaScript 深入之继承》 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] Javascript深入之bind的模拟实现","slug":"js-深入之bind的模拟实现","date":"2018-11-15T06:07:43.000Z","updated":"2019-01-03T15:10:54.849Z","comments":true,"path":"2018/11/15/js-深入之bind的模拟实现/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之bind的模拟实现/","excerpt":"bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数","text":"bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现从第一个特点开始，我们举个例子： 123456789101112var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;// 返回了一个函数var bindFoo = bar.bind(foo)bindFoo() // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript 深入之 call 和 apply 的模拟实现》。我们来写第一版的代码： 1234567// 第一版Function.prototype.bind2 = function(context) &#123; var self = this return function() &#123; return self.apply(context) &#125;&#125; 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = &#123; value: 1&#125;function bar() &#123; return this.value&#125;var bindFoo = bar.bind(foo)console.log(bindFoo()) // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 123456789101112131415var foo = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value) console.log(name) console.log(age)&#125;var bindFoo = bar.bind(foo, 'daisy')bindFoo('18')// 1// daisy// 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： 123456789101112// 第二版Function.prototype.bind2 = function(context) &#123; var self = this // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1) return function() &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments) return self.apply(context, args.concat(bindArgs)) &#125;&#125; 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2var foo = &#123; value: 1&#125;function bar(name, age) &#123; this.habit = 'shopping' console.log(this.value) console.log(name) console.log(age)&#125;bar.prototype.friend = 'kevin'var bindFoo = bar.bind(foo, 'daisy')var obj = new bindFoo('18')// undefined// daisy// 18console.log(obj.habit)console.log(obj.friend)// shopping// kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript 深入系列之 new 的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// 第三版Function.prototype.bind2 = function(context) &#123; var self = this var args = Array.prototype.slice.call(arguments, 1) var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments) // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)) &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype return fBound&#125; 如果对原型链稍有困惑，可以查看《JavaScript 深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 12345678910111213141516// 第四版Function.prototype.bind2 = function(context) &#123; var self = this var args = Array.prototype.slice.call(arguments, 1) var fNOP = function() &#123;&#125; var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound&#125; 到此为止，大的问题都已经解决，给自己一个赞！o(￣ ▽ ￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： 1self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2var foo = &#123; value: 1, bar: bar.bind(null)&#125;function bar() &#123; console.log(this.value)&#125;foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ 123if (typeof this !== 'function') &#123; throw new Error('Function.prototype.bind - what is trying to be bound is not callable')&#125; 3.我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： 123456789101112131415161718192021Function.prototype.bind2 = function(context) &#123; if (typeof this !== 'function') &#123; throw new Error( 'Function.prototype.bind - what is trying to be bound is not callable' ) &#125; var self = this var args = Array.prototype.slice.call(arguments, 1) var fNOP = function() &#123;&#125; var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)) &#125; fNOP.prototype = this.prototype fBound.prototype = new fNOP() return fBound&#125; 下一篇文章《JavaScript 深入系列之 new 的模拟实现》 相关链接 《JavaScript 深入之从原型到原型链》 《JavaScript 深入之 call 和 apply 的模拟实现》 《JavaScript 深入系列之 new 的模拟实现》 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] JavaScript深入之call和apply的模拟实现","slug":"js-深入之call和apply的模拟实现","date":"2018-11-15T06:04:31.000Z","updated":"2019-01-03T15:10:48.661Z","comments":true,"path":"2018/11/15/js-深入之call和apply的模拟实现/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之call和apply的模拟实现/","excerpt":"call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call(foo) // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了","text":"call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call(foo) // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;foo.bar() // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this context.fn() delete context.fn&#125;// 测试一下var foo = &#123; value: 1&#125;function bar() &#123; console.log(this.value)&#125;bar.call2(foo) // 1 正好可以打印 1 哎！是不是很开心！(～￣ ▽ ￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = &#123; value: 1&#125;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;bar.call(foo, 'kevin', 18)// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = []for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']')&#125;// 执行后 args为 [\"arguments[1]\", \"arguments[2]\", \"arguments[3]\"] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到 ES6 的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args + ')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) &#123; context.fn = this var args = [] for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']') &#125; eval('context.fn(' + args + ')') delete context.fn&#125;// 测试一下var foo = &#123; value: 1&#125;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;bar.call2(foo, 'kevin', 18)// kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 1234567var value = 1function bar() &#123; console.log(this.value)&#125;bar.call(null) // 1 虽然这个例子本身不使用 call，结果依然一样。 2.函数是可以有返回值的！ 举个例子： 123456789101112131415161718var obj = &#123; value: 1&#125;function bar(name, age) &#123; return &#123; value: this.value, name: name, age: age &#125;&#125;console.log(bar.call(obj, 'kevin', 18))// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function(context) &#123; var context = context || window context.fn = this var args = [] for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']') &#125; var result = eval('context.fn(' + args + ')') delete context.fn return result&#125;// 测试一下var value = 2var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value) return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call(null) // 2console.log(bar.call2(obj, 'kevin', 18))// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣ ▽ ￣）ｄ apply 的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 123456789101112131415161718Function.prototype.apply = function(context, arr) &#123; var context = Object(context) || window context.fn = this var result if (!arr) &#123; result = context.fn() &#125; else &#123; var args = [] for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']') &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result&#125; 下一篇文章JavaScript 深入之 bind 的模拟实现 重要参考知乎问题 不能使用 call、apply、bind，如何用 js 实现 call 或者 apply 的功能？ 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] JavaScript深入之参数按值传递","slug":"js-深入之参数按传递","date":"2018-11-15T04:06:06.000Z","updated":"2019-01-03T15:09:55.255Z","comments":true,"path":"2018/11/15/js-深入之参数按传递/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之参数按传递/","excerpt":"JavaScript 深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript 高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript 中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。","text":"JavaScript 深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript 高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript 中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1function foo(v) &#123; v = 2 console.log(v) //2&#125;foo(value)console.log(value) // 1 很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 \\_value，函数中修改的都是 \\_value 的值，而不会影响原来的 value 值。 引用传递拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所以还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 123456789var obj = &#123; value: 1&#125;function foo(o) &#123; o.value = 2 console.log(o.value) //2&#125;foo(obj)console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按引用传递成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 123456789var obj = &#123; value: 1&#125;function foo(o) &#123; o = 2 console.log(o) //2&#125;foo(obj)console.log(obj.value) // 1 如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递是指，在传递对象的时候，传递对象的引用的副本。 注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！ 所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。 所以，高程，谁叫你是红宝书嘞！ 下一篇文章JavaScript 深入之 call 和 apply 的模拟实现","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] JavaScript深入之闭包","slug":"js-深入之闭包","date":"2018-11-15T04:02:32.000Z","updated":"2019-01-03T15:08:49.375Z","comments":true,"path":"2018/11/15/js-深入之闭包/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之闭包/","excerpt":"定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1function foo() &#123; console.log(a)&#125;foo() foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……","text":"定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1function foo() &#123; console.log(a)&#125;foo() foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript 权威指南》中就讲到：从技术的角度讲，所有的 JavaScript 函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript 中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript 权威指南》，稍微做点改动： 1234567891011var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;var foo = checkscope()foo() 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript 深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this 等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this 等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的 PHP 同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO]&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript 权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = []for (var i = 0; i &lt; 3; i++) &#123; data[i] = function() &#123; console.log(i) &#125;&#125;data[0]()data[1]()data[2]() 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = []for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function(i) &#123; return function() &#123; console.log(i) &#125; &#125;)(i)&#125;data[0]()data[1]()data[2]() 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为 3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 下一篇文章JavaScript 深入之参数按值传递 相关链接如果想了解执行上下文的具体变化，不妨循序渐进，阅读这六篇： 《JavaScript 深入之词法作用域和动态作用域》 《JavaScript 深入之执行上下文栈》 《JavaScript 深入之变量对象》 《JavaScript 深入之作用域链》 《JavaScript 深入之从 ECMAScript 规范解读 this》 《JavaScript 深入之执行上下文》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"闭包","slug":"闭包","permalink":"https://gershonv.github.io/tags/闭包/"}]},{"title":"[转] JavaScript深入之执行上下文","slug":"js-深入之执行上下文","date":"2018-11-15T02:54:38.000Z","updated":"2019-01-03T15:09:39.108Z","comments":true,"path":"2018/11/15/js-深入之执行上下文/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之执行上下文/","excerpt":"JavaScript 深入系列第七篇，结合之前所讲的四篇文章，以权威指南的 demo 为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript 深入之变量对象》、《JavaScript 深入之作用域链》、《JavaScript 深入之从 ECMAScript 规范解读 this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。","text":"JavaScript 深入系列第七篇，结合之前所讲的四篇文章，以权威指南的 demo 为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript 深入之变量对象》、《JavaScript 深入之作用域链》、《JavaScript 深入之从 ECMAScript 规范解读 this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript 深入之词法作用域和动态作用域》中，提出这样一道思考题： 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;checkscope()() 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript 深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码： 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 1ECStack = [globalContext] 2.全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1ECStack = [checkscopeContext, globalContext] 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 1ECStack = [fContext, checkscopeContext, globalContext] 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1ECStack = [checkscopeContext, globalContext] 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 1ECStack = [globalContext] 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;checkscope()() 不过，在下一篇《JavaScript 深入之闭包》中也会提及这段代码的执行过程。 下一篇文章《JavaScript 深入之闭包》 相关链接《JavaScript 深入之词法作用域和动态作用域》 《JavaScript 深入之执行上下文栈》 《JavaScript 深入之变量对象》 《JavaScript 深入之作用域链》 《JavaScript 深入之从 ECMAScript 规范解读 this》 重要参考《一道 js 面试题引发的思考》","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://gershonv.github.io/tags/执行上下文/"}]},{"title":"[转] JavaScript深入之从 ECMAScript 规范解读 this","slug":"js-深入之从ECMAScript规范解读this","date":"2018-11-15T02:13:44.000Z","updated":"2019-01-03T15:10:34.284Z","comments":true,"path":"2018/11/15/js-深入之从ECMAScript规范解读this/","link":"","permalink":"https://gershonv.github.io/2018/11/15/js-深入之从ECMAScript规范解读this/","excerpt":"前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。 …… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！","text":"前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。 …… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！ Types首先是第 8 章 Types： Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript 的类型分为语言类型和规范类型。 ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的 Undefined, Null, Boolean, String, Number, 和 Object。 而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。 Reference那什么又是 Reference ？ 让我们看 8.7 章 The Reference Specification Type： The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1// 对应的Reference是：var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125; 再举个例子： 1234567891011121314var foo = &#123; bar: function() &#123; return this &#125;&#125;foo.bar() // foo// bar对应的Reference是：var BarReference = &#123; base: foo, propertyName: 'bar', strict: false&#125; 而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 这两个方法很简单，简单看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回 true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;GetValue(fooReference) // 1; GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定 this 的值关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段： 看规范 11.2.3 Function Calls： 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then a.If IsPropertyReference(ref) is true, then i.Let thisValue be GetBase(ref). b.Else, the base of ref is an Environment Record i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 7.Else, Type(ref) is not Reference. a. Let thisValue be undefined. 让我们描述一下： 1.计算 MemberExpression 的结果赋值给 ref 2.判断 ref 是不是一个 Reference 类型 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript 权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo() // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()() // MemberExpression 是 foo()var foo = &#123; bar: function() &#123; return this &#125;&#125;foo.bar() // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 2.判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个 Reference 类型。 举最后一个例子： 12345678910111213141516171819var value = 1var foo = &#123; value: 2, bar: function() &#123; return this.value &#125;&#125;//示例1console.log(foo.bar())//示例2console.log(foo.bar())//示例3console.log((foo.bar = foo.bar)())//示例4console.log((false || foo.bar)())//示例5console.log((foo.bar, foo.bar)()) foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = &#123; base: foo, name: 'bar', strict: false&#125; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： 1this = GetBase(ref)， GetBase 也已经铺垫了，获得 base value 值，这个例子中就是 foo，所以 this 的值就是 foo ，示例 1 的结果就是 2！ 唉呀妈呀，为了证明 this 指向 foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例 2： 1console.log(foo.bar()) foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例 3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例 4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例 5，逗号操作符，查看规范 11.14 Comma Operator ( , ) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 12345678910111213141516171819var value = 1var foo = &#123; value: 2, bar: function() &#123; return this.value &#125;&#125;//示例1console.log(foo.bar()) // 2//示例2console.log(foo.bar()) // 2//示例3console.log((foo.bar = foo.bar)()) // 1//示例4console.log((false || foo.bar)()) // 1//示例5console.log((foo.bar, foo.bar)()) // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() &#123; console.log(this)&#125;foo() MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么 this 的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1var foo = &#123; value: 2, bar: function() &#123; return this.value &#125;&#125;console.log((false || foo.bar)()) // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"this","slug":"this","permalink":"https://gershonv.github.io/tags/this/"}]},{"title":"[转] JavaScript深入之作用域链","slug":"js-深入之作用域链","date":"2018-11-14T09:41:00.000Z","updated":"2019-01-03T15:10:13.837Z","comments":true,"path":"2018/11/14/js-深入之作用域链/","link":"","permalink":"https://gershonv.github.io/2018/11/14/js-深入之作用域链/","excerpt":"JavaScript 深入之作用域链 JavaScript 深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。","text":"JavaScript 深入之作用域链 JavaScript 深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript 深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript 深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 123456789foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]) 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = 'global scope'function checkscope() &#123; var scope2 = 'local scope' return scope2&#125;checkscope() 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1ECStack = [checkscopeContext, globalContext] 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 12345678checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;&#125; 5.第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 6.准备工作做完，开始执行函数，随着函数的执行，修改AO的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: 'local scope' &#125;, Scope: [AO, [[Scope]]]&#125; 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 1ECStack = [globalContext] 本文相关链接 《JavaScript 深入之词法作用域和动态作用域》 《JavaScript 深入之执行上下文栈》 《JavaScript 深入之变量对象》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"原型/原型链","slug":"原型-原型链","permalink":"https://gershonv.github.io/tags/原型-原型链/"}]},{"title":"[转] JavaScript深入之变量对象","slug":"js-深入之变量对象","date":"2018-11-14T08:44:48.000Z","updated":"2019-01-03T15:09:49.300Z","comments":true,"path":"2018/11/14/js-深入之变量对象/","link":"","permalink":"https://gershonv.github.io/2018/11/14/js-深入之变量对象/","excerpt":"在上篇《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。","text":"在上篇《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当 JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 1234567891011121314151617// 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象console.log(this)// 全局对象是由 Object 构造函数实例化的一个对象。console.log(this instanceof Object)// 预定义了一堆，嗯，一大堆函数和属性console.log(Math.random())console.log(this.Math.random())// 作为全局变量的宿主。var a = 1console.log(window.a)// 客户端 JavaScript 中，全局对象有 window 属性指向自身。this.window.b = 2console.log(this.b) 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码，变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 123456789function foo(a) &#123; var b = 2 function c() &#123;&#125; var d = function() &#123;&#125; b = 3&#125;foo(1) 在进入执行上下文后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题最后让我们看几个例子： 1.第一题 123456789101112function foo() &#123; console.log(a) a = 1&#125;foo() // ???function bar() &#123; a = 1 console.log(a)&#125;bar() // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 2.第二题 1234567console.log(foo)function foo() &#123; console.log('foo')&#125;var foo = 1 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"}]},{"title":"[转] JavaScript深入之执行上下文栈 ","slug":"js-深入之执行上下文栈","date":"2018-11-14T06:18:00.000Z","updated":"2019-01-03T15:09:32.973Z","comments":true,"path":"2018/11/14/js-深入之执行上下文栈/","link":"","permalink":"https://gershonv.github.io/2018/11/14/js-深入之执行上下文栈/","excerpt":"顺序执行？如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： 1234567891011var foo = function() &#123; console.log('foo1')&#125;foo() // foo1var foo = function() &#123; console.log('foo2')&#125;foo() // foo2 然而去看这段代码： 1234567891011function foo() &#123; console.log('foo1')&#125;foo() // foo2function foo() &#123; console.log('foo2')&#125;foo() // foo2 打印的结果却是两个 foo2。刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底 JavaScript 引擎遇到一段怎样的代码时才会做“准备工作”呢？","text":"顺序执行？如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： 1234567891011var foo = function() &#123; console.log('foo1')&#125;foo() // foo1var foo = function() &#123; console.log('foo2')&#125;foo() // foo2 然而去看这段代码： 1234567891011function foo() &#123; console.log('foo1')&#125;foo() // foo2function foo() &#123; console.log('foo2')&#125;foo() // foo2 打印的结果却是两个 foo2。刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底 JavaScript 引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？其实很简单，就三种，全局代码、函数代码、eval 代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = [] 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext： 1ECStack = [globalContext] 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3()&#125;function fun1() &#123; fun2()&#125;fun1() 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript 深入之词法作用域和动态作用域》最后的问题： 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;checkscope()() 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript 深入之变量对象》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://gershonv.github.io/tags/执行上下文/"}]},{"title":"[转] JavaScript深入之词法作用域和动态作用域","slug":"js-深入之词法作用域和动态作用域","date":"2018-11-14T03:53:24.000Z","updated":"2019-01-03T15:09:02.744Z","comments":true,"path":"2018/11/14/js-深入之词法作用域和动态作用域/","link":"","permalink":"https://gershonv.github.io/2018/11/14/js-深入之词法作用域和动态作用域/","excerpt":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 123456789101112var value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; var value = 2 foo()&#125;bar() // 1","text":"作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 123456789101112var value = 1function foo() &#123; console.log(value)&#125;function bar() &#123; var value = 2 foo()&#125;bar() // 1 假设 JavaScript 采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value 如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1 假设 JavaScript 采用动态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value 如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 思考题最后，让我们看一个《JavaScript 权威指南》中的例子： 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f()&#125;checkscope() // local scope 123456789var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;checkscope()() // local scope 两段代码都会打印：local scope。因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript 权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript 深入之执行上下文栈》。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"作用域","slug":"作用域","permalink":"https://gershonv.github.io/tags/作用域/"}]},{"title":"[转] JavaScirpt深入之从原型到原型链","slug":"js-深入之从原型到原型链","date":"2018-11-14T02:50:07.000Z","updated":"2019-01-03T15:10:28.672Z","comments":true,"path":"2018/11/14/js-深入之从原型到原型链/","link":"","permalink":"https://gershonv.github.io/2018/11/14/js-深入之从原型到原型链/","excerpt":"构造函数创建对象我们先使用构造函数创建一个对象： 1234function Person() &#123;&#125;var person = new Person()person.name = 'Kevin'console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。","text":"构造函数创建对象我们先使用构造函数创建一个对象： 1234function Person() &#123;&#125;var person = new Person()person.name = 'Kevin'console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 prototype 每一个函数都有一个 prototype 属性。 123456function Person() &#123;&#125;Person.prototype.name = 'Kevin'var person1 = new Person()var person2 = new Person()console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__ 每一个实例都有一个 __proto__ 指针，指向构造函数的原型对象。 123function Person() &#123;&#125;var person = new Person()console.log(person.__proto__ === Person.prototype) // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 12function Person() &#123;&#125;console.log(Person === Person.prototype.constructor) // true 所以再更新下关系图： 综上我们已经得出： 1234567function Person() &#123;&#125;var person = new Person()console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // trueconsole.log(Object.getPrototypeOf(person) === Person.prototype) /// 顺便学习一个ES5的方法,可以获得对象的原型 true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 123456789function Person() &#123;&#125;Person.prototype.name = 'Kevin'var person = new Person()person.name = 'Daisy'console.log(person.name) // Daisydelete person.nameconsole.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person._proto_ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object()obj.name = 'Kevin'console.log(obj.name) // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ 1Object.prototype.__proto__ === null // ture 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined 与 null 的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor123function Person() &#123;&#125;var person = new Person()console.log(person.constructor === Person) // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 来源 转自 冴羽 JavaScript 深入之从原型到原型链","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"Javascript 深入系列","slug":"Javascript-深入系列","permalink":"https://gershonv.github.io/tags/Javascript-深入系列/"},{"name":"原型/原型链","slug":"原型-原型链","permalink":"https://gershonv.github.io/tags/原型-原型链/"}]},{"title":"js - 常用的设计模式","slug":"js-design mode","date":"2018-11-12T08:33:26.000Z","updated":"2019-01-03T15:11:16.912Z","comments":true,"path":"2018/11/12/js-design mode/","link":"","permalink":"https://gershonv.github.io/2018/11/12/js-design mode/","excerpt":"发布订阅模式发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。","text":"发布订阅模式发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Bus &#123; constructor() &#123; this.watchers = &#123;&#125; // 存放事件 &#125; on(event, handler) &#123; this.watchers[event] = this.watchers[event] || [] this.watchers[event].push(handler) &#125; emit(event, ...args) &#123; if (this.watchers[event]) &#123; this.watchers[event].forEach(cb =&gt; cb(...args)) &#125; &#125; off(event, handler) &#123; if (event &amp;&amp; handler) &#123; if (this.watchers[event] &amp;&amp; this.watchers[event].length) &#123; const index = this.watchers[event].findIndex(cb =&gt; Object.is(cb, handler)) // 找到需要退订的函数... this.watchers[event].splice(index, 1) &#125; &#125; else if (event) &#123; // 如果仅传入事件名称，则退订此事件对应的所有的事件函数 this.watchers[event] = [] &#125; else &#123; this.watchers = &#123;&#125; &#125; &#125;&#125;const bus = new Bus()const fn1 = (...args) =&gt; &#123; console.log('emit function one, params is: ', ...args)&#125;const fn2 = (...args) =&gt; &#123; console.log('emit function two, params is: ', ...args)&#125;bus.on('a', fn1)bus.on('a', fn2)bus.emit('a', 1) // emit function one/two, params is: 1 2bus.off('a', fn1)bus.emit('a', 2) // emit function two, params is: 2bus.off('a') // remove all the listeners 中介者模式观察者模式通过维护一堆列表来管理对象间的多对多关系，中介者模式通过统一接口来维护一对多关系，且通信者之间不需要知道彼此之间的关系，只需要约定好 API 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 汽车class Bus &#123; constructor() &#123; // 初始化所有乘客 this.passengers = &#123;&#125; &#125; // 发布广播 broadcast(passenger, message = passenger) &#123; // 如果车上有乘客 if (Object.keys(this.passengers).length) &#123; // 如果是针对某个乘客发的，就单独给他听 if (passenger.id &amp;&amp; passenger.listen) &#123; // 乘客他爱听不听 if (this.passengers[passenger.id]) &#123; this.passengers[passenger.id].listen(message) &#125; // 不然就广播给所有乘客 &#125; else &#123; Object.keys(this.passengers).forEach(passenger =&gt; &#123; if (this.passengers[passenger].listen) &#123; this.passengers[passenger].listen(message) &#125; &#125;) &#125; &#125; &#125; // 乘客上车 aboard(passenger) &#123; this.passengers[passenger.id] = passenger &#125; // 乘客下车 debus(passenger) &#123; this.passengers[passenger.id] = null delete this.passengers[passenger.id] console.log(`乘客$&#123;passenger.id&#125;下车`) &#125; // 开车 start() &#123; this.broadcast(&#123; type: 1, content: '前方无障碍，开车！Over' &#125;) &#125; // 停车 end() &#123; this.broadcast(&#123; type: 2, content: '老司机翻车，停车！Over' &#125;) &#125;&#125;// 乘客class Passenger &#123; constructor(id) &#123; this.id = id &#125; // 听广播 listen(message) &#123; console.log(`乘客$&#123;this.id&#125;收到消息`, message) // 乘客发现停车了，于是自己下车 if (Object.is(message.type, 2)) &#123; this.debus() &#125; &#125; // 下车 debus() &#123; console.log(`我是乘客$&#123;this.id&#125;，我现在要下车`, bus) bus.debus(this) &#125;&#125;// 创建一辆汽车const bus = new Bus()// 创建两个乘客const passenger1 = new Passenger(1)const passenger2 = new Passenger(2)// 俩乘客分别上车bus.aboard(passenger1)bus.aboard(passenger2)// 2秒后开车setTimeout(bus.start.bind(bus), 2000)// 3秒时司机发现2号乘客没买票，2号乘客被驱逐下车setTimeout(() =&gt; &#123; bus.broadcast(passenger2, &#123; type: 3, content: '同志你好，你没买票，请下车!' &#125;) bus.debus(passenger2)&#125;, 3000)// 4秒后到站停车setTimeout(bus.end.bind(bus), 3600)// 6秒后再开车，车上已经没乘客了setTimeout(bus.start.bind(bus), 6666) 代理模式常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载） 图片懒加载的方式：先通过一张 loading 图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。 1234567891011121314151617181920212223var myImage = (function() &#123; var imgNode = document.createElement('img') document.body.appendChild(imgNode) return function(src) &#123; imgNode.src = src &#125;&#125;)()var ProxyImage = (function() &#123; var img = new Image() img.onload = function() &#123; myImage(this.src) &#125; return function(src) &#123; // 占位图片loading myImage('http://www.baidu.com/img/baidu_jgylogo3.gif') img.src = src &#125;&#125;)()// 调用方式ProxyImage('https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png') // 真实要展示的图片 单例模式 单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 1234567891011121314151617181920212223242526class CreateUser &#123; constructor(name) &#123; this.name = name this.instance = null &#125; getName() &#123; return this.name &#125;&#125;// 代理实现单例模式var ProxyMode = (function() &#123; var instance = null return function(name) &#123; if (!instance) &#123; instance = new CreateUser(name) &#125; return instance &#125;&#125;)()const instanceA = new ProxyMode('instanceA') // &#123; name: 'instanceA', instance: null &#125;const instanceB = new ProxyMode('instanceB') // &#123; name: 'instanceA', instance: null &#125;console.log(instanceA === instanceB) // true 优点 可以用来划分命名空间，减少全局变量的数量。 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。 可以被实例化，且实例化一次。 适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gershonv.github.io/tags/设计模式/"}]},{"title":"ES6 - async await","slug":"es6-async&await","date":"2018-11-12T04:02:26.000Z","updated":"2019-01-03T15:03:06.120Z","comments":true,"path":"2018/11/12/es6-async&await/","link":"","permalink":"https://gershonv.github.io/2018/11/12/es6-async&await/","excerpt":"async 函数 async 函数是什么？一句话，它就是 Generator 函数的语法糖。async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已 12345678910111213141516171819function getSomething() &#123; return 'something'&#125;async function testAsync() &#123; return 'Hello async'&#125;async function test() &#123; const v1 = await getSomething() // 普通值 const v2 = await testAsync() // Promise对象 console.log(v1, v2)&#125;test() .then(() =&gt; &#123; console.log('调用该函数时，会立即返回一个Promise对象') &#125;) .catch(e =&gt; &#123;&#125;)","text":"async 函数 async 函数是什么？一句话，它就是 Generator 函数的语法糖。async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已 12345678910111213141516171819function getSomething() &#123; return 'something'&#125;async function testAsync() &#123; return 'Hello async'&#125;async function test() &#123; const v1 = await getSomething() // 普通值 const v2 = await testAsync() // Promise对象 console.log(v1, v2)&#125;test() .then(() =&gt; &#123; console.log('调用该函数时，会立即返回一个Promise对象') &#125;) .catch(e =&gt; &#123;&#125;) async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function*() &#123; // ... &#125;)&#125; 所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。 1234567891011121314151617181920function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF() let next function step(nextF) &#123; let next try &#123; next = nextF() &#125; catch (err) &#123; return reject(err) &#125; if (next.done) return resolve(next.value) Promise.resolve(next.value).then( v =&gt; step(() =&gt; gen.next(v)), e =&gt; gen.throw(e) ) &#125; step(() =&gt; gen.next(undefined)) &#125;)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://gershonv.github.io/tags/ES6/"}]},{"title":"ES6 - generator","slug":"es6-generator","date":"2018-11-12T03:24:35.000Z","updated":"2019-01-03T14:17:53.342Z","comments":true,"path":"2018/11/12/es6-generator/","link":"","permalink":"https://gershonv.github.io/2018/11/12/es6-generator/","excerpt":"","text":"基本概念 Generator 函数是 ES6 提供的一种异步编程解决方案。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态。 1234567891011121314151617181920212223242526// 该函数有三个状态：hello，world 和 return 语句（结束执行）function* helloWorldGenerator() &#123; yield 'hello' yield 'world' return 'ending'&#125;var hw = helloWorldGenerator()// 只有调用 next() 函数才会执行hw.next() // &#123; value: 'hello', done: false &#125;hw.next() // &#123; value: 'world', done: false &#125;hw.next() // &#123; value: 'ending', done: true &#125;hw.next() // &#123; value: undefined, done: true &#125;hw // &#123;&#125;// yield表达式如果用在另一个表达式之中，必须放在圆括号里面function* demo() &#123; console.log('Hello' + yield) // SyntaxError console.log('Hello' + yield 123) // SyntaxError console.log('Hello' + (yield)) // OK console.log('Hello' + (yield 123)) // OK&#125; Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 总结一下： 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。 以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值 done 属性是一个布尔值，表示是否遍历结束。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://gershonv.github.io/tags/ES6/"}]},{"title":"react-context 实现 todoList","slug":"react-context-todoList","date":"2018-11-09T15:56:25.000Z","updated":"2019-01-03T15:08:17.812Z","comments":true,"path":"2018/11/09/react-context-todoList/","link":"","permalink":"https://gershonv.github.io/2018/11/09/react-context-todoList/","excerpt":"src/context/TodoContext.js 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from 'react'export const TodoContext = React.createContext()export class TodoProvider extends Component &#123; state = &#123; todoList: [] &#125; addTodo = text =&gt; &#123; const todoList = [...this.state.todoList, &#123; id: Math.random(), text &#125;] this.setState(&#123; todoList &#125;) &#125; deleteTodo = id =&gt; &#123; const todoList = this.state.todoList.filter(todo =&gt; todo.id !== id) this.setState(&#123; todoList &#125;) &#125; clearTodos = () =&gt; &#123; this.setState(&#123; todoList: [] &#125;) &#125; render() &#123; return ( &lt;TodoContext.Provider value=&#123;&#123; todoList: this.state.todoList, addTodo: this.addTodo, deleteTodo: this.deleteTodo, clearTodos: this.clearTodos &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/TodoContext.Provider&gt; ) &#125;&#125;","text":"src/context/TodoContext.js 12345678910111213141516171819202122232425262728293031323334353637import React, &#123; Component &#125; from 'react'export const TodoContext = React.createContext()export class TodoProvider extends Component &#123; state = &#123; todoList: [] &#125; addTodo = text =&gt; &#123; const todoList = [...this.state.todoList, &#123; id: Math.random(), text &#125;] this.setState(&#123; todoList &#125;) &#125; deleteTodo = id =&gt; &#123; const todoList = this.state.todoList.filter(todo =&gt; todo.id !== id) this.setState(&#123; todoList &#125;) &#125; clearTodos = () =&gt; &#123; this.setState(&#123; todoList: [] &#125;) &#125; render() &#123; return ( &lt;TodoContext.Provider value=&#123;&#123; todoList: this.state.todoList, addTodo: this.addTodo, deleteTodo: this.deleteTodo, clearTodos: this.clearTodos &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/TodoContext.Provider&gt; ) &#125;&#125; App.jsx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component &#125; from 'react'import &#123; TodoContext, TodoProvider &#125; from './context/TodoContext'class App extends Component &#123; state = &#123; text: '' &#125; render() &#123; const &#123; todoList, addTodo, deleteTodo, clearTodos &#125; = this.props const &#123; text &#125; = this.state return ( &lt;div&gt; &lt;h2&gt;TodoList&lt;/h2&gt; &lt;div&gt; &lt;input type=\"text\" placeholder=\"请输入内容\" onChange=&#123;e =&gt; this.setState(&#123; text: e.target.value &#125;)&#125; /&gt; &lt;button onClick=&#123;e =&gt; addTodo(text)&#125;&gt;AddTodo&lt;/button&gt; &lt;button onClick=&#123;clearTodos&#125;&gt;clearTodos&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123;todoList.map(todo =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;e =&gt; deleteTodo(todo.id)&#125;&gt;delete&lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;const Hoc = WrappedComponent =&gt; class extends Component &#123; render() &#123; return ( &lt;TodoProvider&gt; &lt;TodoContext.Consumer&gt; &#123;ctx =&gt; &lt;WrappedComponent &#123;...ctx&#125; /&gt;&#125; &lt;/TodoContext.Consumer&gt; &lt;/TodoProvider&gt; ) &#125; &#125;export default Hoc(App)","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react-context","slug":"react-context","date":"2018-11-09T01:58:42.000Z","updated":"2019-01-03T15:08:12.553Z","comments":true,"path":"2018/11/09/react-context/","link":"","permalink":"https://gershonv.github.io/2018/11/09/react-context/","excerpt":"简单使用Context 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 redux，因为 redux 也是通过这个东东实现的。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'/** * 1. 创建 context * 2. 根组件 App 包裹 MyContext.Provider * 3. App =&gt; Father =&gt; Child =&gt; MyContext.Consumer =&gt; context.age 取出结果 */const MyContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt;&#123;(&#123; age &#125;) =&gt; &lt;p&gt;My age is &#123;age&#125;&lt;/p&gt;&#125;&lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: 22 &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App","text":"简单使用Context 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 redux，因为 redux 也是通过这个东东实现的。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'/** * 1. 创建 context * 2. 根组件 App 包裹 MyContext.Provider * 3. App =&gt; Father =&gt; Child =&gt; MyContext.Consumer =&gt; context.age 取出结果 */const MyContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt;&#123;(&#123; age &#125;) =&gt; &lt;p&gt;My age is &#123;age&#125;&lt;/p&gt;&#125;&lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: 22 &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 理论知识React.createContext1const &#123; Provider, Consumer &#125; = React.createContext(defaultValue) 创建一对 { Provider, Consumer }。当 React 渲染 context 组件 Consumer 时，它将从组件树的上层中最接近的匹配的 Provider 读取当前的 context 值。 Provider1&lt;Provider value=&#123;/* some value */&#125;&gt; React 组件允许 Consumers 订阅 context 的改变。接收一个 value 属性传递给 Provider 的后代 Consumers。一个 Provider 可以联系到多个 Consumers。Providers 可以被嵌套以覆盖组件树内更深层次的值。 Consumer123&lt;Consumer&gt; &#123;value =&gt; /* render something based on the context value */&#125;&lt;/Consumer&gt; 一个可以订阅 context 变化的 React 组件。 注意，MyContext.Consumer 使用的是 render props 这种模式，render props 模式指的是让 prop 可以是一个 render 函数 父子耦合经常需要从组件树中某个深度嵌套的组件中更新 context。在这种情况下，可以通过 context 向下传递一个函数，以允许 Consumer 更新 context ： 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react'const MyContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt; &#123;ctx =&gt; ( &lt;div&gt; &lt;p&gt;My age is &#123;ctx.age&#125;&lt;/p&gt; &lt;button onClick=&#123;ctx.changeAge&#125;&gt;changeAge&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; state = &#123; age: 22 &#125; changeAge = () =&gt; &#123; this.setState(prevState =&gt; (&#123; age: ++prevState.age &#125;)) &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: this.state.age, changeAge: this.changeAge &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 作用于多个上下文为了保持 context 快速进行二次渲染， React 需要使每一个 Consumer 在组件树中成为一个单独的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; Component &#125; from 'react'const MyContext = React.createContext()const UserContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt; &#123;ctx =&gt; ( &lt;UserContext.Consumer&gt; &#123;user =&gt; ( &lt;div&gt; &lt;p&gt;My name is &#123;user.name&#125;&lt;/p&gt; &lt;p&gt;My age is &#123;ctx.age&#125;&lt;/p&gt; &lt;button onClick=&#123;ctx.changeAge&#125;&gt;changeAge&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/UserContext.Consumer&gt; )&#125; &lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; state = &#123; age: 22, name: '郭大大' &#125; changeAge = () =&gt; &#123; this.setState(prevState =&gt; (&#123; age: ++prevState.age &#125;)) &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: this.state.age, changeAge: this.changeAge &#125;&#125;&gt; &lt;UserContext.Provider value=&#123;&#123; name: this.state.name &#125;&#125;&gt; &lt;Father /&gt; &lt;/UserContext.Provider&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 如果两个或者多个上下文的值经常被一起使用，也许你需要考虑你自己渲染属性的组件提供给它们。 在生命周期方法中访问 Context在生命周期方法中从上下文访问值是一种相对常见的用例。而不是将上下文添加到每个生命周期方法中，只需要将它作为一个 props 传递，然后像通常使用 props 一样去使用它。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, &#123; Component &#125; from 'react'const MyContext = React.createContext()class Child extends Component &#123; componentDidMount() &#123; console.log(this.props.ctx) &#125; render() &#123; const &#123; age, changeAge &#125; = this.props.ctx return ( &lt;div&gt; &lt;p&gt;My age is &#123;age&#125;&lt;/p&gt; &lt;button onClick=&#123;changeAge&#125;&gt;changeAge&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const Father = props =&gt; ( &lt;MyContext.Consumer&gt; &#123;ctx =&gt; &lt;Child &#123;...props&#125; ctx=&#123;ctx&#125; /&gt;&#125; &lt;/MyContext.Consumer&gt;)class App extends Component &#123; state = &#123; age: 22 &#125; changeAge = () =&gt; &#123; this.setState(prevState =&gt; (&#123; age: ++prevState.age &#125;)) &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: this.state.age, changeAge: this.changeAge &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 转发 Refs一个关于渲染属性API的问题是 refs 不会自动的传递给被封装的元素。为了解决这个问题，使用 React.forwardRef： fancy-button.js 1234567891011121314151617class FancyButton extends React.Component &#123; focus() &#123; // ... &#125; // ...&#125;// 使用 context 传递当前的 \"theme\" 给 FancyButton.// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.export default React.forwardRef((props, ref) =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt;)) app.js 12345678910import FancyButton from './fancy-button'const ref = React.createRef()// ref属性将指向 FancyButton 组件,// ThemeContext.Consumer 没有包裹它// 这意味着我们可以调用 FancyButton 的方法就像这样 ref.current.focus()&lt;FancyButton ref=&#123;ref&#125; onClick=&#123;handleClick&#125;&gt; Click me!&lt;/FancyButton&gt; 尽量减少使用 context因为 context 使用 reference identity 确定何时重新渲染，在 Consumer 中，当一个 Provider 的父节点重新渲染的时候，有一些问题可能触发意外的渲染。例如下面的代码，所有的 Consumner 在 Provider 重新渲染之时，每次都将重新渲染，因为一个新的对象总是被创建对应 Provider 里的 value 123456789class App extends React.Component &#123; render() &#123; return ( &lt;Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 为了防止这样, 提升 value 到父节点的 state 里: 123456789101112131415class App extends React.Component &#123; constructor(props) &#123; this.state = &#123; value: &#123;something: 'something'&#125;, &#125;; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 注意点React context的局限性： 在组件树中，如果中间某一个组件 ShouldComponentUpdate returning false 了，会阻碍 context 的正常传值，导致子组件无法获取更新。 组件本身 extends React.PureComponent 也会阻碍 context 的更新。 Context 应该是唯一不可变的 组件只在初始化的时候去获取 Context","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react-router - 动态路由","slug":"react-router-6","date":"2018-11-08T07:59:59.000Z","updated":"2019-01-03T15:08:01.266Z","comments":true,"path":"2018/11/08/react-router-6/","link":"","permalink":"https://gershonv.github.io/2018/11/08/react-router-6/","excerpt":"动态组件webpack 的 import 方法webpack 将 import()看做一个分割点并将其请求的 module 打包为一个独立的 chunk。import()以模块名称作为参数名并且返回一个 Promise 对象。 采用适配器模式封装 import() 适配器模式（Adapter）:将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 当前场景，需要解决的是，使用 import()异步加载组件后，如何将加载的组件交给 React 进行更新。方法也很容易，就是利用 state。当异步加载好组件后，调用 setState 方法，就可以通知到。那么，依照这个思路，新建个高阶组件，运用适配器模式，来对 import()进行封装。 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom'function asyncComponent(importComponent) &#123; class AsyncComponent extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; component: null &#125; &#125; async componentDidMount() &#123; const &#123; default: component &#125; = await importComponent() this.setState(&#123; component: component &#125;) &#125; render() &#123; const RenderComponet = this.state.component return RenderComponet ? &lt;RenderComponet &#123;...this.props&#125; /&gt; : &lt;div&gt;loading...&lt;/div&gt; &#125; &#125; return AsyncComponent&#125;const NoFound = asyncComponent(() =&gt; import('./components/NoFound'))class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route component=&#123;NoFound&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ) &#125;&#125;export default App","text":"动态组件webpack 的 import 方法webpack 将 import()看做一个分割点并将其请求的 module 打包为一个独立的 chunk。import()以模块名称作为参数名并且返回一个 Promise 对象。 采用适配器模式封装 import() 适配器模式（Adapter）:将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 当前场景，需要解决的是，使用 import()异步加载组件后，如何将加载的组件交给 React 进行更新。方法也很容易，就是利用 state。当异步加载好组件后，调用 setState 方法，就可以通知到。那么，依照这个思路，新建个高阶组件，运用适配器模式，来对 import()进行封装。 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom'function asyncComponent(importComponent) &#123; class AsyncComponent extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; component: null &#125; &#125; async componentDidMount() &#123; const &#123; default: component &#125; = await importComponent() this.setState(&#123; component: component &#125;) &#125; render() &#123; const RenderComponet = this.state.component return RenderComponet ? &lt;RenderComponet &#123;...this.props&#125; /&gt; : &lt;div&gt;loading...&lt;/div&gt; &#125; &#125; return AsyncComponent&#125;const NoFound = asyncComponent(() =&gt; import('./components/NoFound'))class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route component=&#123;NoFound&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ) &#125;&#125;export default App 基于 react-loadable 实现代码分割react-router v4 发生了巨大改变，由静态路由开始转向动态路由，从此，就像使用普通组件一样来声明路由。其实，路由从此就是一个普通组件。 路由的按需加载的实质是代码分割,react-router 官网有个代码拆分的示例，是基于 bundle-loader 实现的.现在官网的代码已经改为基于react-loadable 实现。 按照上述方法，已经实现了代码分割。然而，react-loadable 为我们提供了更好的解决方案。react-loadable 核心实现原理也是通过 dynamic import 来实现组件的异步加载。在此基础上，它提供了更为强大的功能，如根据延迟时间确定是否显示 loading 组件、预加载、支持服务端渲染等。 在另一篇译文- [译] react-router Code Splitting中，我也写过了 react-loadable 的用法介绍，详情可以查看这篇文章。 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom'import Loadable from 'react-loadable'const NoFound = Loadable(&#123; loader: () =&gt; import('./components/NoFound'), loading: &lt;div&gt;loading&lt;/div&gt;&#125;)class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route component=&#123;NoFound&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ) &#125;&#125;export default App 参考 React router 动态加载组件-适配器模式的应用 react 扬帆起航之路由配置与组件分割","categories":[{"name":"React-Router","slug":"React-Router","permalink":"https://gershonv.github.io/categories/React-Router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://gershonv.github.io/tags/react-router/"}]},{"title":"react-router - 实践系列","slug":"react-router-5","date":"2018-11-07T02:37:49.000Z","updated":"2019-01-03T15:07:52.257Z","comments":true,"path":"2018/11/07/react-router-5/","link":"","permalink":"https://gershonv.github.io/2018/11/07/react-router-5/","excerpt":"简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Switch, Route, Link, NavLink &#125; from 'react-router-dom'const Home = () =&gt; ( &lt;div&gt; &lt;h2&gt;主页&lt;/h2&gt; &lt;Link to=\"/article/1\"&gt;文章1&lt;/Link&gt; &lt;/div&gt;)const Mine = () =&gt; &lt;h2&gt;我的&lt;/h2&gt;class Article extends Component &#123; handleClick = () =&gt; &#123; // 坑点： this.props.history.push('home') 会跳转到路径 /article/home this.props.history.push('/home') &#125; render() &#123; const &#123; match &#125; = this.props return ( &lt;div&gt; &lt;h2&gt;文章&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;路由传参： &#123;match.params.topicId&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;go Home&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;/** * 坑点1： You should not use &lt;Link&gt; outside a &lt;Router&gt; @desc Link 组件不要在 Router 组件外使用 * 坑点2： A &lt;Router&gt; may have only one child element @desc Router 组件只能有一个子元素 * 坑点3： /article/:topicId 匹配不到 /Article 组件， /article/123 可以 */class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Router&gt; &lt;div&gt; &lt;NavLink to=\"/\" activeClassName=\"active\"&gt; 首页 &lt;/NavLink&gt; &lt;NavLink to=\"/article\" activeClassName=\"active\"&gt; 文章 &lt;/NavLink&gt; &lt;NavLink to=\"/mine\" activeClassName=\"active\"&gt; 我的 &lt;/NavLink&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/article/:topicId\" component=&#123;Article&#125; /&gt; &lt;Route path=\"/mine\" component=&#123;Mine&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; &lt;/div&gt; ) &#125;&#125;export default App url 跳转 + 传参","text":"简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Switch, Route, Link, NavLink &#125; from 'react-router-dom'const Home = () =&gt; ( &lt;div&gt; &lt;h2&gt;主页&lt;/h2&gt; &lt;Link to=\"/article/1\"&gt;文章1&lt;/Link&gt; &lt;/div&gt;)const Mine = () =&gt; &lt;h2&gt;我的&lt;/h2&gt;class Article extends Component &#123; handleClick = () =&gt; &#123; // 坑点： this.props.history.push('home') 会跳转到路径 /article/home this.props.history.push('/home') &#125; render() &#123; const &#123; match &#125; = this.props return ( &lt;div&gt; &lt;h2&gt;文章&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;路由传参： &#123;match.params.topicId&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;go Home&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;/** * 坑点1： You should not use &lt;Link&gt; outside a &lt;Router&gt; @desc Link 组件不要在 Router 组件外使用 * 坑点2： A &lt;Router&gt; may have only one child element @desc Router 组件只能有一个子元素 * 坑点3： /article/:topicId 匹配不到 /Article 组件， /article/123 可以 */class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Router&gt; &lt;div&gt; &lt;NavLink to=\"/\" activeClassName=\"active\"&gt; 首页 &lt;/NavLink&gt; &lt;NavLink to=\"/article\" activeClassName=\"active\"&gt; 文章 &lt;/NavLink&gt; &lt;NavLink to=\"/mine\" activeClassName=\"active\"&gt; 我的 &lt;/NavLink&gt; &lt;hr /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/article/:topicId\" component=&#123;Article&#125; /&gt; &lt;Route path=\"/mine\" component=&#123;Mine&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt; &lt;/div&gt; ) &#125;&#125;export default App url 跳转 + 传参 路由跳转12345678910&lt;Route path=\"/article/:topicId\" component=&#123;Article&#125; /&gt;// html&lt;Link to=\"/article/1\"&gt;文章1&lt;/Link&gt;// js 方式this.props.history.push('/article/1')// Article 组件 接收参数this.props.match.params.topicId 通过 query前提：必须由其他页面跳过来，参数才会被传递过来 1234567891011// 不需要配置路由表。路由表中的内容照常&lt;Route path=\"/article\" component=&#123;Article&#125; /&gt;// html&lt;Link to=&#123;&#123; pathname: '/article', query: &#123; topicId: 2 &#125; &#125;&#125;&gt;文章2&lt;/Link&gt;// js 方式this.props.history.push(&#123; pathname : '/article' ,query : &#123; topicId: 2&#125; &#125;)// Article 组件 接收参数this.props.location.query.topicId //建议不用 刷新页面时 丢失 通过 state同 query 差不多，只是属性不一样，而且 state 传的参数是加密的，query 传的参数是公开的，在地址栏 1234567891011// 不需要配置路由表。路由表中的内容照常&lt;Route path=\"/article\" component=&#123;Article&#125; /&gt;// html&lt;Link to=&#123;&#123; pathname: '/article', state: &#123; topicId: 2 &#125; &#125;&#125;&gt;文章2&lt;/Link&gt;// js 方式this.props.history.push(&#123; pathname: '/article', state: &#123; topicId: 2 &#125; &#125;)// Article 组件 接收参数this.props.location.state.topicId 重定向1234567891011121314// 通过from匹配路由重定向&lt;Switch&gt; &lt;Redirect from=\"/users/:id\" to=\"/users/profile/:id\" /&gt; &lt;Route path=\"/users/profile/:id\" component=&#123;Profile&#125; /&gt;&lt;/Switch&gt;// 通过render重定向&lt;Route exact path=\"/\" render=&#123;() =&gt; ( loggedIn ? ( &lt;Redirect to=\"/dashboard\"/&gt; ) : ( &lt;PublicHomePage/&gt; ))&#125;/&gt; Redirect(Auth)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Link, Redirect, withRouter&#125; from 'react-router-dom'const fakeAuth = &#123; isAuthenticated: false, authenticate(cb) &#123; this.isAuthenticated = true setTimeout(cb, 100) // fake async &#125;, signout(cb) &#123; this.isAuthenticated = false setTimeout(cb, 100) &#125;&#125;/** * @class Login - 登录组件 * 接受参数 this.props.location.state.from * 如果登录成功 redirectToReferrer = true, 则跳转回之前的页面 &lt;Redirect to=&#123;from&#125; /&gt; */class Login extends Component &#123; state = &#123; redirectToReferrer: false &#125; login = () =&gt; &#123; fakeAuth.authenticate(() =&gt; &#123; this.setState(&#123; redirectToReferrer: true &#125;) &#125;) &#125; render() &#123; let &#123; from &#125; = this.props.location.state || &#123; from: &#123; pathname: '/' &#125; &#125; let &#123; redirectToReferrer &#125; = this.state if (redirectToReferrer) return &lt;Redirect to=&#123;from&#125; /&gt; return ( &lt;div&gt; &lt;p&gt;You must log in to view the page at &#123;from.pathname&#125;&lt;/p&gt; &lt;button onClick=&#123;this.login&#125;&gt;Log in&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;/** * @class AuthRoute - 权限高阶路由组件 * 通过 fakeAuth.isAuthenticated 控制是否重定向到 /login * 传递参数 &#123; from: props.location &#125; */const AuthRoute = (&#123; component: Component, ...rest &#125;) =&gt; ( &lt;Route &#123;...rest&#125; render=&#123;props =&gt; fakeAuth.isAuthenticated ? ( &lt;Component &#123;...props&#125; /&gt; ) : ( &lt;Redirect to=&#123;&#123; pathname: '/login', state: &#123; from: props.location &#125; &#125;&#125; /&gt; ) &#125; /&gt;)/** * @func AuthStatus - 显示登录状态的组件 * @desc 通过 withRouter 包裹，获得 this.props.history 用于跳转 * 登录成功，显示 login succeeds，并显示注销按钮 * 未登录，显示 You are not logged in. */const AuthStatus = withRouter( (&#123; history &#125;) =&gt; fakeAuth.isAuthenticated ? ( &lt;p&gt; login succeeds &lt;button onClick=&#123;() =&gt; &#123; fakeAuth.signout(() =&gt; history.push('/')) &#125;&#125;&gt; Sign out &lt;/button&gt; &lt;/p&gt; ) : ( &lt;p&gt;You are not logged in.&lt;/p&gt; ))class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Link to=\"/auth\"&gt;Auth Page&lt;/Link&gt; &lt;AuthStatus /&gt; &lt;Route path=\"/login\" component=&#123;Login&#125; /&gt; &lt;AuthRoute path=\"/auth\" component=&#123;() =&gt; &lt;h2&gt;Auth page&lt;/h2&gt;&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;export default App NotFound12345678910111213141516import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom'class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;() =&gt; &lt;h2&gt;Home&lt;/h2&gt;&#125; /&gt; &lt;Route component=&#123;() =&gt; &lt;h2&gt;404, not found&lt;/h2&gt;&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ) &#125;&#125;export default App 何时使用 Switch123456789101112131415161718import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route &#125; from 'react-router-dom'// 输入地址 /article 可以发现 两个组件同时都被命中，这是我们不希望出现的// 这个时候可以使用Switch，他只会命中第一个命中的路由class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;Route path=\"/article\" component=&#123;() =&gt; &lt;p&gt;article&lt;/p&gt;&#125; /&gt; &lt;Route path=\"/:name\" component=&#123;() =&gt; &lt;p&gt;:name&lt;/p&gt;&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;export default App 实现 sidebar12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'// 路由表const routes = [ &#123; path: '/', exact: true, component: () =&gt; &lt;h1&gt;Home&lt;/h1&gt; &#125;, &#123; path: '/bubblegum', component: () =&gt; &lt;h1&gt;bubblegum&lt;/h1&gt; &#125;, &#123; path: '/shoelaces', component: () =&gt; &lt;h1&gt;shoelaces&lt;/h1&gt; &#125;]class App extends Component &#123; render() &#123; const sideBarStyle = &#123; padding: '10px', width: '40%', background: '#f0f0f0' &#125; return ( &lt;Router&gt; &lt;div style=&#123;&#123; display: 'flex' &#125;&#125;&gt; &lt;div style=&#123;sideBarStyle&#125;&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/bubblegum\"&gt;Bubblegum&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/shoelaces\"&gt;Shoelaces&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div style=&#123;&#123; flex: 1, padding: '10px' &#125;&#125;&gt; &#123;routes.map((route, index) =&gt; ( &lt;Route key=&#123;index&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;export default App route config - 定义路由表，实现子路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'// 路由表const routes = [ &#123; path: '/sandwiches', component: () =&gt; &lt;h2&gt;Sandwiches&lt;/h2&gt; &#125;, &#123; path: '/tacos', component: Tacos, routes: [ &#123; path: '/tacos/bus', component: () =&gt; &lt;h3&gt;sub Bus&lt;/h3&gt; &#125;, &#123; path: '/tacos/cart', component: () =&gt; &lt;h3&gt;sub cart&lt;/h3&gt; &#125; ] &#125;]function Tacos(&#123; routes &#125;) &#123; return ( &lt;div&gt; &lt;h2&gt;Tacos&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/tacos/bus\"&gt;Bus&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/tacos/cart\"&gt;Cart&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt; )&#125;const RouteWithSubRoutes = route =&gt; ( &lt;Route path=&#123;route.path&#125; render=&#123;props =&gt; &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;&#125; /&gt;)class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/tacos\"&gt;Tacos&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/sandwiches\"&gt;Sandwiches&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &#123;routes.map((route, i) =&gt; ( &lt;RouteWithSubRoutes key=&#123;i&#125; &#123;...route&#125; /&gt; ))&#125; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;export default App render","categories":[{"name":"React-Router","slug":"React-Router","permalink":"https://gershonv.github.io/categories/React-Router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://gershonv.github.io/tags/react-router/"}]},{"title":"react-router - 常用知识","slug":"react-router-4","date":"2018-11-07T02:37:43.000Z","updated":"2019-01-03T15:07:39.731Z","comments":true,"path":"2018/11/07/react-router-4/","link":"","permalink":"https://gershonv.github.io/2018/11/07/react-router-4/","excerpt":"组件-Router1234567891011121314// 用于导航的历史对象&lt;Router history=&#123;history&#125;&gt;&lt;/Router&gt;// 一个使用了 HTML5 history API 的高阶路由组件，保证你的 UI 界面和 URL 保持同步&lt;BrowserRouter basename=\"/calendar\" // 添加一个基准URL forceRefresh=&#123;false&#125; // 当浏览器不支持 HTML5 的 history API 时强制刷新页面 getUserConfirmation=&#123;getConfirmation()&#125; // 导航到此页面前执行的函数 keyLength=&#123;12&#125; // 设置它里面路由的 location.key 的长度。默认是6&gt;&lt;/BrowserRouter&gt;&lt;HashRouter&gt;&lt;/HashRouter&gt;// Hash history 不支持 location.key 和 location.state。// 另外由于该技术只是用来支持旧版浏览器，因此更推荐大家使用 BrowserRouter","text":"组件-Router1234567891011121314// 用于导航的历史对象&lt;Router history=&#123;history&#125;&gt;&lt;/Router&gt;// 一个使用了 HTML5 history API 的高阶路由组件，保证你的 UI 界面和 URL 保持同步&lt;BrowserRouter basename=\"/calendar\" // 添加一个基准URL forceRefresh=&#123;false&#125; // 当浏览器不支持 HTML5 的 history API 时强制刷新页面 getUserConfirmation=&#123;getConfirmation()&#125; // 导航到此页面前执行的函数 keyLength=&#123;12&#125; // 设置它里面路由的 location.key 的长度。默认是6&gt;&lt;/BrowserRouter&gt;&lt;HashRouter&gt;&lt;/HashRouter&gt;// Hash history 不支持 location.key 和 location.state。// 另外由于该技术只是用来支持旧版浏览器，因此更推荐大家使用 BrowserRouter forceRefresh: bool如果为 true，路由器将在页面导航时使用完整页面刷新。您可能只想在不支持 HTML5 历史记录 API 的浏览器中使用它。 12const supportsHistory = 'pushState' in window.history&lt;BrowserRouter forceRefresh=&#123;!supportsHistory&#125;/&gt; getUserConfirmation: func用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理。译注：需要配合 &lt;Prompt&gt; 一起使用。 1234567// this is the default behaviorconst getConfirmation = (message, callback) =&gt; &#123; const allowTransition = window.confirm(message) callback(allowTransition)&#125;&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125;/&gt; keyLength: numberThe length of location.key. Defaults to 6. 组件-Switch如果你访问 /about，那么组件 About User Nomatch 都将被渲染出来，因为他们对应的路由与访问的地址 /about 匹配 1234// render all&lt;Route path=\"/about\" component=&#123;About&#125;/&gt;&lt;Route path=\"/:user\" component=&#123;User&#125;/&gt;&lt;Route component=&#123;NoMatch&#125;/&gt; &lt;Switch&gt;只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt; 1234567// Renders the first child &lt;Route&gt; or &lt;Redirect&gt; that matches the location.&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/:user\" component=&#123;User&#125; /&gt; &lt;Route component=&#123;NoMatch&#125; /&gt;&lt;/Switch&gt; 组件-Route1234567891011&lt;Route path=\"/\" // url路径 exact // bool 严格匹配 ’/link’与’/’是不匹配的，但是在false的情况下它们是匹配的 component=&#123;IndexPage&#125; // 渲染的组件/&gt;&lt;Route path=\"/\" // url路径 exact // bool 严格匹配 ’/link’与’/’是不匹配的，但是在false的情况下它们是匹配的 render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125; // 内联渲染/&gt; 渲染一些内容有以下三种方式：component / render / children Route 渲染方式component指定只有当位置匹配时才会渲染的 React 组件，该组件会接收 route props 作为属性。 12345const User = (&#123; match &#125;) =&gt; &#123; return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125;&lt;Route path=\"/user/:username\" component=&#123;User&#125; /&gt; 当你使用 component（而不是 render 或 children）时，Router 将根据指定的组件，使用 React.createElement 创建一个新的 React 元素。这意味着，如果你向 component 提供一个内联函数，那么每次渲染都会创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不是仅仅更新现有组件。当使用内联函数进行内联渲染时，请使用 render 或 children（见下文）。 render: func使用 render 可以方便地进行内联渲染和包装，而无需进行上文解释的不必要的组件重装。 你可以传入一个函数，以在位置匹配时调用，而不是使用 component 创建一个新的 React 元素。render 渲染方式接收所有与 component 方式相同的 route props。 12345678910111213// 方便的内联渲染&lt;Route path=\"/home\" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125; /&gt;// 包装const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; ( &lt;Route &#123;...rest&#125; render=&#123;props =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/FadeIn&gt; )&#125; /&gt;)&lt;FadingRoute path=\"/cool\" component=&#123;Something&#125; /&gt; 警告： 优先于 ，因此不要在同一个 中同时使用两者。 children: func有时候不论 path 是否匹配位置，你都想渲染一些内容。在这种情况下，你可以使用 children 属性。除了不论是否匹配它都会被调用以外，它的工作原理与 render 完全一样。 children 渲染方式接收所有与 component 和 render 方式相同的 route props，除非路由与 URL 不匹配，不匹配时 match 为 null。这允许你可以根据路由是否匹配动态地调整用户界面。如下所示，如果路由匹配，我们将添加一个激活类： 123456789101112const ListItemLink = (&#123; to, ...rest &#125;) =&gt; ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? 'active' : ''&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125; /&gt; &lt;/li&gt; )&#125; /&gt;)&lt;ul&gt; &lt;ListItemLink to=\"/somewhere\" /&gt; &lt;ListItemLink to=\"/somewhere-else\" /&gt;&lt;/ul&gt; 这对动画也很有用： 123456&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &#123;/* Animate 将始终渲染，因此你可以利用生命周期来为其子元素添加进出动画 */&#125; &lt;Animate&gt; &#123;match &amp;&amp; &lt;Something &#123;...rest&#125; /&gt;&#125; &lt;/Animate&gt;)&#125; /&gt; 警告：&lt;Route component&gt; 和&lt;Route render&gt; 优先于 &lt;Route children&gt;，因此不要在同一个 &lt;Route&gt; 中同时使用多个。 Route props三种渲染方式都将提供相同的三个路由属性： match location history match: object123456const Topics = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/rendering`&#125;&gt;Rendering with React&lt;/Link&gt; &lt;Route path=&#123;`$&#123;match.url&#125;/:topicId`&#125; component=&#123;Topic&#125; /&gt; &lt;/div&gt;) match 对象包含了 &lt;Route path&gt; 如何与 URL 匹配的信息，具有以下属性： params: object 路径参数，通过解析 URL 中的动态部分获得键值对 isExact: bool 为 true 时，整个 URL 都需要匹配 path: string 用来匹配的路径模式，用于创建嵌套的 url: string URL 匹配的部分，用于嵌套的 在以下情境中可以获取 match 对象 在 Route component 中，以 this.props.match 获取 在 Route render 中，以 ({match}) =&gt; () 方式获取 在 Route children 中，以 ({match}) =&gt; () 方式获取 uter 中，以 this.props.match 的方式获取 matchPath 的返回值 location: objectlocation 是指你当前的位置，将要去的位置，或是之前所在的位置 123456789&#123; key: 'ac3df4', // not with HashHistory! pathname: '/somewhere' search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 在以下情境中可以获取 location 对象 在Route component 中，以 this.props.location 获取 在 Route render 中，以 ({location}) =&gt; () 方式获取 在 Route children 中，以 ({location}) =&gt; () 方式获取 在 withRouter 中，以 this.props.location 的方式获取 可以在不同情境中使用 location： 12345&lt;Link to=&#123;location&#125; /&gt;&lt;NaviveLink to=&#123;location&#125; /&gt;&lt;Redirect to=&#123;location /&gt;history.push(location)history.replace(location) history: objecthistory 对象通常具有以下属性和方法： length: number 浏览历史堆栈中的条目数 action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP location: object 当前访问地址信息组成的对象 push(path, [state]) 在历史堆栈信息里加入一个新条目。 replace(path, [state]) 在历史堆栈信息里替换掉当前的条目 go(n) 将 history 堆栈中的指针向前移动 n。 goBack() 等同于 go(-1) goForward 等同于 go(1) block(prompt) 阻止跳转 属性path: string可以是 path-to-regexp 能够理解的任何有效的 URL 路径。 1&lt;Route path=\"/users/:id\" component=&#123;User&#125; /&gt; 没有定义 path 的 &lt;Route&gt; 总是会被匹配。【常用于搭建 404 页面】 exact: bool如果为 true，则只有在 path 完全匹配 location.pathname 时才匹配。 123&lt;Route exact path=\"/one\" component=&#123;OneComponent&#125; /&gt;// url: /one/two 不可以匹配到 OneComponent// 若是没加 exact， 则路径为 /one/two 或 /one/two... 都可以匹配到该组件 strict: bool如果为 true，则具有尾部斜杠的 path 仅与具有尾部斜杠的 location.pathname 匹配。当 location.pathname 中有附加的 URL 片段时，strict 就没有效果了。 123&lt;Route strict path=\"/one/\" component=&#123;OneComponent&#125; /&gt;// url /one 不匹配// url /one/ 或 /one/two 匹配 警告：可以使用 strict 来强制规定location.pathname 不能具有尾部斜杠，但是为了做到这一点，strict 和 exact 必须都是 true。 sensitive: bool如果为 true，进行匹配时将区分大小写。 组件-Redirect使用 &lt;Redirect&gt; 会导航到一个新的位置。新的位置将覆盖历史堆栈中的当前条目，例如服务器端重定向（HTTP 3xx）。 1234567import &#123; Route, Redirect &#125; from 'react-router-dom'&lt;Route exact path=\"/\" render=&#123;() =&gt; (loggedIn ? &lt;Redirect to=\"/dashboard\" /&gt; : &lt;PublicHomePage /&gt;)&#125;/&gt; to: string要重定向到的 URL，可以是 path-to-regexp 能够理解的任何有效的 URL 路径。所有要使用的 URL 参数必须由 from 提供。 1&lt;Redirect to=\"/somewhere/else\" /&gt; to: object要重定向到的位置，其中 pathname 可以是 path-to-regexp 能够理解的任何有效的 URL 路径。 123456789&lt;Redirect to=&#123;&#123; pathname: '/login', search: '?utm=your+face', state: &#123; referrer: currentLocation &#125; &#125;&#125;/&gt; 上例中的 state 对象可以在重定向到的组件中通过 this.props.location.state 进行访问。而 referrer 键（不是特殊名称）将通过路径名 /login 指向的登录组件中的 this.props.location.state.referrer进行访问。 push: bool如果为 true，重定向会将新的位置推入历史记录，而不是替换当前条目。 1&lt;Redirect push to=\"/somewhere/else\" /&gt; from: string要从中进行重定向的路径名，可以是 path-to-regexp 能够理解的任何有效的 URL 路径。所有匹配的 URL 参数都会提供给 to，必须包含在 to 中用到的所有参数，to 未使用的其它参数将被忽略。 只能在 &lt;Switch&gt;组件内使用 &lt;Redirect from&gt;，以匹配一个位置。 1234&lt;Switch&gt; &lt;Redirect from=\"/old-path\" to=\"/new-path\" /&gt; &lt;Route path=\"/new-path\" component=&#123;Place&#125; /&gt;&lt;/Switch&gt; 12345// 根据匹配参数进行重定向&lt;Switch&gt; &lt;Redirect from=\"/users/:id\" to=\"/users/profile/:id\" /&gt; &lt;Route path=\"/users/profile/:id\" component=&#123;Profile&#125; /&gt;&lt;/Switch&gt; 译注：经过实践，发现以上“根据匹配参数进行重定向”的示例存在 bug，没有效果。to 中的 :id 并不会继承 from 中的 :id 匹配的值，而是直接作为字符串显示到浏览器地址栏！！！ exact: boolstrict: bool组件-link123456789101112131415// to为string&lt;Link to='/courses?sort=name'/&gt;// to为obj&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt;// replace&lt;Link to=\"/courses\" replace /&gt;// replace(bool)：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；// 为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false； 组件-NavLink12345678910111213141516171819&lt;NavLink to=\"/about\" exact&gt;About&lt;/NavLink&gt;&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt;&lt;NavLink to=\"/faq\" activeStyle=&#123;&#123; fontWeight: 'bold', color: 'red' &#125;&#125;&gt;FAQs&lt;/NavLink&gt;&lt;NavLink to=\"/events/123\" isActive=&#123;oddEvent&#125;&gt;Event 123&lt;/NavLink&gt; 参考 React Router 中文文档（一） react-浅析 react-router4","categories":[{"name":"React-Router","slug":"React-Router","permalink":"https://gershonv.github.io/categories/React-Router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://gershonv.github.io/tags/react-router/"}]},{"title":"react-router - [译] Code Splitting","slug":"react-router-3","date":"2018-11-07T02:37:40.000Z","updated":"2019-01-03T15:07:33.844Z","comments":true,"path":"2018/11/07/react-router-3/","link":"","permalink":"https://gershonv.github.io/2018/11/07/react-router-3/","excerpt":"One great feature of the web is that we don’t have to make our visitors download the entire app before they can use it. You can think of code splitting as incrementally downloading the app. To accomplish this we’ll use webpack, @babel/plugin-syntax-dynamic-import, and react-loadable. Code Spliting 的一个重要特性是我们不必让访问者在使用它之前下载整个应用程序。您可以将代码拆分视为逐步下载应用程序。为此，我们将使用 webpack，@babel/plugin-syntax-dynamic-import 和 react-loadable。","text":"One great feature of the web is that we don’t have to make our visitors download the entire app before they can use it. You can think of code splitting as incrementally downloading the app. To accomplish this we’ll use webpack, @babel/plugin-syntax-dynamic-import, and react-loadable. Code Spliting 的一个重要特性是我们不必让访问者在使用它之前下载整个应用程序。您可以将代码拆分视为逐步下载应用程序。为此，我们将使用 webpack，@babel/plugin-syntax-dynamic-import 和 react-loadable。 12yarn add @babel/plugin-syntax-dynamic-import -Dyarn add react-loadable webpack has built-in support for dynamic imports; however, if you are using Babel (e.g., to compile JSX to JavaScript) then you will need to use the @babel/plugin-syntax-dynamic-import plugin. This is a syntax-only plugin, meaning Babel won’t do any additional transformations. The plugin simply allows Babel to parse dynamic imports so webpack can bundle them as a code split. Your .babelrc should look something like this: webpack 内置了对动态导入的支持;但是，如果您使用 Babel（例如，将 JSX 编译为 JavaScript），那么您将需要使用 @babel/plugin-syntax-dynamic-import 插件。这是一个仅限语法的插件，这意味着 Babel 不会进行任何其他转换。该插件只允许 Babel 解析动态导入，因此 webpack 可以将它们捆绑为代码拆分。你的.babelrc 应该是这样的： 1234&#123; \"presets\": [\"@babel/react\"], \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"]&#125; react-loadable is a higher-order component for loading components with dynamic imports. It handles all sorts of edge cases automatically and makes code splitting simple! Here’s an example of how to use react-loadable: react-loadable 是一个高阶组件，用于加载具有动态导入的组件。它自动处理各种边缘情况，使代码分割变得简单！以下是如何使用 react-loadable 的示例： 新建 components/About.jsx components/Loading.jsx: 1234567891011121314import React from 'react'import Loadable from 'react-loadable'import Loading from './components/Loading'const LoadableComponent = Loadable(&#123; loader: () =&gt; import('./components/About'), loading: Loading&#125;)export default class App extends React.Component &#123; render() &#123; return &lt;LoadableComponent /&gt; &#125;&#125; 只需使用 LoadableComponent（或任何您命名的组件），当您在应用程序中使用它时，它将自动加载和呈现。loader 选项是一个实际加载组件的函数，而 loading 是一个占位符组件，用于在实际组件加载时显示。 Code-splitting + server rendering | 代码分割与服务端渲染 react-loadable includes a guide for server-side rendering. All you should need to do is include babel-plugin-import-inspector in your .babelrc and server-side rendering should just work™. Here is an example .babelrc file: react-loadable 包括服务器端呈现的指南。您需要做的就是在.babelrc 中包含 babel-plugin-import-inspector，服务器端渲染应该只是work™。这是一个示例.babelrc 文件： 123456789101112&#123; \"presets\": [\"@babel/react\"], \"plugins\": [ \"@babel/plugin-syntax-dynamic-import\", [ \"import-inspector\", &#123; \"serverSideRequirePath\": true &#125; ] ]&#125; 相关介绍React Loadable - 以组件为中心的代码分割和懒加载","categories":[{"name":"React-Router","slug":"React-Router","permalink":"https://gershonv.github.io/categories/React-Router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://gershonv.github.io/tags/react-router/"}]},{"title":"react-router - [译] Basic Components","slug":"react-router-2","date":"2018-11-07T02:37:36.000Z","updated":"2019-01-03T15:07:23.772Z","comments":true,"path":"2018/11/07/react-router-2/","link":"","permalink":"https://gershonv.github.io/2018/11/07/react-router-2/","excerpt":"Routers At the core of every React Router application should be a router component. For web projects, react-router-dom provides and routers. Both of these will create a specialized history object for you. Generally speaking, you should use a if you have a server that responds to requests and a if you are using a static file server. 每个 React Router 应用程序的核心应该是路由器组件。对于 Web 项目，react-router-dom 提供&lt;BrowserRouter&gt;和&lt;HashRouter&gt;路由器。这两个都将为您创建一个专门的历史对象。 一般来说，如果您有响应请求的服务器，则应使用&lt;BrowserRouter&gt;;如果使用静态文件服务器，则应使用&lt;HashRouter&gt;。","text":"Routers At the core of every React Router application should be a router component. For web projects, react-router-dom provides and routers. Both of these will create a specialized history object for you. Generally speaking, you should use a if you have a server that responds to requests and a if you are using a static file server. 每个 React Router 应用程序的核心应该是路由器组件。对于 Web 项目，react-router-dom 提供&lt;BrowserRouter&gt;和&lt;HashRouter&gt;路由器。这两个都将为您创建一个专门的历史对象。 一般来说，如果您有响应请求的服务器，则应使用&lt;BrowserRouter&gt;;如果使用静态文件服务器，则应使用&lt;HashRouter&gt;。 Router 组件本身只是一个容器，真正的路由要通过 Route 组件定义: Route MatchingThere are two route matching components: &lt;Route&gt; and &lt;Switch&gt;. Route matching is done by comparing a ‘s path prop to the current location’s pathname. When a matches it will render its content and when it does not match, it will render null. A with no path will always match. 路由匹配是通过将&lt;Route&gt;的路径 prop 与当前位置的路径名进行比较来完成的。 当&lt;Route&gt;匹配时，它将呈现其内容，当它不匹配时，它将呈现为 null。 没有路径的&lt;Route&gt;将始终匹配。 The is not required for grouping s, but it can be quite useful. A will iterate over all of its children elements and only render the first one that matches the current location. This helps when multiple route’s paths match the same pathname, when animating transitions between routes, and in identifying when no routes match the current location (so that you can render a “404” component). &lt;Switch&gt; 组件用于包裹 &lt;Route&gt; 组件, &lt;Switch&gt; 将迭代其所有子 &lt;Route&gt; 元素，并仅渲染与当前位置匹配的第一个子元素。当多个路径的路径匹配相同的路径名，动画路径之间的转换，以及识别何时没有路径与当前位置匹配（这样您可以渲染“404”组件）时，这会有所帮助。 12345678910111213141516171819202122232425import React from 'react'import &#123; BrowserRouter, Route, Switch &#125; from 'react-router-dom'const About = () =&gt; &lt;h1&gt;About&lt;/h1&gt;const Home = () =&gt; &lt;h1&gt;Home&lt;/h1&gt;const NoFound = () =&gt; &lt;h1&gt;NoFound&lt;/h1&gt;/** * @desc Switch 组件包裹，匹配第一个匹配到路由的组件 * 1. 没有 exact 属性，则永远都能匹配到第一个组件，不会匹配到下面的路由 * 2. 都匹配不中时，匹配到最后一个组件。可以作为404 */const App = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route component=&#123;NoFound&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; )&#125;export default App Route Rendering Props对于给定的组件呈现方式，您有三个 prop 选项：component，render 和 children。 component should be used when you have an existing component (either a React.Component or a stateless functional component) that you want to render. render, which takes an inline function, should only be used when you have to pass in-scope variables to the component you want to render. You should not use the component prop with an inline function to pass in-scope variables because you will get undesired component unmounts/remounts. component: 在你需要呈现现有的组件，应使用该属性。 render: 采用内联函数，当你需要传递变量给渲染的组件时，才使用。 1234567891011// 正确的使用方式const name = 'guodada'&lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt;&lt;Route path=\"/about\" render=&#123;props =&gt; &lt;About &#123;...props&#125; name=&#123;name&#125; /&gt;&#125;/&gt;// incorrect&lt;Route path=\"/about\" component=&#123;props =&gt; &lt;About &#123;...props&#125; name=&#123;name&#125; /&gt;&#125;/&gt; children - 使用在嵌套路由中123456789101112131415161718192021222324252627282930313233import React from 'react'import &#123; BrowserRouter as Router, Switch, Route &#125; from 'react-router-dom'const Home = () =&gt; &lt;h1&gt;Home&lt;/h1&gt;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;header&gt;我是 header&lt;/header&gt; &#123;this.props.children&#125; &lt;footer&gt;我是 footer&lt;/footer&gt; &lt;/div&gt; ) &#125;&#125;const Routes = () =&gt; ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=\"/\" render=&#123;props =&gt; ( &lt;App &#123;...props&#125;&gt; &lt;Route path=\"/home\" component=&#123;Home&#125; /&gt; &lt;/App&gt; )&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt;)export default Routes 上面代码中，用户访问/home 时，会先加载 App 组件，然后在它的内部再加载 Home 组件 上面代码中，App 组件的 this.props.children 属性就是子组件。 子路由也可以不写在 Router 组件里面，单独传入 Router 组件的 routes 属性。 12345678const routes = ( &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"/home\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;/Route&gt;)&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125; /&gt; Navigation - 导航 React Router provides a component to create links in your application. Wherever you render a , an anchor () will be rendered in your application’s HTML. React Router 提供了一个&lt;Link&gt;组件来在您的应用程序中创建链接。无论何处呈现，锚点（）都将在应用程序的 HTML 中呈现 123456import &#123; NavLink &#125; from 'react-router-dom'// location = &#123; pathname: '/react' &#125;&lt;NavLink to=\"/react\" activeClassName=\"hurray\"&gt; React&lt;/NavLink&gt;","categories":[{"name":"React-Router","slug":"React-Router","permalink":"https://gershonv.github.io/categories/React-Router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://gershonv.github.io/tags/react-router/"}]},{"title":"react-router - [译] quickstart","slug":"react-router-1","date":"2018-11-07T02:30:48.000Z","updated":"2019-01-03T15:07:13.610Z","comments":true,"path":"2018/11/07/react-router-1/","link":"","permalink":"https://gershonv.github.io/2018/11/07/react-router-1/","excerpt":"Quick start - 快速开始1234567891011121314151617181920212223242526import React from 'react'import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'const Index = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;const About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;const Users = () =&gt; &lt;h2&gt;Users&lt;/h2&gt;const AppRouter = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;Link to=\"/about/\"&gt;About&lt;/Link&gt; &lt;Link to=\"/users/\"&gt;Users&lt;/Link&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Route path=\"/\" exact component=&#123;Index&#125; /&gt; &lt;Route path=\"/about/\" component=&#123;About&#125; /&gt; &lt;Route path=\"/users/\" component=&#123;Users&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;)export default AppRouter","text":"Quick start - 快速开始1234567891011121314151617181920212223242526import React from 'react'import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'const Index = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;const About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;const Users = () =&gt; &lt;h2&gt;Users&lt;/h2&gt;const AppRouter = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;Link to=\"/about/\"&gt;About&lt;/Link&gt; &lt;Link to=\"/users/\"&gt;Users&lt;/Link&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Route path=\"/\" exact component=&#123;Index&#125; /&gt; &lt;Route path=\"/about/\" component=&#123;About&#125; /&gt; &lt;Route path=\"/users/\" component=&#123;Users&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;)export default AppRouter Nested Routing -嵌套路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from 'react'import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'const App = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;Link to=\"/about/\"&gt;About&lt;/Link&gt; &lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt; &lt;/nav&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;)const Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;const About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;/** * @param props * Route 组件中 component 的 props 中会传递 match 属性 * @example /topics/components * match `isExact`: true ; `params`: &#123;id: \"components\"&#125; ; `path`: \"/topics/:id\"; `url`: \"/topics/components\" */const Topic = (&#123; match &#125;) =&gt; &lt;h3&gt;Requested Param: &#123;match.params.id&#125;&lt;/h3&gt;const Topics = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:id`&#125; component=&#123;Topic&#125; /&gt; &lt;Route exact path=&#123;match.path&#125; render=&#123;() =&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt;&#125; /&gt; &lt;/div&gt;)export default App","categories":[{"name":"React-Router","slug":"React-Router","permalink":"https://gershonv.github.io/categories/React-Router/"}],"tags":[{"name":"react-router","slug":"react-router","permalink":"https://gershonv.github.io/tags/react-router/"}]},{"title":"koa2-基础知识","slug":"koa2-base","date":"2018-10-21T12:20:25.000Z","updated":"2019-01-03T15:02:23.995Z","comments":true,"path":"2018/10/21/koa2-base/","link":"","permalink":"https://gershonv.github.io/2018/10/21/koa2-base/","excerpt":"起步1npm i koa -S 1234567891011const Koa = require('koa')const app = new Koa()app.use(async ctx =&gt; &#123; ctx.body = 'hello koa'&#125;)app.listen(3000, () =&gt; &#123; console.log('app listen on http://127.0.0.1:3000')&#125;)","text":"起步1npm i koa -S 1234567891011const Koa = require('koa')const app = new Koa()app.use(async ctx =&gt; &#123; ctx.body = 'hello koa'&#125;)app.listen(3000, () =&gt; &#123; console.log('app listen on http://127.0.0.1:3000')&#125;) 接收 get / post 请求get =&gt; ctx.query1234567891011app.use(async ctx =&gt; &#123; /** * test: http://localhost:3000/?username=guodada * url: /?username=guodada * query: &#123;username: \"guodada\"&#125; * querystring: username=guodada * request: &#123; header, method, url&#125; */ let &#123; url, request, query, querystring &#125; = ctx ctx.body = &#123; url, request, query, querystring &#125;&#125;) query：返回的是格式化好的参数对象。 querystring：返回的是请求字符串。 post =&gt; ctx.request.body对于 POST 请求的处理，Koa2 没有封装方便的获取参数的方法，需要通过解析上下文 context 中的原生 node.js 请求对象 req 来获取。 12345678910111213141516171819202122232425262728293031323334353637// 将 useraname=guodada&amp;age=22 解析为 &#123; \"useraname\": \"guodada\", \"age\": 22 &#125;const parseQueryStr = queryStr =&gt; &#123; let queryData = &#123;&#125; let queryStrList = queryStr.split('&amp;') for (let [index, queryStr] of queryStrList.entries()) &#123; let itemList = queryStr.split('=') queryData[itemList[0]] = decodeURIComponent(itemList[1]) &#125; return queryData&#125;// 解析 post 得到的数据const parsePostData = ctx =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let postString = '' ctx.req.on('data', chunk =&gt; &#123; postString += chunk &#125;) ctx.req.on('end', chunk =&gt; &#123; // postString : useraname=guodada&amp;age=22 let parseData = parseQueryStr(postString) resolve(parseData) &#125;) &#125; catch (error) &#123; reject(error) &#125; &#125;)&#125;// 测试用例：post : &#123; \"useraname\": \"guodada\", \"age\": 22 &#125;app.use(async ctx =&gt; &#123; if (ctx.method === 'POST') &#123; const data = await parsePostData(ctx) ctx.body = data &#125;&#125;) koa-bodyparser上面解析 post 数据就是 koa-bodyparser 中间件函数的雏形，不需要我们写，直接使用这个中间件就可以了 1npm i koa-bodyparser -S 123456789101112const Koa = require('koa')const bodyParser = require('koa-bodyparser')const app = new Koa()app.use(bodyParser())app.use(async ctx =&gt; &#123; ctx.body = ctx.request.body&#125;)//... koa-router主要是通过 ctx.request.url 获取地址栏输入的路径，根据路径不同进行跳转。这里不做实现。使用已有的中间件 koa-router 1npm install koa-router -S 1234567891011const Router = require('koa-router')const router = new Router()router.get('/', function(ctx, next) &#123; ctx.body = 'Hello index'&#125;)app .use(router.routes()) // 作用：启动路由 .use(router.allowedMethods()) // 作用：这是官方推荐用法，我们可以看到 router.allowedMethods() 用在路由匹配// router.routes() 之后，所以在所有路由中间件最后调用，此时根据 ctx.status 设置 response 响应头 路由层级1234567891011121314151617const router = new Router()const page = new Router()// page 路由page .get('/info', async ctx =&gt; &#123; ctx.body = 'url: /page/info' &#125;) .get('/todo', async ctx =&gt; &#123; ctx.body = 'url: /page/todo' &#125;)router.use('/page', page.routes(), page.allowedMethods())app.use(router.routes()).use(router.allowedMethods())// 输入 localhost:3000/page/info 可以去到 page 的路由... cookiekoa 的上下文（ctx）直接提供了 cookie 读取和写入的方法 ctx.cookies.get(name,[optins]):读取上下文请求中的 cookie。 ctx.cookies.set(name,value,[options])：在上下文中写入 cookie。 1234567891011app.use(async ctx =&gt; &#123; ctx.cookies.set('username', 'guodada', &#123; domain: '127.0.0.1', // 写cookie所在的域名 path: '/', // 写cookie所在的路径 maxAge: 1000 * 60 * 60 * 24, // cookie有效时长 expires: new Date('2018-12-31'), // cookie失效时间 httpOnly: false, // 是否只用于http请求中获取 默认是 true overwrite: false // 是否允许重写 默认是 false &#125;) ctx.body = ctx.cookies.get('username') // guodada&#125;) koa-static 静态资源中间件1234567const path = require('path')const static = require('koa-static')const staticPath = './static'app.use(static( path.join( __dirname, staticPath))) 我们 新建 static/baidu.png, 地址输入 localhost:3000/baidu.png 就可以直接访问静态资源了。","categories":[{"name":"koa2","slug":"koa2","permalink":"https://gershonv.github.io/categories/koa2/"}],"tags":[{"name":"koa2","slug":"koa2","permalink":"https://gershonv.github.io/tags/koa2/"}]},{"title":"js - 继承","slug":"js-extends","date":"2018-10-16T01:12:50.000Z","updated":"2019-01-03T15:11:08.058Z","comments":true,"path":"2018/10/16/js-extends/","link":"","permalink":"https://gershonv.github.io/2018/10/16/js-extends/","excerpt":"继承 原型链 prototype 共享属性/方法，实例之间相互影响 执行对给定对象的浅复制 child.prototype = new Father() 借用构造函数 解决原型中包含引用类型值所带来问题，通过使用 call、apply 在新创建的对象执行构造函数 function Child(){ Father.call(this) } 无法实现函数复用 组合继承 使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。 实现了函数复用，又能够保证每个实例都有它自己的属性 组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数 寄生组合式继承 使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型 继承是 OO 语言中的一个最为人津津乐道的概念。许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。","text":"继承 原型链 prototype 共享属性/方法，实例之间相互影响 执行对给定对象的浅复制 child.prototype = new Father() 借用构造函数 解决原型中包含引用类型值所带来问题，通过使用 call、apply 在新创建的对象执行构造函数 function Child(){ Father.call(this) } 无法实现函数复用 组合继承 使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。 实现了函数复用，又能够保证每个实例都有它自己的属性 组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数 寄生组合式继承 使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型 继承是 OO 语言中的一个最为人津津乐道的概念。许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。 原型链ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 实现原型链有一种基本模式，其代码大致如下。 1234567891011121314151617181920function SuperType() &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;function SubType() &#123; this.Subproperty = false&#125;SubType.prototype = new SuperType()SuperType.prototype.getSubValue = function() &#123; return this.subproperty&#125;var instance = new SubType()console.log(instance.getSuperValue()) 以上代码定义了两个类型： SuperType 和 SubType 。每个类型分别有一个属性和一个方法。它们的主要区别是 SubType 继承了 SuperType ，而继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图 通过原型链，本质上扩展了原型搜索机制。在 instance.getSuperValue()调用会经历三个搜索步骤 搜索实例 搜索原型对象 搜索父类原型对象 instance 指向 SubType 的 原 型 ， SubType 的 原 型 又 指 向 SuperType 的 原 型 。 getSuperValue() 方 法 仍 然 还 在 SuperType.prototype 中，但 property 则位于 SubType.prototype 中。 原型链的问题原型链这么强大，同样也会造成问题。最主要的问题来自于包含引用类型的原型。引用类型的原型属性会被虽有实例共享，在通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性也就顺理成章变成来现在的原型属性。 123456789101112function SuperType() &#123; this.colors = ['red', 'blue', 'green']&#125;function SubType() &#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType()var instance1 = new SubType()instance1.colors.push('black')alert(instance1.colors) //\"red,blue,green,black\"var instance2 = new SubType()alert(instance2.colors) //\"red,blue,green,black\" ======&gt; 实例 instance2 的 colors 也被更新了 还有一个问题，就是不能在创建子类性时，像父类型的构造函数传递参数。所以我们一般很少单独使用原型链。 借用构造函数在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply() 和 call() 方法也可以在（将来）新创建的对象上执行构造函数，如下所示： 123456789101112131415function SuperType() &#123; this.colors = ['red', 'blue', 'green']&#125;function SubType() &#123; // 继承了 SuperType SuperType.call(this) // 通过使用 call() 方法 在新创建的 SubType 实例的环境下调用了 SuperType 构造函数 // 这样一来，就会在新 SubType 对象上执行 SuperType() 函数中定义的所有对象初始化代码&#125;var instance1 = new SubType()instance1.colors.push('black')alert(instance1.colors) //\"red,blue,green,black\"var instance2 = new SubType()alert(instance2.colors) //\"red,blue,green\" 借用构造函数的问题：如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 组合继承将原型链和借用构造函数的技术组合到一块：其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 1234567891011121314151617181920212223242526272829function SuperType(name) &#123; //SuperType 构造函数定义了两个属性： name 和 colors this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function () &#123; // 原型上定义了sayName方法，其实例共享这个方法 alert(this.name);&#125;;function SubType(name, age) &#123; //继承属性 SuperType.call(this, name); // 调用 SuperType 构造函数时传入了 name 参数 this.age = age; // 定义了它自己的属性 age&#125;//继承方法SubType.prototype = new SuperType(); // 将 SuperType 的实例赋值给 SubType 的原型SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123; // 在该新原型上定义了方法 sayAge() alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"instance1.sayName(); //\"Nicholas\";instance1.sayAge(); //29var instance2 = new SubType(\"Greg\", 27);alert(instance2.colors); //\"red,blue,green\"instance2.sayName(); //\"Greg\";instance2.sayAge(); //27 在这个例子中， SuperType 构造函数定义了两个属性： name 和 colors ，其原型定义了一个方法 sayName SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着又定义了它自己的属性 age 。 然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型上定义了方法 sayAge() 这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法了。 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且， instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象。 寄生组合式继承组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。 123456789101112131415161718function SuperType(name) &#123; this.name = name&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name)&#125;function SubType(name, age) &#123; // 继承了 SuperType SuperType.call(this, name) //第二次调用 this.age = age&#125;SubType.prototype = new SuperType() // 第一次调用var instance1 = new SubType()console.log(instance1.name) 我们不必为了指定子类型的原型调用超类型的构造函数，我们所需要的不过是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype) //创建对象 prototype.constructor = subType //增强对象 subType.prototype = prototype //指定对象&#125; 1234567891011121314151617function SuperType(name) &#123; this.name = name this.color = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function() &#123; console.log(this.name)&#125;function SubType(name, age) &#123; SuperType.call(this, name) this.age = age&#125;SubType.prototype = Object.create(SuperType.prototype)SubType.prototype.constructor = SubType","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"}]},{"title":"js - 创建对象的几种方式（工厂模式、构造函数模式、原型模式）","slug":"js-createObject","date":"2018-10-16T01:11:46.000Z","updated":"2019-01-03T15:11:21.322Z","comments":true,"path":"2018/10/16/js-createObject/","link":"","permalink":"https://gershonv.github.io/2018/10/16/js-createObject/","excerpt":"创建对象的模式 工厂模式 做法：内部创建一个对象，并未对象属性赋值并且返回 缺点：解决创建多个相识对象的问题，但不能识别创建的对象的类型 构造函数模式 做法：直接将属性和方法赋值给 this 对象，没有 return 语句 缺点：对象不是共用方法和属性，每 new 一次对象就要创建一个内存，超出性能消耗 原型模式 做法：通过 prototype 为对象添加属性 缺点：每个实例都共享属性方法，实例中修改对象属性会影响到其他实例 组合使用构造函数模式和原型模式 做法：构造函数模式用于定义实例属性，而原型模式用于定义共用方法 构造函数与原型混成，使用较为广泛 动态原型模式 过检查某个应该存在的方法是否有效，来决定是否需要初始化原中的某个属性 寄生构造函数模式…","text":"创建对象的模式 工厂模式 做法：内部创建一个对象，并未对象属性赋值并且返回 缺点：解决创建多个相识对象的问题，但不能识别创建的对象的类型 构造函数模式 做法：直接将属性和方法赋值给 this 对象，没有 return 语句 缺点：对象不是共用方法和属性，每 new 一次对象就要创建一个内存，超出性能消耗 原型模式 做法：通过 prototype 为对象添加属性 缺点：每个实例都共享属性方法，实例中修改对象属性会影响到其他实例 组合使用构造函数模式和原型模式 做法：构造函数模式用于定义实例属性，而原型模式用于定义共用方法 构造函数与原型混成，使用较为广泛 动态原型模式 过检查某个应该存在的方法是否有效，来决定是否需要初始化原中的某个属性 寄生构造函数模式… 前言js 面向对象第一步是什么？答：创建对象。创建对象有很多中方式，我们最常用的是对象字面量来创建对象，var obj = {}，你看我这不就创建了一个对象了吗，我还干嘛要继续了解那些奇葩的方法呢？这么想的人活该单身，多掌握些找对象只有好处没有坏处哈。正经的，高阶上有这么一句话，使用对象字面量创建单个对象，有个明显的缺点，使用同一个接口创建很多对象，会产生大量重复的代码。为了解决这个问题，我们需要了解下面?这些方式。 工厂模式123456789101112function createPerson(name, age, job) &#123; var o = new Object() o.name = name o.age = age o.job = job o.sayName = function() &#123; alert(this.name) &#125; return o&#125;var person1 = createPerson('Nicholas', 29, 'Software Engineer')var person2 = createPerson('Greg', 27, 'Doctor') 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题法识别创建的对象的类型。因为全部都是 Object，没有区分度，不像 Date、Array 等，因此出现了构造函数模式 构造函数模式12345678910function Person(name) &#123; this.name = name this.showName = function() &#123; alert(this.name) &#125;&#125;var p1 = new Person('haha')p1.showName()var p2 = new Person('hehe')p2.showName() 我们注意到， Person() 中的代码除了与 createPerson() 中相同的部分外，还存在以下不同之处： 没有显式地创建对象； 直接将属性和方法赋给了 this 对象； 没有 return 语句。 此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 举个例子 123456789function Person(name) &#123; this.name = name this.showName = function() &#123; alert(this.name) &#125; console.log(this)&#125;new Person('haha') //PersonPerson('haha') //window 我们会发现当用 New 去调用一个函数的时候，this 的指向会不一样。其实 New 主要做了下面这些事，不过下面写的只是大概的行为，并不是内部源码 1234567891011function Person(name) &#123; var obj = &#123;&#125; //声明一个空对象obj obj._proto_ = Person.prototype //把这个对象的_proto_属性指向构造函数的原型对象,这样obj就可以调用Person原型对象下的所有方法 ，这里原型先知道结论，下面会讲。 Person.apply(obj) //用apply方法让this指向obj对象 this.name = name //obj对象添加属性，方法 this.showName = function() &#123; alert(this.name) &#125; return obj //返回这个对象&#125; 函数构造模式存在的问题： 1alert(p1.showName == p2.showName) //false 可见这两个对象并不是共用一个方法，每 new 一次，系统都会新创建一个内存，这两个对象各自有各自的地盘，但他们具有相同的功能，还不共用，肯定不是我们所希望的。所以就有了下一种方法，原型+构造模式 ==&gt;原型模式 原型模式我们创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。 1234567891011function Person(name) &#123; this.name = name&#125;Person.prototype.showName = function() &#123; alert(this.name)&#125;var p1 = new Person('haha')p1.showName()var p2 = new Person('hehe')p2.showName()alert(p1.showName == p2.showName) //true 测试为 true，可见 showName()方法是共享的，也就是说他们共用一个内存，更进一步的说它们存在引用关系，也就是说你更改了 p1 的 showName 也会影响 p2 的 showName，而这个问题正是我们很少看到有人单独使用原型模式的原因所在。 组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。 12345678910111213141516171819function Person(name, age, job) &#123; this.name = name this.age = age this.job = job this.friends = ['Shelby', 'Court']&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name) &#125;&#125;var person1 = new Person('Nicholas', 29, 'Software Engineer')var person2 = new Person('Greg', 27, 'Doctor')person1.friends.push('Van')alert(person1.friends) //\"Shelby,Count,Van\"alert(person2.friends) //\"Shelby,Count\"alert(person1.friends === person2.friends) //falsealert(person1.sayName === person2.sayName) //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName() 则是在原型中定义的。而修改了 person1.friends （向其中添加一个新字符串），并不会影响到 person2.friends ，因为它们分别引用了不同的数组。 种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 动态原型模式有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。 1234567891011121314function Person(name, age, job) &#123; //属性 this.name = name this.age = age this.job = job // 方法 if (typeof this.sayName != 'function') &#123; Person.prototype.sayName = function() &#123; alert(this.name) &#125; &#125;&#125;var friend = new Person('Nicholas', 29, 'Software Engineer')friend.sayName() 注意构造函数代码中 if 判断语句的部分。这里只在 sayName() 方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中， if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定它的类型。 使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 123456789function Person() &#123;&#125;var friend = new Person()Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name) &#125;&#125;friend.sayName() //error 寄生构造函数模式….","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"}]},{"title":"ES6 - Map 和 Set","slug":"es6-map&set","date":"2018-10-16T01:07:08.000Z","updated":"2019-01-03T15:12:44.906Z","comments":true,"path":"2018/10/16/es6-map&set/","link":"","permalink":"https://gershonv.github.io/2018/10/16/es6-map&set/","excerpt":"Map 和 SetJavaScript 的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy']var scores = [95, 75, 85] 给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。 如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下：","text":"Map 和 SetJavaScript 的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy']var scores = [95, 75, 85] 给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。 如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]])m.get('Michael') // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map() // 空Mapm.set('Adam', 67) // 添加新的key-valuem.set('Bob', 59)m.has('Adam') // 是否存在key 'Adam': truem.get('Adam') // 67m.delete('Adam') // 删除key 'Adam'm.get('Adam') // undefined 由于一个 key 只能对应一个 value，所以，多次对一个 key 放入 value，后面的值会把前面的值冲掉： 1234var m = new Map()m.set('Adam', 67)m.set('Adam', 88)m.get('Adam') // 88 SetSet和Map类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在Set中，没有重复的 key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set() // 空Setvar s2 = new Set([1, 2, 3]) // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3'])s // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4)s // Set &#123;1, 2, 3, 4&#125;s.add(4)s // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s = new Set([1, 2, 3])s // Set &#123;1, 2, 3&#125;s.delete(3)s // Set &#123;1, 2&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://gershonv.github.io/tags/ES6/"}]},{"title":"webpack-plugins","slug":"webpack-plugins","date":"2018-10-12T13:43:08.000Z","updated":"2019-01-03T15:13:54.713Z","comments":true,"path":"2018/10/12/webpack-plugins/","link":"","permalink":"https://gershonv.github.io/2018/10/12/webpack-plugins/","excerpt":"功能类html-webpack-plugin 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等 filename：输出文件名； template：模板文件，不局限于 html 后缀哦； removeComments：移除 HTML 中的注释； collapseWhitespace：删除空白符与换行符，整个文件会压成一行； inlineSource：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入； inject：是否能注入内容到 输出 的页面去； chunks：指定插入某些模块； hash：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；其他：favicon、meta、title ……；","text":"功能类html-webpack-plugin 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等 filename：输出文件名； template：模板文件，不局限于 html 后缀哦； removeComments：移除 HTML 中的注释； collapseWhitespace：删除空白符与换行符，整个文件会压成一行； inlineSource：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入； inject：是否能注入内容到 输出 的页面去； chunks：指定插入某些模块； hash：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；其他：favicon、meta、title ……； 12345678910111213141516171819202122const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; mode: 'production', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'js/[name].[hash:8].js' // 打包路径及名称 &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 生成文件名 template: './public/index.html', // 配置要被编译的html文件 hash: true, // 压缩HTML文件 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ]&#125; 传送门 ==&gt; html-webpack-plugin clean-webpack-plugin 在编译之前清理指定目录指定内容。 123456const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125;// 指定清除哪些文件 new CleanWebpackPlugin(pathsToClean [, &#123;pathsToClean &#125;]) 详情请看 npm 传送门 ==&gt; clean-webpack-plugin copy-webpack-plugin12345const CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = &#123; plugins: [new CopyWebpackPlugin([...patterns], options)]&#125; 传送门 ==&gt; copy-webpack-plugin compression-webpack-plugin 使用 compression-webpack-plugin 插件进行压缩，提供带 Content-Encoding 编码的压缩版的资源。 12345678910111213const CompressionPlugin = require('compression-webpack-plugin')module.exports = &#123; plugins: [ new CompressionPlugin(&#123; filename: '[path].gz[query]', //目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串 algorithm: 'gzip', //算法 test: /\\.js(\\?.*)?$/i, //压缩 js deleteOriginalAssets: true, // 删除源文件 threshold: 10240, //只处理比这个值大的资源。按字节计算 minRatio: 0.8 //只有压缩率比这个值小的资源才会被处理 &#125;) ]&#125; 传送门 ==&gt; compression-webpack-plugin webpack-manifest-plugin 该插件可以显示出编译之前的文件和编译之后的文件的映射 1234const ManifestPlugin = require('webpack-manifest-plugin')module.exports = &#123; plugins: [new ManifestPlugin()]&#125; 传送门 ==&gt; webpack-manifest-plugin progress-bar-webpack-plugin 编译进度条插件 1234const ProgressBarPlugin = require('progress-bar-webpack-plugin') // 编译进度条插件module.exports = &#123; plugins: [new ProgressBarPlugin()]&#125; 传送门 ==&gt; progress-bar-webpack-plugin 代码相关webpack.ProvidePlugin 自动加载模块，而不必到处 import 或 require 。 1234567const webpack = require('webpack')module.exports = &#123; plugins: [new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;)]&#125;// index.jsconsole.log($) 传送门 ==&gt; webpack.ProvidePlugin webpack.DefinePlugin DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 DefinePlugin 的用处，设置它，就可以忘记开发和发布构建的规则。 12345678910module.exports = &#123; plugins: [ new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true) &#125;) ]&#125;// index.jsconsole.log(PRODUCTION) // true 传送门 ==&gt; webpack.DefinePlugin mini-css-extract-pluginmini-css-extract-plugin，它默认就会对你的样式进行模块化拆分。相对 extract-text-webpack-plugin。 即 css 异步按需加载 1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require('mini-css-extract-plugin') // 抽取 css 到独立文件module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '../' // chunk publicPath &#125; &#125;, 'css-loader' ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].[hash:8].css', //这里配置跟output写法一致 chunkFilename: 'css/[id][chunkhash:8].css' &#125;) ]&#125; 传送门 ==&gt; mini-css-extract-plugin 编译结果优化类wbepack.IgnorePlugin防止在 import 或 require 调用时，生成以下正则表达式匹配的模块： requestRegExp 匹配(test)资源请求路径的正则表达式。 contextRegExp （可选）匹配(test)资源上下文（目录）的正则表达式。 moment 2.18 会将所有本地化内容和核心功能一起打包（见该 GitHub issue）。你可使用 IgnorePlugin 在打包时忽略本地化内容: 1new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) 传送门 ==&gt; wbepack.IgnorePlugin uglifyjs-webpack-plugin js 代码压缩,默认会使用 optimization.minimizer， cache: Boolean/String ,字符串即是缓存文件存放的路径； test：正则表达式、字符串、数组都可以，用于只匹配某些文件，如：/.js(?.*)?\\$/i; parallel : 启用多线程并行运行来提高编译速度，经常编译的时候听到电脑跑的呼呼响，可能就是它干的，哈哈～； output.comments ： 删除所有注释， compress.warnings ：插件在进行删除一些无用代码的时候，不提示警告， compress.drop_console：喜欢打 console 的同学，它能自动帮你过滤掉，再也不用担心线上还打印日志了； 1234567891011121314151617181920212223242526const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多线程编译 sourceMap: true, // 是否sourceMap // 丑化参数 uglifyOptions: &#123; comments: false, warnings: false, compress: &#123; unused: true, dead_code: true, collapse_vars: true, reduce_vars: true &#125;, output: &#123; comments: false &#125; &#125; &#125;) ] &#125;&#125; 传送门 ==&gt; uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin它的作用在于压缩 css 文件 assetNameRegExp：默认是全部的 css 都会压缩，该字段可以进行指定某些要处理的文件， cssProcessor：指定一个优化 css 的处理器，默认 cssnano， cssProcessorPluginOptions：cssProcessor 后面可以跟一个 process 方法，会返回一个 promise 对象，而 cssProcessorPluginOptions 就是一个 options 参数选项！ canPrint：布尔，是否要将编译的消息显示在控制台，没发现有什么用！ 坑点 ：建议使用高版本的包，之前低版本有遇到样式丢失把各浏览器前缀干掉的问题， 1234567891011const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin') // 丑化 cssmodule.exports = &#123; optimization: &#123; minimizer: [ new OptimizeCssAssetsPlugin(&#123; cssProcessor: require('cssnano'), // css 压缩优化器 cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125; // 去除所有注释 &#125;) ] &#125;&#125; 传送门 ==&gt; optimize-css-assets-webpack-plugin SplitChunksPluginwebpack 把 chunk 分为两种类型，一种是初始加载 initial chunk，另外一种是异步加载 async chunk，如果不配置 SplitChunksPlugin，`webpack 会在 production 的模式下自动开启，默认情况下，webpack会将node_modules下的所有模块定义为异步加载模块，并分析你的entry、动态加载（import()、require.ensure）模块，找出这些模块之间共用的node_modules下的模块，并将这些模块提取到单独的chunk` 中，在需要的时候异步加载到页面当中，其中默认配置如下： 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'async', // 异步加载chunk minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', // 文件名中chunk分隔符 name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // priority: -10 &#125;, default: &#123; minChunks: 2, // 最小的共享chunk数 priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 传送门 ==&gt; SplitChunksPlugin webpack.HotModuleReplacementPlugin热更新, 配合 webpack-dev-server 使用 1yarn add webpack-dev-server -D 123456789101112131415161718new webpack.HotModuleReplacementPlugin()module.exports = &#123; devServer: &#123; port: 1234, open: true, // 自动打开浏览器 compress: true, // 服务器压缩 hot: true // 开启热加载 //... proxy、hot &#125;, plugins: [new webpack.HotModuleReplacementPlugin()]&#125;// index.jsif (module.hot) &#123; module.hot.accept()&#125; 传送门 ==&gt; devServer 传送门 ==&gt; webpack-dev-server 加快编译速度DllPlugin &amp;&amp; DllReferencePlugin &amp;&amp; autodll-webpack-pluginDllPlugin 和 DllReferencePlugin 提供分离包的方式可以大大提高构建时间性能。主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包。从而节省了打包时间。 DllPlugin 插件：用于打包出一个个单独的动态链接库文件。DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。 DllPlugin context (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context)) name: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] &amp; [name] ) path: manifest json 文件的绝对路径 (输出文件) DllReferencePlugin: 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。 DllReferencePlugin context: (绝对路径) manifest (或者是内容属性)中请求的上下文 manifest: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径 content (optional): 请求到模块 id 的映射 (默认值为 manifest.content) name (optional): dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals) scope (optional): dll 中内容的前缀 sourceType (optional): dll 是如何暴露的 (libraryTarget) 传送门 ==&gt; DllPlugin","categories":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/tags/webpack/"}]},{"title":"webpack - babel篇","slug":"webpack-babel","date":"2018-10-11T06:23:24.000Z","updated":"2019-01-03T15:13:46.161Z","comments":true,"path":"2018/10/11/webpack-babel/","link":"","permalink":"https://gershonv.github.io/2018/10/11/webpack-babel/","excerpt":"Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置. 相关版本号如下 123456789101112&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/plugin-proposal-decorators\": \"^7.1.6\", \"@babel/plugin-transform-runtime\": \"^7.1.0\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/runtime\": \"^7.1.5\", \"babel-loader\": \"^8.0.4\", \"webpack\": \"^4.26.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125;","text":"Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置. 相关版本号如下 123456789101112&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/plugin-proposal-decorators\": \"^7.1.6\", \"@babel/plugin-transform-runtime\": \"^7.1.0\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/runtime\": \"^7.1.5\", \"babel-loader\": \"^8.0.4\", \"webpack\": \"^4.26.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125; babel-loader 和 @babel/core建立基本的 webpack 配置文件 1234567891011mkdir webpack-babel =&gt; cd webpack-babel =&gt; yarn init -y // 初始化npm i yarn -g // 安装了yarn可以忽略yarn add webpack webpack-cli -D// package.json 中添加：\"scripts\": &#123; \"start\": \"webpack --mode development\", \"build\": \"webpack --mode production\"&#125;yarn add babel-loader @babel/core -D yarn : 和 npm 几乎一样，本文使用 yarn 安装… babel-loader: 转义 js 文件代码的 loader @babel/core：babel 核心库 根目录下添加 webpack.config.js 123456789101112131415161718const path = require('path')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader' &#125; // options 在 .babelrc 定义 &#125; ] &#125;&#125; src/index.js 123456789101112const func = () =&gt; &#123; console.log('hello webpack')&#125;func()class User &#123; constructor() &#123; console.log('new User') &#125;&#125;const user = new User() 执行 yarn build 后就可以打包成功，打包后的代码是压缩后的。而 yarn start 后的代码是未压缩的。为了使代码可读性高一点，我们可以在webpack.config.js添加： 1234module.exports = &#123; //... devtool: true&#125; @babel-preset-env打包后我们可以发现箭头函数并未转化为 ES5 语法！ 查阅 babel plugins 文档，如果要转义箭头函数，需要使用到 @babel/plugin-transform-arrow-functions 这个插件同理转义 class 需要使用 @babel/plugin-transform-classes 1yarn add @babel/plugin-transform-arrow-functions @babel/plugin-transform-classes -D 根目录下建立 .babelrc 文件： 123456&#123; \"plugins\": [ \"@babel/plugin-transform-arrow-functions\", \"@babel/plugin-transform-classes\" ]&#125; yarn build 之后可以看出 箭头函数和类都被转义了。 但是假如你再使用 async await 之类的 es6 语法，你还得一个个添加，这是不实际的。 @babel-preset-env 就整合了这些语法转义插件： 123456789Using plugins:transform-template-literals &#123;&#125;transform-literals &#123;&#125;transform-function-name &#123;&#125;transform-arrow-functions &#123;&#125;transform-block-scoped-functions &#123;&#125;transform-classes &#123;&#125;transform-object-super &#123;&#125;//... 使用如下： 1yarn add @babel-preset-env -D .babelrc 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; @babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 这样就导致了一些新的 API 老版浏览器不兼容。如上述所说，对于新的 API，你可能需要引入 @babel-polyfill 来进行兼容 1yarn add @babel-polyfill -D 修改 weboack.config.js 123module.exports = &#123; entry: ['@babel-polyfill', './src/index.js']&#125; yarn build 发现文件体积大了很多，因为上面的代码表示将 @babel-polyfill 的代码也打包进去了。 当然这不是我们希望的，如何按需编译呢？ 我们可以这么做： index.js 123456789101112131415161718import '@babel/polyfill' // 引入const func = () =&gt; &#123; console.log('hello webpack')&#125;func()class User &#123; constructor() &#123; console.log('new User') &#125;&#125;const user = new User()new Promise(resolve =&gt; console.log('promise'))Array.from('foo') 还原 webpack.config.js 123module.exports = &#123; entry: './src/index.js'&#125; 修改 .babelrc 123&#123; \"presets\": [[\"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\" &#125;]]&#125; yarn build 后发现我们的代码体积就变得很小了！ @babel/runtime 和 @babel/plugin-transform-runtime babel-polyfill 会污染全局作用域, 如引入 Array.prototype.includes 修改了 Array 的原型，除此外还有 String… babel-polyfill 引入新的对象： Promise、WeakMap 等 这也不是我们希望出现的。 @babel/runtime 的作用： 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 _extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。 提供 polyfill：不会污染全局作用域，但是不支持实例方法如 Array.includes @transform-runtime 的作用： babel-runtime 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 polyfill，你只需使用，transform-runtime 会帮你引入。 12yarn add @babel/runtime-corejs2yarn add @babel/plugin-transform-runtime -D 修改 .babelrc 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [[\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125;]]&#125; index.js 移除 import &#39;@babel/polyfill&#39; @babel/plugin-proposal-decorators添加装饰器模式的支持 1yarn add @babel/plugin-proposal-decorators -D index.js 1234567891011function annotation(target) &#123; target.annotated = true&#125;@annotationclass User &#123; constructor() &#123; console.log('new User') &#125;&#125;//... .babelrc 1234567&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"decoratorsBeforeExport\": true &#125;], [\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125;] ]&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/tags/webpack/"}]},{"title":"webpack - 理论篇","slug":"webpack-theory","date":"2018-10-11T03:15:56.000Z","updated":"2019-01-03T15:14:00.589Z","comments":true,"path":"2018/10/11/webpack-theory/","link":"","permalink":"https://gershonv.github.io/2018/10/11/webpack-theory/","excerpt":"entry123456789101112131415161718192021/** * @param &#123;String&#125; - String 时 打包为一个文件，默认包名 main.js * @param &#123;Array&#125; - Array 时 webpack会把数组里所有文件打包成一个js文件 * @param &#123;Object&#125; - Object 时 webpack会把对象里的文件分别打包成多个文件 * */module.exports = &#123; entry: './index.js', entry: ['./index.js', './about.js'], entry: &#123; app: './index.js', about: './about.js' &#125;, entry: &#123; app: './index.js', vendors: ['jquery'] // 分离第三方库 &#125;&#125;","text":"entry123456789101112131415161718192021/** * @param &#123;String&#125; - String 时 打包为一个文件，默认包名 main.js * @param &#123;Array&#125; - Array 时 webpack会把数组里所有文件打包成一个js文件 * @param &#123;Object&#125; - Object 时 webpack会把对象里的文件分别打包成多个文件 * */module.exports = &#123; entry: './index.js', entry: ['./index.js', './about.js'], entry: &#123; app: './index.js', about: './about.js' &#125;, entry: &#123; app: './index.js', vendors: ['jquery'] // 分离第三方库 &#125;&#125; vendors 第三方库// 待补充 output 指示 webpack 如何去输出、以及在哪里输出、输出的格式等 123456789module.exports = &#123; output: &#123; path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'js/[name].[chunkhash:8].js', // 打包路径及名称 chunkFilename: 'js/[name].[chunkhash:8].js' // 按需加载 // publicPath：文件输出的公共路径， //... &#125;&#125; resolve 配置模块如何解析 extensions：自动解析确定的扩展,省去你引入组件时写后缀的麻烦， alias：非常重要的一个配置，它可以配置一些短路径， modules：webpack 解析模块时应该搜索的目录， … 123456789module.exports = &#123; resolve: &#123; extensions: ['.js', '.jsx', '.ts', '.tsx', '.scss', '.json', '.css'], alias: &#123; '@': path.resolve(__dirname, 'src') &#125;, modules: [path.resolve(__dirname, 'src'), 'node_modules'] &#125;&#125; module.rules rules：也就是之前的 loaders， test ： 正则表达式，匹配编译的文件， exclude：排除特定条件，如通常会写 node_modules，即把某些目录/文件过滤掉， include：它正好与 exclude 相反， use -loader ：必须要有它，它相当于是一个 test 匹配到的文件对应的解析器，babel-loader、style-loader、sass-loader、url-loader 等等， use - options：它与 loader 配合使用，可以是一个字符串或对象，它的配置可以直接简写在 loader 内一起，它下面还有 presets、plugins 等属性； plugins// 另一篇文章 webpack - plugins 篇 敬请期待 devtool 控制是否生成，以及如何生成 source map 文件，开发环境下更有利于定位问题，默认 false, 当然它的开启，也会影响编译的速度，所以生产环境一定一定记得关闭； 常用的值：cheap-eval-source-map、eval-source-map、cheap-module-eval-source-map、inline-cheap-module-source-map 等等 1devtool: 'eval-source-map' // 原始源代码 webpack-dev-server contentBase ：告诉服务(dev server)在哪里查找文件，默认不指定会在是当期项目根目录， historyApiFallback:可以是 boolean、 object，默认响应的入口文件，包括 404 都会指向这里，object 见下面示例： compress：启用 gzip 压缩， publicPath：它其实就是 output.publicPath，当你改变了它，即会覆盖了 output 的配置， stats： 可以自定控制要显示的编译细节信息， proxy：它其实就是 http-proxy-middleware，可以进行处理一些代理的请求。 123456789101112131415const webpack = require('webpack')module.exports = &#123; devServer: &#123; contentBase:'./assets', port: 1234, open: true, // 自动打开浏览器 compress: true // 服务器压缩 hot: true // 配合 HotModuleReplacementPlugin 使用 //... proxy、hot &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; optimization optimization 是 webpack4 新增的，主要是用来让开发者根据需要自定义一些优化构建打包的策略配置， minimize：true/false,告诉 webpack 是否开启代码最小化压缩， minimizer：自定 js 优化配置，会覆盖默认的配置，结合 UglifyJsPlugin 插件使用， removeEmptyChunks: bool 值，它检测并删除空的块。将设置为 false 将禁用此优化， nodeEnv：它并不是 node 里的环境变量，设置后可以在代码里使用 process.env.NODE_ENV === ‘development’来判断一些逻辑，生产环境 UglifyJsPlugin 会自动删除无用代码， splitChunks ：取代了 CommonsChunkPlugin，自动分包拆分、代码拆分，详细默认配置： 默认配置，只会作用于异步加载的代码块 —— chunks: ‘async’，它有三个值：all,async,initial 12345678910111213141516171819202122232425262728module.exports = &#123; // 优化构建打包的策略配置 optimization: &#123; minimize: true, // 是否开启代码最小化压缩 默认 false //splitChunks 默认配置 splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 配合 UglifyJsPlugin12345678910111213141516171819202122232425262728const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; // 优化构建打包的策略配置 optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多线程编译 sourceMap: true, // 是否sourceMap uglifyOptions: &#123; // 丑化参数 comments: false, warnings: false, compress: &#123; unused: true, dead_code: true, collapse_vars: true, reduce_vars: true &#125;, output: &#123; comments: false &#125; &#125; &#125;) ] &#125;&#125; 参考 webpack4 配置详解之慢嚼细咽","categories":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/tags/webpack/"}]},{"title":"webpack - 入门篇","slug":"webpack-入门","date":"2018-10-10T14:09:14.000Z","updated":"2019-01-03T15:14:05.699Z","comments":true,"path":"2018/10/10/webpack-入门/","link":"","permalink":"https://gershonv.github.io/2018/10/10/webpack-入门/","excerpt":"什么是 webpackwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Scss、TypeScript 等），将其打包为合适的格式以供浏览器使用 构建就是把源代码转换成发布到线上可执行的 JavaScript、CSS、HTML 代码，包括以下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。","text":"什么是 webpackwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Scss、TypeScript 等），将其打包为合适的格式以供浏览器使用 构建就是把源代码转换成发布到线上可执行的 JavaScript、CSS、HTML 代码，包括以下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 webpack 的基本概念 入口(entry point): 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，webpack 会找出有哪些模块和 library 是入口起点（直接和间接）依赖的。 默认值是 ./src/index.js，然而，可以通过在 webpack 配置中配置 entry 属性，来指定一个不同的入口起点（或者也可以指定多个入口起点）。 出口 output: 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，主输出文件默认为 ./dist/main.js，其他生成文件的默认输出目录是 ./dist loader: 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 插件 plugins: loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 模式 mode: 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 webpack 构建过程 从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则。 对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。 最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 开发环境和生产环境我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，一套供线上使用。 development: 用于开发的配置文件，用于定义 webpack dev server 和其他东西 production: 用于生产的配置文件，用于定义 UglifyJSPlugin，sourcemaps 等 简单来说，开发时可能需要打印 debug 信息，包含 sourcemap 文件，而生产环境是用于线上的即代码都是压缩后，运行时不打印 debug 信息等。譬如 axios、antd 等我们的生产环境中需要使用到那么我们应该安装该依赖在生产环境中，而 webpack-dev-server 则是需要安装在开发环境中 平时我们 npm 中安装的文件中有 -S -D, -D 表示我们的依赖是安装在开发环境的，而-S 的是安装依赖在生产环境中。 本文就来带你搭建基本的前端开发环境，前端开发环境需要什么呢？ 构建发布需要的 HTML、CSS、JS、图片等资源 使用 CSS 预处理器，这里使用 less 配置 babel 转码器 =&gt; 使用 es6+ 处理和压缩图片 配置热加载，HMR 以上配置就可以满足前端开发中需要的基本配置。下面是本文打包后的效果图： 搭建基本的开发环境安装123mkdir webpack-dev &amp;&amp; cd webpack-devnpm init -ynpm i webpack webpack-cli -D 添加 scripts生成了 package.json 文件，在文件中添加 123\"scripts\": &#123; \"build\": \"webpack --mode production\" &#125; –mode 模式 (必选，不然会有 WARNING)，是 webpack4 新增的参数选项，默认是 production --mode production 生产环境 提供 uglifyjs-webpack-plugin 代码压缩 不需要定义 new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) }) 默认 production 默认开启 NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors, 编译出错时跳过输出，以确保输出资源不包含错误 默认开启 ModuleConcatenationPlugin -&gt; optimization.concatenateModules, webpack3 添加的作用域提升(Scope Hoisting) --mode development 开发环境 使用 eval 构建 module, 提升增量构建速度 不需要定义 new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) }) 默认 development 默认开启 NamedModulesPlugin -&gt; optimization.namedModules 使用模块热替换(HMR)时会显示模块的相对路径 添加了 scripts 之后，新建src/index.js，然后执行npm run build ，你就会发现新增了一个 dist 目录，里边存放的是 webpack 构建好的 main.js 文件。 ps npm scripts 使用指南 新建 webpack.config.js 文件要想对 webpack 中增加更多的配置信息，我们需要建立一个 webpack 的配置文件。在根目录下创建 webpack.config.js 后再执行 webpack 命令，webpack 就会使用这个配置文件的配置了 配置中具备以下的基本信息： 12345678module.exports = &#123; entry: '', // 打包入口：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 output: '', // 出口 resolve: &#123;&#125;, // 配置解析：配置别名、extensions 自动解析确定的扩展等等 devServer: &#123;&#125;, // 开发服务器：run dev/start 的配置，如端口、proxy等 module: &#123;&#125;, // 模块配置：配置loader（处理非 JavaScript 文件，比如 less、sass、jsx、图片等等）等 plugins: [] // 插件的配置：打包优化、资源管理和注入环境变量&#125; 配置打包入口和出口首先我们往 webpack.config.js 添加点配置信息 123456789101112const path = require('path')module.exports = &#123; // 指定打包入口 entry: './src/index.js', // 打包出口 output: &#123; path: path.resolve(__dirname, 'dist'), // 解析路径为 ./dist filename: 'bundle.js' &#125;&#125; 上面我们定义了打包入口 ./src/index.js，打包出口为 ./dist, 打包的文件夹名字为bundle.js，执行npm run build命令后，index.js 文件会被打包为 bundle.js 文件。此时随便建立一个 html 文件引用这个bundle.js就可以看到你在index.js 写的代码了。 path.resolve([…paths]) 方法会把一个路径或路径片段的序列解析为一个绝对路径。 使用 html-webpack-plugin 创建 html 文件更多情况下我们不希望打包一次，就新建一次 html 文件来引用打包后的文件，这样显得不智能或者说当你打包的文件名修改后，引用路径就会出错。 这个时候我们就可以使用 html-webpack-plugin 插件来将 HTML 引用路径和我们的构建结果关联起来。 1npm install html-webpack-plugin -D 创建文件public/index.html 修改 webpack.config.js 文件 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './public/index.html' // 配置要被编译的html文件 &#125;) ]&#125; 重新执行 npm run build, dist 目录就会多个 index.html 并引入了 bundle.js. 压缩 html 文件修改 webpack.config.js 12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './public/index.html', // 配置要被编译的html文件 hash: true, // 压缩 =&gt; production 模式使用 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ]&#125; 打包 css 文件我们希望使用 webpack 来进行构建 css 文件，，为此，需要在配置中引入 loader 来解析和处理 CSS 文件： 1npm install style-loader css-loader -D 新建 src/assets/style/color.css, 修改 webpack.config.js 文件： 123456789101112131415161718192021module.exports = &#123; //... module: &#123; /** * test: 匹配特定条件。一般是提供一个正则表达式或正则表达式的数组 * include: 匹配特定条件。一般是提供一个字符串或者字符串数组 * exclude: 排除特定条件 * and: 必须匹配数组中的所有条件 * or: 匹配数组中任何一个条件, * nor: 必须排除这个条件 */ rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: ['style-loader', 'css-loader'] &#125; ] &#125; //...&#125; 经由上述两个 loader 的处理后，CSS 代码会转变为 JS， 如果需要单独把 CSS 文件分离出来，我们需要使用 mini-css-extract-plugin 插件 抽取 css 到独立文件, 自动添加前缀1npm i mini-css-extract-plugin postcss-loader autoprefixer -D 我们在写 css 时不免要考虑到浏览器兼容问题，如 transform 属性，需要添加浏览器前缀以适配其他浏览器。故使用到 postcss-loader 这个 loader， 下面则是相关的配置 webpack.config.js 123456789101112131415161718192021222324252627282930const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] &#125; &#125; ] &#125; ] &#125;, plugins: [ //... new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[id].css' &#125;) ]&#125; 打包 less 文件开发中通常会用到一门预处理语言，这里以less为例，通过less-loader可以打包 less 为 css 文件 1npm install less less-loader -D 新建 src/assets/style/index.less, 并且在 src/index.js 中引入 import &#39;./assets/style/index.less&#39; 配置 webpack.config.js 123456789101112131415161718192021222324const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] // 添加css中的浏览器前缀 &#125; &#125;, 'less-loader' ] &#125; ] &#125; //...&#125; 执打包命令后就可以发现 index.less 中写的样式会和color.css一样被打包进 main.css中。 webpack@v4 升级踩坑: 关于使用 mini-css-extract-plugin 的注意点。 打包图片1npm install file-loader url-loader -D file-loader: 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。 url-loader:如果图片较多，会发很多 http 请求，会降低页面性能。url-loader 会将引入的图片编码，生成 dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl，大于 limit 的还会使用 file-loader 进行 copy。 url-loader 可以看作是增强版的 file-loader。 url-loader 把图片编码成 base64 格式写进页面，从而减少服务器请求。 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; outputPath: 'images/', //输出到images文件夹 limit: 500 //是把小于500B的文件打成Base64的格式，写入JS &#125; &#125; ] &#125; ] &#125; //...&#125; url-loader 和 file-loader 是什么关系呢？ 简单地说，url-loader 封装了 file-loader。url-loader 不依赖于 file-loader，即使用 url-loader 时，只需要安装 url-loader 即可，不需要安装 file-loader，因为 url-loader 内置了 file-loader。 通过上面的介绍，我们可以看到，url-loader 工作分两种情况： 文件大小小于 limit 参数，url-loader 将会把文件转为 DataURL； 文件大小大于 limit，url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。因此我们只需要安装 url-loader 即可。 有关 url-loader 和 file-loader 的解析：webpack 之图片引入-增强的 file-loader：url-loader 配置 babelbabel-loaderBabel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 Babel 7 的相关依赖包需要加上 @babel scope。一个主要变化是 presets 设置由原来的 env 换成了 @babel/preset-env, 可以配置 targets, useBuiltIns 等选项用于编译出兼容目标环境的代码。其中 useBuiltIns 如果设为 &quot;usage&quot;，Babel 会根据实际代码中使用的 ES6/ES7 代码，以及与你指定的 targets，按需引入对应的 polyfill，而无需在代码中直接引入 import &#39;@babel/polyfill&#39;，避免输出的包过大，同时又可以放心使用各种新语法特性。 1npm i babel-loader @babel/core @babel/preset-env -D 笔者这里配的版本号如下 12345&#123; \"babel-loader\": \"^8.0.4\", \"@babel/core\": \"^7.1.2\", \"@babel/preset-env\": \"^7.1.0\"&#125; babel-loader: 用 babel 转换 ES6 代码需要使用到 babel-loader @babel-preset-env： 默认情况下是等于 ES2015 + ES2016 + ES2017，也就是说它对这三个版本的 ES 语法进行转化。 @babel/core：babel 核心库 根目录下新建 .babelrc 文件 1234567891011121314&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125;, \"useBuiltIns\": \"usage\" &#125; ] ]&#125; presets 是一堆 plugins 的预设，起到方便的作用。 plugins 是编码转化工具，babel 会根据你配置的插件对代码进行相应的转化。 修改 webpack.config.js 1234567891011121314module.exports = &#123; module: &#123; rules: [ //... &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader' &#125; &#125; ] &#125;&#125; babel/polyfill 和 transform-runtime Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 babel-polyfill: 如上述所说，对于新的 API，你可能需要引入 babel-polyfill 来进行兼容 关键点 babel-polyfill 是为了模拟一个完整的 ES2015+环境，旨在用于应用程序而不是库/工具。 babel-polyfill 会污染全局作用域 babel-runtime 的作用： 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 _extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。 提供 polyfill：不会污染全局作用域，但是不支持实例方法如 Array.includes babel-runtime 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 polyfill，你只需使用，transform-runtime 会帮你引入。 对于开发应用来说，直接使用上述的按需 polyfill 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合（babel-polyfill 是通过向全局对象和内置对象的 prototype 上添加方法实现的，会造成全局变量污染）。Babel 提供了另外一种方案 transform-runtime，它在编译过程中只是将需要 polyfill 的代码引入了一个指向 core-js 中对应模块的链接(alias)。关于这两个方案的具体差异和选择，可以自行搜索相关教程，这里不再展开，下面提供一个 transform-runtime 的参考配置方案。 首先安装 runtime 相关依赖 12npm i @babel/plugin-transform-runtime -Dnpm i @babel/runtime -S 修改 .babelrc 1234&#123; //... \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 打包前清理源目录文件 clean-webpack-plugin每次打包，都会生成项目的静态资源，随着某些文件的增删，我们的 dist 目录下可能产生一些不再使用的静态资源，webpack 并不会自动判断哪些是需要的资源，为了不让这些旧文件也部署到生产环境上占用空间，所以在 webpack 打包前最好能清理 dist 目录。 1npm install clean-webpack-plugin -D 修改 webpack.config.js 文件 1234const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125; 提取公用代码假如你 a.js 和 b.js 都 import 了 c.js 文件，这段代码就冗杂了。为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。 12345678910111213141516171819202122232425262728293031module.exports = &#123; //... optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; // 抽离自己写的公共代码 chunks: 'initial', name: 'common', // 打包后的文件名，任意命名 minChunks: 2, //最小引用2次 minSize: 0 // 只要超出0字节就生成一个新包 &#125;, styles: &#123; name: 'styles', // 抽离公用样式 test: /\\.css$/, chunks: 'all', minChunks: 2, enforce: true &#125;, vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125; &#125; &#125; &#125;&#125; hashhash 是干嘛用的？我们每次打包出来的结果可能都是同一个文件，那我上线的时候是不是要替换掉上线的 js，那我怎么知道哪是最新的呢，我们一般会清一下缓存。而 hash 就是为了解决这个问题而存在的 我们此时在改一些 webpack.config.js 的配置 1234567891011121314module.exports = &#123; //... output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js' &#125;, //... plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[hash:8].css', chunkFilename: '[id].[hash:8].css' &#125;) ]&#125; 减少 resolve 的解析，配置别名如果我们可以精简 resolve 配置，让 webpack 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 webpack 的构建速度也会快一些 123456789101112131415161718192021module.exports = &#123; resolve: &#123; /** * alias: 别名的配置 * * extensions: 自动解析确定的扩展, * 比如 import 'xxx/theme.css' 可以在extensions 中添加 '.css'， 引入方式则为 import 'xxx/theme' * @default ['.wasm', '.mjs', '.js', '.json'] * * modules 告诉 webpack 解析模块时应该搜索的目录 * 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索 * 这样配置在某种程度上可以简化模块的查找，提升构建速度 @default node_modules 优先 */ alias: &#123; '@': path.resolve(__dirname, 'src'), tool$: path.resolve(__dirname, 'src/utils/tool.js') // 给定对象的键后的末尾添加 $，以表示精准匹配 &#125;, extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'], modules: [path.resolve(__dirname, 'src'), 'node_modules'] &#125;&#125; webpack-dev-serve上面讲到了都是如何打包文件，但是开发中我们需要一个本地服务，这时我们可以使用 webpack-dev-server 在本地开启一个简单的静态服务来进行开发。 webpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果。… 1npm install webpack-dev-server -D package.json 中 scripts 中添加 1&quot;start&quot;: &quot;webpack-dev-server --mode development&quot; 默认开启一个本地服务的窗口 http://localhost:8080/ 便于开发 配置开发服务器我们可以对 webpack-dev-server 做针对性的配置 123456789module.exports = &#123; // 配置开发服务器 devServer: &#123; port: 1234, open: true, // 自动打开浏览器 compress: true // 服务器压缩 //... proxy、hot &#125;&#125; contentBase: 服务器访问的根目录（可用于访问静态资源） port: 端口 open: 自动打开浏览器 模块热替换(hot module replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 上面我们 npm start 后修改一次文件，页面就会刷新一次。这样就存在很大问题了，比如我们使用 redux, vuex 等插件，页面一刷新那么存放在 redux, vuex 中的东西就会丢失，非常不利于我们的开发。 HMR 配合 webpack-dev-server ，首先我们配置下 webpack.config.js 123456789101112const webpack = require('webpack')module.exports = &#123; devServer: &#123; //... hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() //... ]&#125; 配置后还不行，因为 webpack 还不知道你要更新哪里, 修改 src/index.js 文件, 添加 123if (module.hot) &#123; module.hot.accept()&#125; 重启服务，npm start 之后，修改引入 index.js 文件后，页面就不会重新刷新了，这便实现了 HMR 但是但是有个问题是，你修改 css/less 等样式文件并未发生改变， what ? HMR 修改样式表 需要借助于 style-loader， 而我们之前用的是 MiniCssExtractPlugin.loader， 这也好办，修改其中一个 rules 就可以了，我们可以试试改 123456789101112131415161718192021module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/, use: [ // MiniCssExtractPlugin.loader, 'style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] // 添加css中的浏览器前缀 &#125; &#125;, 'less-loader' ] &#125; ] &#125;&#125; 这样我们修改 less 文件就会发现 HMR 已经实现了。 其实，我们可以发现，dev 下配置的 loader 为 style-loader , 而生产环境下则是需要 MiniCssExtractPlugin.loader 这就涉及到了不同环境之间的配置。可以通过 process.env.NODE_ENV 获取当前是开发环境或者是生产环境，然后配置不同的 loader，这里就不做展开了。下一篇文章打算在做一个 react-cli 或者 vue-cli 的配置，将开发环境的配置与生产环境的配置分开为不同的文件。 结语前面讲到的知识都是 webpack 的一些基础的知识，更多的资料可以查询webpack 中文官网，官网讲的比较详细，我这里也是讲最常的配置，也是一篇入门系列的文章，文中涉及的知识点还有很多地方还需要完善，譬如 优化 webpack 的构建速度， 减小打包的体积等等。 学习 webpack 4.0 还需要多实践，多瞎搞，笔者也是刚刚学习 webpack 的配置，不对之处请各位指出。 下一篇文章打算从零配置一个脚手架，以加深自己对 webpack 的理解。 本文产生的代码：webpack-dev 参考 webpack4.x 入门一篇足矣 Webpack4 不深不浅的实践教程 webpack 之 babel 配置和 HMR 使用 webpack 4 和 Babel 7 配置 Vue.js 工程模板 webpack 4 ：从 0 配置到项目搭建 webpack 详解 手写一个 webpack4.0 配置 Webpack 4 教程：从零配置到生产发布（2018） Webpack 揭秘——走向高阶前端的必经之路 珠峰架构师培训公开课 webpack4.0 进阶 webpack 官网","categories":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://gershonv.github.io/tags/webpack/"}]},{"title":"vscode-react 快捷键","slug":"vscode-react","date":"2018-10-10T12:56:32.000Z","updated":"2019-01-03T15:13:07.042Z","comments":true,"path":"2018/10/10/vscode-react/","link":"","permalink":"https://gershonv.github.io/2018/10/10/vscode-react/","excerpt":"插件 React/Redux/react-router Snippets import 相关 imr =&gt; import React from &#39;react&#39; imrc =&gt; import React, { Component } from &#39;react&#39; impt =&gt; import PropTypes from &#39;prop-types&#39; imc =&gt; import ${1:componentName} from &#39;./Components/${1:componentName}&#39; imconnect =&gt; import { connect } from ‘react-redux’","text":"插件 React/Redux/react-router Snippets import 相关 imr =&gt; import React from &#39;react&#39; imrc =&gt; import React, { Component } from &#39;react&#39; impt =&gt; import PropTypes from &#39;prop-types&#39; imc =&gt; import ${1:componentName} from &#39;./Components/${1:componentName}&#39; imconnect =&gt; import { connect } from ‘react-redux’ Reactrcc =&gt; 创建模板组件1234567891011121314151617181920import React, &#123; Component &#125; from 'react'class componentName extends Component &#123; render() &#123; return &lt;div /&gt; &#125;&#125;export default componentName// orimport React, &#123; Component &#125; from 'react'export default class componentName extends Component &#123; render() &#123; return ( &lt;div&gt;&lt;/div&gt; ) &#125;&#125; rccp 创建带 propsTypes 的模板组件rccp =&gt; class component skeleton with prop types after the class 1234567891011import React, &#123; Component, PropTypes &#125; from 'react'class componentName extends Component &#123; render() &#123; return &lt;div /&gt; &#125;&#125;componentName.propTypes = &#123;&#125;export default componentName rsc 创建无状态组件rsc 1234567import React from 'react'function componentName() &#123; return &lt;div /&gt;&#125;export default componentName rscp 创建无状态组件带 propTypesrscp =&gt; stateless component with prop types skeleton 123456789101112import React from 'react'import PropTypes from 'prop-types'const propTypes = &#123;&#125;function componentName(props) &#123; return &lt;div /&gt;&#125;componentName.propTypes = propTypesexport default componentName con 构造函数1234constructor(props) &#123; super(props)&#125; st 声明 statest =&gt; Creates empty state object with ES7 synTax 1state = &#123;&#125; 生命周期 cwm→ componentWillMount method cdm→ componentDidMount method cwr→ componentWillReceiveProps method scu→ shouldComponentUpdate method cwup→ componentWillUpdate method cdup→ componentDidUpdate method cwun→ componentWillUnmount method ren render 方法1234567render() &#123; return ( &lt;div&gt; &lt;/div&gt; )&#125; sst =&gt; this.setState({})ssf =&gt; this.setState(()=&gt;{})123this.setState((state, props) =&gt; &#123; return &#123;&#125;&#125;) PropTypes 检查 pta→ PropTypes.array ptar→ PropTypes.array.isRequired ptb→ PropTypes.bool ptbr→ PropTypes.bool.isRequired ptbr→ PropTypes.bool.isRequired ptf→ PropTypes.func ptfr→ PropTypes.func.isRequired ptn→ PropTypes.number ptnr→ PropTypes.number.isRequired pto→ PropTypes.object. ptor→ PropTypes.object.isRequired pts→ PropTypes.string ptsr→ PropTypes.string.isRequired ptnd→ PropTypes.node ptndr→ PropTypes.node.isRequired ptel→ PropTypes.element ptelr→ PropTypes.element.isRequired redux rat =&gt; export const = &#39;&#39; types rac =&gt; actionCreator 1234export const actionCreator = payload =&gt; (&#123; type: actionType, payload&#125;) reducer 12345678export const reducerName = (state = , action) =&gt; &#123; switch (action.type) &#123; case 'ACTION_TYPE': return default: return state &#125;&#125; container 123456789101112import &#123; connect &#125; from 'react-redux'import component from '../components/component'import &#123; actionCreator &#125; from '../actionPath'const mapStateToProps = (state, ownProps) =&gt; (&#123;&#125;)const mapDispatchToProps = &#123;&#125;export default connect( mapStateToProps, mapDispatchToProps)(component)","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://gershonv.github.io/categories/开发工具/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://gershonv.github.io/tags/vscode/"}]},{"title":"react - 高阶组件","slug":"react-hoc","date":"2018-09-28T14:58:45.000Z","updated":"2019-01-03T15:05:37.169Z","comments":true,"path":"2018/09/28/react-hoc/","link":"","permalink":"https://gershonv.github.io/2018/09/28/react-hoc/","excerpt":"高阶函数高阶函数（Higher Order Function）=&gt; 参数或返回值为函数高阶组件：以组件作为参数的组件，结果 return 一个组件。 简单的例子: 1234567function add(a, b, fn) &#123; return fn(a) + fn(b)&#125;var fn = function(a) &#123; return a * a&#125;add(2, 3, fn) //13 还有一些我们平时常用高阶的方法,如： Map、Reduce、Filter、Sort；以及现在常用的 redux 中的 connect 方法也是高阶函数。 函数柯里化 Currying：是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术 简单的例子： 1234567891011var add = function(x) &#123; return function(y) &#123; return function(z) &#123; console.log('curr', x, y, z) return x + y + z &#125; &#125;&#125;console.log(add(1)(5)(5)) //11console.log(add(1)(5)) //如果传两个参数，则会把第三个函数返回出来 Function","text":"高阶函数高阶函数（Higher Order Function）=&gt; 参数或返回值为函数高阶组件：以组件作为参数的组件，结果 return 一个组件。 简单的例子: 1234567function add(a, b, fn) &#123; return fn(a) + fn(b)&#125;var fn = function(a) &#123; return a * a&#125;add(2, 3, fn) //13 还有一些我们平时常用高阶的方法,如： Map、Reduce、Filter、Sort；以及现在常用的 redux 中的 connect 方法也是高阶函数。 函数柯里化 Currying：是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术 简单的例子： 1234567891011var add = function(x) &#123; return function(y) &#123; return function(z) &#123; console.log('curr', x, y, z) return x + y + z &#125; &#125;&#125;console.log(add(1)(5)(5)) //11console.log(add(1)(5)) //如果传两个参数，则会把第三个函数返回出来 Function 高阶组件 A higher-order component is a function that takes a component and returns a new component 先来一个最简单的高阶组件 123456789101112131415161718192021222324//===&gt; demoimport React, &#123; Component &#125; from 'react'import simpleHoc from './simpleHoc';class Demo extends Component &#123; render() &#123; return &lt;div&gt;223&lt;/div&gt; &#125;&#125;export default simpleHoc(Demo)//===&gt; simpleHocimport React, &#123; Component &#125; from 'react'const simpleHoc = WrappedComponent =&gt; class extends Component &#123; render() &#123; console.log('simple') return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;export default simpleHoc 装饰器模式高阶组件可以看做是装饰器模式(Decorator Pattern)在 React 的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种 ES7 中添加了一个 decorator 的属性，使用@符表示，可以更精简的书写。那上面的例子就可以改成： 123456789101112//===&gt; demoimport React, &#123; Component &#125; from 'react'import simpleHoc from './simpleHoc'@simpleHocclass Demo extends Component &#123; render() &#123; return &lt;div&gt;223&lt;/div&gt; &#125;&#125;export default Demo 当然兼容性是存在问题的，通常都是通过 babel 去编译的。 babel 提供了 plugin，高阶组件用的是类装饰器，所以用 transform-decorators-legacy ps vscode 中使用 Experimental Decorators 报错 属性代理模式引入里我们写的最简单的形式，就是属性代理(Props Proxy)的形式。通过 hoc 包装 wrappedComponent，demo 组件中可以通过 props 直接操作包装传递的属性 123456789101112131415161718192021222324252627282930313233// ===&gt; demoimport React, &#123; Component &#125; from 'react'import simpleHoc from './simpleHoc'@simpleHocclass Demo extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.handleClick&#125;&gt;onClick&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Demo// ===&gt; simpleHocimport React, &#123; Component &#125; from 'react'const simpleHoc = WrappedComponent =&gt; class extends Component &#123; handleClick = () =&gt; &#123; alert(1) &#125; render() &#123; console.log('simple') return &lt;WrappedComponent &#123;...this.props&#125; handleClick=&#123;this.handleClick&#125; /&gt; &#125; &#125;export default simpleHoc 抽离 state这里不是通过 ref 获取 state， 而是通过 { props, 回调函数 } 传递给 wrappedComponent 组件，通过回调函数获取 state。这里用的比较多的就是 react 处理表单的时候。通常 react 在处理表单的时候，一般使用的是受控组件，即把 input 都做成受控的，改变 value 的时候，用 onChange 事件同步到 state 中。当然这种操作通过 Container 组件也可以做到，具体的区别放到后面去比较。看一下代码就知道怎么回事了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ===&gt; demoimport React, &#123; Component &#125; from 'react'import simpleHoc from './simpleHoc'@simpleHocclass Demo extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;input name=\"username\" &#123;...this.props.getField('username')&#125; /&gt; &lt;br /&gt; &lt;input name=\"password\" &#123;...this.props.getField('password')&#125; /&gt; &lt;button onClick=&#123;this.props.handleSubmit&#125;&gt;submit&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Demo// ===&gt; hocimport React, &#123; Component &#125; from 'react'const simpleHoc = WrappedComponent =&gt; class extends Component &#123; constructor() &#123; super() this.state = &#123; fields: &#123;&#125; &#125; &#125; onChange = key =&gt; e =&gt; &#123; let &#123; fields &#125; = this.state fields[key] = e.target.value this.setState(&#123; fields &#125;) &#125; getField = fieldName =&gt; &#123; return &#123; onChange: this.onChange(fieldName) &#125; &#125; handleSubmit = () =&gt; &#123; console.log(this.state.fields) &#125; render() &#123; const props = &#123; ...this.props, getField: this.getField, handleSubmit: this.handleSubmit &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt; &#125; &#125;export default simpleHoc 这里我们把 state，onChange 等方法都放到 HOC 里，其实是遵从的 react 组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到 Container。比如说我们在 HOC 获取到用户名密码之后，再去做其他操作，就方便多了，而 state，处理函数放到 Form 组件里，只会让 Form 更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。 反向继承反向继承(Inheritance Inversion)，简称 II，跟属性代理的方式不同的是，II 采用通过 去继承 WrappedComponent，本来是一种嵌套的关系，结果 II 返回的组件却继承了 WrappedComponent，这看起来是一种反转的关系。 通过继承 WrappedComponent，除了一些静态方法，包括生命周期，state，各种 function，我们都可以得到。上栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ===&gt; demoimport React, &#123; Component &#125; from 'react'import simpleHoc from './simpleHoc'@simpleHocclass Demo extends Component &#123; constructor() &#123; super() this.state = &#123; name: 'demo' &#125; &#125; componentDidMount() &#123; // 不执行, 执行hoc中的生命周期，hoc 中无此生命周期才执行这个组件的周期 console.log(this.state) &#125; render() &#123; this.hocMethods() // run hocMthods console.log(this.state) // &#123;mixinName: \"hoc\", name: \"demo\"&#125; return &lt;div&gt;demo&lt;/div&gt; &#125;&#125;export default Demo// ===&gt; simpleHocimport React, &#123; Component &#125; from 'react'const simpleHoc = WrappedComponent =&gt; class extends WrappedComponent &#123; constructor(props) &#123; super(props) this.state = &#123; hocState: 'hoc', ...this.state &#125; &#125; componentDidMount() &#123; console.log(this.state) &#125; hocMethods = () =&gt; &#123; console.log('run hocMthods') &#125; render() &#123; return super.render() &#125; &#125;export default simpleHoc simpleHoc return 的组件通过继承，拥有了 demo 的生命周期及属性，所以 didMount 会打印，state 也通过 constructor 执行，得到 state.name。 渲染劫持这里 HOC 里定义的组件继承了 WrappedComponent 的 render(渲染)，我们可以以此进行 hijack(劫持)，也就是控制它的 render 函数。栗子： 1234567891011121314151617181920212223242526272829303132333435// ===&gt; demoimport React, &#123; Component &#125; from 'react'import simpleHoc from './simpleHoc'@simpleHoc(&#123; type: 'add-style', style: &#123; color: 'red' &#125; &#125;)class Demo extends Component &#123; constructor() &#123; super() this.state = &#123; name: 'demo' &#125; &#125; render() &#123; return &lt;div&gt;demo&lt;/div&gt; &#125;&#125;export default Demo// ===&gt; simpleHocimport React, &#123; Component &#125; from 'react'const simpleHoc = config =&gt; WrappedComponent =&gt; class extends WrappedComponent &#123; render() &#123; const &#123; style = &#123;&#125; &#125; = config const elementsTree = super.render() if (config.type === 'add-style') &#123; return &lt;div style=&#123;&#123; ...style &#125;&#125;&gt;&#123;elementsTree&#125;&lt;/div&gt; &#125; return elementsTree &#125; &#125;export default simpleHoc 我这里通过二阶函数，把 config 参数预制进 HOC， 算是一种柯理化的思想。 栗子很简单，这个 hoc 就是添加样式的功能。但是它暴露出来的信息却不少。首先我们可以通过 config 参数进行逻辑判断，有条件的渲染，当然这个参数的作用很多，react-redux 中的 connect 不就是传入了 props-key 嘛。再就是我们还可以拿到 WrappedComponent 的元素树，可以进行修改操作。最后就是我们通过 div 包裹，设置了 style。但其实具体如何操作还是根据业务逻辑去处理的… 参考：React 进阶之高阶组件","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"正则表达式","slug":"js-regexp","date":"2018-08-24T16:39:14.000Z","updated":"2019-01-03T15:11:03.294Z","comments":true,"path":"2018/08/25/js-regexp/","link":"","permalink":"https://gershonv.github.io/2018/08/25/js-regexp/","excerpt":"匹配出现次数 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。 {m,n}，表示连续出现最少 m 次，最多 n 次。 123var regx = /ab&#123;2,5&#125;c/var string = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'string.match(regex) // =&gt; [\"abbc\", \"abbbc\", \"abbbbc\", \"abbbbbc\"] 匹配范围 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 123var regex = /a[123]b/gvar string = 'a0b a1b a2b a3b a4b'console.log(string.match(regex)) // =&gt; [\"a1b\", \"a2b\", \"a3b\"] [123] : 匹配 123 中任意一位数 [^123] : 匹配除 1 2 3 之外的任意一个字符 123var regx = /[^123]/regx.test('12') // falseregx.test('1234') // true [a-zA-Z] : 匹配 26 位字母 [0-9] : 匹配数字范围 /.^/ : 不匹配任何东西","text":"匹配出现次数 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。 {m,n}，表示连续出现最少 m 次，最多 n 次。 123var regx = /ab&#123;2,5&#125;c/var string = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'string.match(regex) // =&gt; [\"abbc\", \"abbbc\", \"abbbbc\", \"abbbbbc\"] 匹配范围 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 123var regex = /a[123]b/gvar string = 'a0b a1b a2b a3b a4b'console.log(string.match(regex)) // =&gt; [\"a1b\", \"a2b\", \"a3b\"] [123] : 匹配 123 中任意一位数 [^123] : 匹配除 1 2 3 之外的任意一个字符 123var regx = /[^123]/regx.test('12') // falseregx.test('1234') // true [a-zA-Z] : 匹配 26 位字母 [0-9] : 匹配数字范围 /.^/ : 不匹配任何东西 贪婪匹配与惰性匹配123var regex = /\\d&#123;2,5&#125;/gvar string = '123 1234 12345 123456'console.log(string.match(regex)) // =&gt; [\"123\", \"1234\", \"12345\", \"12345\"] 其中正则 /\\d{2,5}/，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。 但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就要 3 个。反正只要在能力范围内，越多越好。 我们知道有时贪婪不是一件好事, 而惰性匹配，就是尽可能少的匹配： 123var regex = /\\d&#123;2,5&#125;?/gvar string = '123 1234 12345 123456'console.log(string.match(regex)) // =&gt; [\"12\", \"12\", \"34\", \"12\", \"34\", \"12\", \"34\", \"56\"] 其中 /\\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。 通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下： 惰性量词 贪婪量词 {m,n}? {m,n} {m,}? {m,} ?? ? +? + _? _ 对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？ 匹配多项 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 例如要匹配”good”和”nice”可以使用/good|nice/。测试如下： 123var regex = /good|nice/gvar string = 'good idea, nice try.'console.log(string.match(regex)) // =&gt; [\"good\", \"nice\"] 但有个事实我们应该注意，比如我用/good|goodbye/，去匹配”goodbye”字符串时，结果是”good”： 1234567var regex = /good|goodbye/gvar string = \"goodbye\"console.log( string.match(regex) ) // =&gt; [\"good\"]// 而把正则改成/goodbye|good/，结果是：var regex2 = /goodbye|good/gconsole.log( string.match(regex) ) // =&gt; [\"goodbye\"] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 匹配位置 ^ : 匹配开头 $ : 匹配结尾 \\b : 匹配单词边界 \\B : 匹配非单词边界 (?=p) : 匹配 p 前面的位置 (?!p) : 匹配 p 后面的位置 ^ $ 123// 字符串的开头和结尾用\"#\"替换：var result = \"hello\".replace(/^|$/g, '#')console.log(result) // =&gt; \"#hello#\" \\b \\B 12var result = \"[JS] Lesson_01.mp4\".replace(/\\b/g, '#')console.log(result) // =&gt; \"[#JS#] #Lesson_01#.#mp4#\" (?=p)(?!p) 12var result = \"hello\".replace(/(?=l)/g, '#') // \"he#l#lo\"var result2 = \"hello\".replace(/(?!l)/g, '#') // \"#h#ell#o#\" 数字的千位分隔符表示法 1var result = \"12345678\".replace(/(?=\\d&#123;3&#125;$)/g, ',') // 12,345,678 分组我们知道/a+/匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用/(ab)+/。 其中括号是提供分组功能，使量词+作用于“ab”这个整体，测试如下： 123var regex = /(ab)+/gvar string = 'ababa abbb ababab'console.log(string.match(regex)) // =&gt; [\"abab\", \"ab\", \"ababab\"] 引用分组 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。 12345678var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/var string = \"2017-06-12\"string.replace(regex, ($1, $2, $3) =&gt; &#123; console.log($1, $2, $3) // 2017-06-12 2017 06&#125;)var result = string.replace(regex, '$2/$3/$1') // 06/12/2017 … 实战 0 ≤ x ≤ 50 整数: /^(\\d|[1-4]\\d|50)$/g -1000 ≤ x ≤ 1000 : /^-?(\\d{1,3}|1000)$/ -1000 ≤ x ≤ 2000 : /^-?(\\d{1,3}|1000)$|^(1\\d{3}|2000)$/ 匹配数字范围参考JS正则表达式完整教程（略长）","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"regexp","slug":"regexp","permalink":"https://gershonv.github.io/tags/regexp/"}]},{"title":"react-redux","slug":"react-redux","date":"2018-08-07T14:42:05.000Z","updated":"2019-01-03T15:06:58.344Z","comments":true,"path":"2018/08/07/react-redux/","link":"","permalink":"https://gershonv.github.io/2018/08/07/react-redux/","excerpt":"ruduxredux 运行流程图： 简单概述：click -&gt; store.dispatch(action) -&gt; reduer -&gt; newState -&gt; viewUpdate react-readux 中 通过 connect 链接组件和 redux , this.props.dispatch() 调用 后面将会讲到… redux 依赖包也是十分的简洁先来个demo","text":"ruduxredux 运行流程图： 简单概述：click -&gt; store.dispatch(action) -&gt; reduer -&gt; newState -&gt; viewUpdate react-readux 中 通过 connect 链接组件和 redux , this.props.dispatch() 调用 后面将会讲到… redux 依赖包也是十分的简洁先来个demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const redux = require('redux')const createStore = redux.createStoreconst types = &#123; UPDATE_NAME: 'UPDATE_NAME'&#125;const defaultStore = &#123; user: 'tom'&#125;/** * reducer 纯函数 接收一个state,返回一个新的state * @param &#123;Object&#125; state * @param &#123;Object&#125; action [type] 必选参数 * @return newState * */function getUser(state = defaultStore, action) &#123; const &#123; type, payload &#125; = action let res = Object.assign(&#123;&#125;, defaultStore) switch (type) &#123; case types.UPDATE_NAME: res.user = payload.name break default: return res &#125; return res&#125;const store = createStore(getUser)/** * listener * */store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;)/** * dispatch(action) action * */store.dispatch(&#123; type: types.UPDATE_NAME, payload: &#123; name: '大帅哥' &#125;&#125;)//@log &#123; name: '大帅哥' &#125; 用户发出 action 【store.dispatch(action)】 Store 自动调用 Reducer , 返回新的 state 【let nextState = getUser(previousState, action)】 State 一旦有变化，Store 就会调用监听函数 【store.subscribe(listener)】 运行过程如下： storeStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store常用方法： store.dispatch() ：分发 action 较为常用 store.subscribe() : state 发生变化后立即执行 store.getState() : 获取 store 中存着的 state createStorecreateStore 如其名，创建 store 下面是该方法的部分源码： 12345678910111213141516171819202122232425262728/** * @param &#123;Function&#125; reducer 函数 * @param &#123;any&#125; [preloadedState] The initial state * @param &#123;Function&#125; [enhancer] The store enhancer * @returns &#123;Store&#125; * */export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; // ... return &#123; dispatch, // 分发 action subscribe, // 监听器 getState, // 获取 store 的 state 值 replaceReducer, [$$observable]: observable // 供Redux内部使用 &#125;&#125; preloadedState: 初始化的initialState，第二个参数不是Object,而是Function，createStore会认为你忽略了preloadedState而传入了一个enhancer createStore会返回enhancer(createStore)(reducer, preloadedState)的调用结果，这是常见高阶函数的调用方式。在这个调用中enhancer接受createStore作为参数，对createStore的能力进行增强，并返回增强后的createStore dispatch(action)diapatch 是 store 对象的方法，主要用来分发 action , redux 规定 action 一定要包含一个 type 属性，且 type 属性也要唯一 dispatch 是 store 非常核心的一个方法，也是我们在应用中最常使用的方法，下面是 dispatch 的源码 ： 12345678910111213141516171819202122232425262728293031function dispatch(action) &#123; if (!isPlainObject(action)) &#123; // 校验了action是否为一个原生js对象 throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.') &#125; if (typeof action.type === 'undefined') &#123; // action对象是否包含了必要的type字段 throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?') &#125; if (isDispatching) &#123; // 判断当前是否处于某个action分发过程中, 主要是为了避免在reducer中分发action throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; // 在一系列检查完毕后，若均没有问题，将当前的状态和action传给当前reducer，用于生成新的state return action&#125; reducer &amp;&amp; store.replaceReducerRedux 中负责响应 action 并修改数据的角色就是reducer，reducer的本质实际上是一个函数replaceReducer: 12345678910111213/** * @desc 替换当前的reducer的函数 * @param &#123;Function&#125; * @return &#123;void&#125; */function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;)&#125; replaceReducer 使用场景： 当你的程序要进行代码分割的时候 当你要动态的加载不同的 reducer 的时候 当你要实现一个实时 reloading 机制的时候 中间件 middleware以上介绍了 redux 的实现流的过程，应用场景无非于 button – click –&gt; disptch – action –&gt; reducer – newState –&gt; view 但是这种实现方式是基于同步的方式的，日常开发中当然少不了 http 这些异步请求，这种情况下必须等到服务器数据返回后才重新渲染 view, 显然某些时候回阻塞页面的展示。 举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对 store.dispatch 进行如下改造。 123456let next = store.dispatchstore.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action) next(action) console.log('next state', store.getState())&#125; 上面代码中，对 store.dispatch 进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。 中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 applyMiddlewareRedux 提供了applyMiddleware来装载middleware：它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。 123456789101112131415161718192021222324252627/** * @param &#123;...Function&#125; middlewares * returns &#123;Function&#125; A store enhancer applying the middleware */export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 所有中间件被放进了一个数组 chain，然后嵌套执行，最后执行 store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法 compose 实际上是函数式编程中的组合，接收多个函数体并且将其组合成一个新的函数，例如compose 后 [fn1, fn2…] 依次从右到左嵌套执行函数 而compose用于applyMiddleware 也是为了组合中间件dispatch = compose(…chain)(store.dispatch)==&gt;dispatch=fn1(fn2(fn3(store.dispatch))) 123456789101112131415/** * @param &#123;...Function&#125; funcs The functions to compose. * @returns &#123;Function&#125; A function obtained by composing the argument functions */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; redux-thunk上面的中间件的介绍可以知道redux 通过 applyMiddleware 来装载中间件，通过 compose 方法可以组合函数 异步的问题可以通过 redux-thunk 解决，用法也不难 react 组件中使用相关如下： 1234567891011121314151617181920212223242526272829// 配置 redux 加上这个...import &#123; createStore, applyMiddleware, compose &#125; from 'redux'import thunk from 'redux-thunk'// ...const store = createStore(getUser, compose(applyMiddleware(thunk)))// react 中使用import &#123; connect &#125; from 'react-redux'handleClick = () =&gt; &#123; this.props.dispatch(dispatch =&gt; &#123; return axios.get('https://randomuser.me/api/').then(res =&gt; &#123; dispatch(&#123; type: types.CHANGE_ARRAY, payload: &#123; name: res.data.results[0].name.title &#125; &#125;) &#125;) &#125;)&#125;const mapStateToProps = (state, props) =&gt; &#123; return &#123; name: state.demo.name &#125;&#125;export default connect(mapStateToProps)(Demo) 处理异步的还有很多插件 如 redux-soga 等，楼主并未实践过，所以不做延伸… react-redux下面是在 react 中使用的代码的雏形： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; createStore &#125; from 'redux'let defaultState = &#123; count: 1&#125;/** * Reducer * */function demoReducer(state = defaultState, action = &#123;&#125;) &#123; const &#123; type, payload &#125; = action const res = Object.assign(&#123;&#125;, state) if (type === 'changeCount') &#123; res.count = payload.count &#125; return res&#125;/** * @Store 存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 * combineReducers(&#123; ...reducers &#125;) 可以组合多个reducer * */const store = createStore( demoReducer, window.devToolsExtension &amp;&amp; window.devToolsExtension() // 配置redux 开发工具)// ... 根元素下配置下 Providerimport &#123; Provider &#125; from 'react-redux'ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'))// 组件中使用import &#123; connect &#125; from 'react-redux'//usethis.dispatch(&#123; type: 'changeCount', payload: &#123; count: 22 &#125;&#125;)const mapStateToProps = (state, props) =&gt; &#123; return &#123; name: state.demo.name &#125;&#125;export default connect(mapStateToProps)(Demo) mapStateToProps 用于建立组件跟 store 的 state 的映射关系作为一个函数，它可以传入两个参数，结果一定要返回一个 object 传入mapStateToProps之后，会订阅 store 的状态改变，在每次 store 的 state 发生变化的时候，都会被调用 如果写了第二个参数 props，那么当 props 发生变化的时候，mapStateToProps 也会被调用 mapDispatchToProps mapDispatchToProps用于建立组件跟 store.dispatch 的映射关系 可以是一个 object，也可以传入函数 如果mapDispatchToProps是一个函数，它可以传入 dispatch,props,定义 UI 组件如何发出 action，实际上就是要调用 dispatch 这个方法 1234567891011121314151617181920212223import &#123; connect &#125; from 'react-redux'import &#123; bindActionCreators &#125; from 'redux'// 页面中使用...this.props.changeName()const mapDispatchToProps = (&#123; changeName &#125; = (dispatch, props) =&gt; &#123; return bindActionCreators( &#123; changeName: function() &#123; return &#123; type: types.UPDATE_NAME, payload: &#123; name: '大大大' &#125; &#125; &#125; &#125;, dispatch )&#125;)export default connect(mapDispatchToProps)(App) 模块化配置下面的配置仅供参考。实现的功能： 整合 action、types、reducer 到一个文件 根据开发/生成环境配置不同的 redux 中间件(开发环境配置 dev-tools ) 支持装饰器模式 redux 热加载配置（这里面顺便将 react 热加载配置也加上了） 注意：项目基于 create-react-app eject 后的配置改造实现的。下面用了别名 @ ，需要改下 webpack 的配置，如果你配置不成功。详情可以看我的 github 上面有源码. 链接入口 安装123npm install redux react-redux redux-thunk --savenpm install redux-devtools-extension react-hot-loader -Dnpm install @babel/plugin-proposal-decorators -D 相关文件夹如图： models/demo.jsdemo 模块。 123456789101112131415161718192021222324// typesconst ADD_COUNT = 'ADD_COUNT'// actionsexport const addCount = () =&gt; &#123; return &#123; type: ADD_COUNT &#125;&#125;// stateconst defaultState = &#123; count: 11&#125;// reducerexport const demoReducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case ADD_COUNT: return &#123; ...state, count: ++state.count &#125; default: return state &#125;&#125;export default demoReducer models/index.js模块的导出口。 1234567import &#123; combineReducers &#125; from 'redux'import demo from './demo'export default combineReducers(&#123; demo&#125;) redux/index.jsredux 仓库的总出口 1234567891011121314151617181920212223242526272829import thunk from 'redux-thunk'import &#123; compose, createStore, applyMiddleware &#125; from 'redux'import &#123; composeWithDevTools &#125; from 'redux-devtools-extension'import rootReducer from './models'let storeEnhancersif (process.env.NODE_ENV === 'production') &#123; storeEnhancers = compose(thunk)&#125; else &#123; storeEnhancers = compose(composeWithDevTools(applyMiddleware(thunk)))&#125;const configureStore = (initialState = &#123;&#125;) =&gt; &#123; const store = createStore(rootReducer, initialState, storeEnhancers) if (module.hot &amp;&amp; process.env.NODE_ENV !== 'production') &#123; // Enable Webpack hot module replacement for reducers module.hot.accept('./models', () =&gt; &#123; console.log('replacing reducer...') const nextRootReducer = require('./models').default store.replaceReducer(nextRootReducer) &#125;) &#125; return store&#125;export default configureStore() src/index.jsreact 项目的入口配置。 12345678910111213141516171819202122232425import React from 'react'import ReactDOM from 'react-dom'import &#123; AppContainer &#125; from 'react-hot-loader'import App from './App'import &#123; Provider &#125; from 'react-redux'import store from '@/redux'const render = Component =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;Component /&gt; &lt;/Provider&gt; &lt;/AppContainer&gt;, document.getElementById('root') )&#125;render(App)if (module.hot) &#123; module.hot.accept('./App', () =&gt; &#123; render(App) &#125;)&#125; App.jsx12345678910111213141516171819202122232425262728import React, &#123; Component, Fragment &#125; from 'react'import &#123; connect &#125; from 'react-redux'import &#123; addCount &#125; from '@/redux/models/demo'import &#123; Button &#125; from 'antd'const mapStateToProps = state =&gt; (&#123; count: state.demo.count&#125;)@connect( mapStateToProps, &#123; addCount &#125;)class ReduxTest extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &#123;this.props.count&#125; &lt;Button type=\"primary\" onClick=&#123;this.props.addCount&#125;&gt; Click &lt;/Button&gt; &lt;hr /&gt; &lt;/Fragment&gt; ) &#125;&#125;export default ReduxTest .babelrc配置 babel 装饰器模式 123456&#123; \"presets\": [\"react-app\"], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;] ]&#125; vscode 装饰器模式如果有报警的话，可以根目录下新建 jsconfig.json 123456789101112131415161718&#123; \"compilerOptions\": &#123; \"experimentalDecorators\": true, \"baseUrl\": \"./\", \"paths\": &#123; \"@/*\": [ \"src/*\" ] &#125;, \"jsx\": \"react\" &#125;, \"exclude\": [ \"node_modules\", \"build\", \"config\", \"scripts\" ]&#125; 参考 阮一峰 redux 入门教程 配置文件可以看我的 github : react-demo","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"canvas","slug":"canvas","date":"2018-08-03T13:37:37.000Z","updated":"2019-01-03T15:02:41.632Z","comments":true,"path":"2018/08/03/canvas/","link":"","permalink":"https://gershonv.github.io/2018/08/03/canvas/","excerpt":"基本用法&lt;canvas&gt; 两个可选属性 width 默认300，height 默认150。可以使用css属性来设置宽高，但是如果宽高属性和初始比例不一致，就会出现扭曲。 1234567&lt;style&gt; #canvas&#123; width: 600px; height: 300px; background: #ddd; &#125;&lt;/style&gt; 这种设置canvas宽高会让画布变得模糊这种设置canvas宽高会让画布变得模糊这种设置canvas宽高会让画布变得模糊 better1&lt;canvas id=\"canvas\" width=\"600\" height=\"300\"&gt;&lt;/canvas&gt; 12345678910&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') if (canvas.getContext) &#123; ctx.fillStyle = 'red' ctx.fillRect(0, 0, 200, 200) &#125;&lt;/script&gt; ctx : 渲染上下文。绘制都靠他","text":"基本用法&lt;canvas&gt; 两个可选属性 width 默认300，height 默认150。可以使用css属性来设置宽高，但是如果宽高属性和初始比例不一致，就会出现扭曲。 1234567&lt;style&gt; #canvas&#123; width: 600px; height: 300px; background: #ddd; &#125;&lt;/style&gt; 这种设置canvas宽高会让画布变得模糊这种设置canvas宽高会让画布变得模糊这种设置canvas宽高会让画布变得模糊 better1&lt;canvas id=\"canvas\" width=\"600\" height=\"300\"&gt;&lt;/canvas&gt; 12345678910&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') if (canvas.getContext) &#123; ctx.fillStyle = 'red' ctx.fillRect(0, 0, 200, 200) &#125;&lt;/script&gt; ctx : 渲染上下文。绘制都靠他 绘制绘制矩形 fillReact、clearRect、strokeRect3种绘制矩形的参数都一样，相对画布的 xy坐标以及绘制的宽高 fillRect(x, y, width, height): 绘制一个填充的矩形 strokeRect(x, y, width, height): 绘制一个矩形的边框 clearRect(x, y, width, height): 清除指定矩形区域，让清除部分完全透明123456789101112&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;script&gt; const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') if (canvas.getContext) &#123; ctx.fillStyle = 'red' ctx.fillRect(25,25,200,200); ctx.clearRect(45,45,100,100); ctx.strokeRect(50,50,50,50); &#125;&lt;/script&gt; 绘制线段 moveTo、lineTo、stoke基本使用 moveTo(x,y): 画笔移到Canvas画布中的某个位置 （直线的起点） lineTo(x,y): 把画笔移到另一个点 （直线的终点） stroke()： 有了起点终点最后需要 stroke 方法才可以绘制线段 123ctx.moveTo(50, 50)ctx.lineTo(150, 50)ctx.stroke() 上面代码 花了一条横线。默认黑色 线段粗细 lineWidth1234 ctx.lineWidth = 10ctx.moveTo(50, 50)ctx.lineTo(150, 50)ctx.stroke() 线段颜色 strokeStyle12ctx.strokeStyle = '#f00'//... createLinearGradient 渐变色 （略） 绘制多条线段 beginPath closePath123456ctx.lineWidth = 10ctx.strokeStyle = '#f36';ctx.moveTo(50, 50)ctx.lineTo(150, 50)ctx.lineTo(150, 150)ctx.stroke() 效果图 12345678910111213ctx.lineWidth = 10ctx.strokeStyle = '#f36';ctx.beginPath();ctx.moveTo(50, 50)ctx.lineTo(150, 50)ctx.lineTo(150, 150)ctx.stroke()ctx.closePath()ctx.beginPath()ctx.moveTo(200, 50)ctx.lineTo(200, 150)ctx.stroke()ctx.closePath() 效果图 fill 通过填充路径的内容区域生成实心的图形stroke 绘制线段而fill 可以填充！如下 可以画出个实心三角形12345ctx.beginPath();ctx.moveTo(75,50);ctx.lineTo(100,75);ctx.lineTo(100,25);ctx.fill(); canvas api 网址","categories":[{"name":"HTML-CSS","slug":"HTML-CSS","permalink":"https://gershonv.github.io/categories/HTML-CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://gershonv.github.io/tags/HTML/"},{"name":"canvas","slug":"canvas","permalink":"https://gershonv.github.io/tags/canvas/"}]},{"title":"react - 生命周期","slug":"react-LifeCycle","date":"2018-07-29T13:20:13.000Z","updated":"2019-01-03T15:05:58.421Z","comments":true,"path":"2018/07/29/react-LifeCycle/","link":"","permalink":"https://gershonv.github.io/2018/07/29/react-LifeCycle/","excerpt":"v16.3+ Mounting constructor(props) static getDerivedStateFromProps(props, state) render() componentDidMount() Updating static getDerivedStateFromProps() shouldComponentUpdate(nextProps, nextState) render() getSnapshotBeforeUpdate(prevProps, prevState) componentDidUpdate(prevProps, prevState, snapshot)","text":"v16.3+ Mounting constructor(props) static getDerivedStateFromProps(props, state) render() componentDidMount() Updating static getDerivedStateFromProps() shouldComponentUpdate(nextProps, nextState) render() getSnapshotBeforeUpdate(prevProps, prevState) componentDidUpdate(prevProps, prevState, snapshot) constructor(props)React 组件的构造函数在安装之前被调用。在为 React.Component 子类实现构造函数时，应该在任何其他语句之前调用 super(props)。否则，this.props 将在构造函数中未定义，这可能导致错误。 Avoid copying props into state! This is a common mistake: 12345constructor(props) &#123; super(props) // Don't do this! this.state = &#123; color: props.color &#125;&#125; static getDerivedStateFromProps(nextProps, prevState)props / state 改变时触发，需要返回一个对象或者 null，相当于 setState demo 1234static getDerivedStateFromProps(nextProps, prevState)&#123; if (nextProps.sum !== prevState.sum) return &#123; sum: nextProps.sum &#125; // 类似于 setState(&#123; sum: nextProps.sum &#125;) return null&#125; render()12345render()&#123; // don't do this this.setState(&#123; num: 12 &#125;) return null&#125; componentDidMount()组件挂载后。 shouldComponentUpdate(nextProps, nextState)1shouldComponentUpdate(nextProps, nextState) return true / false 来决定是否重新 render getSnapshotBeforeUpdate(prevProps, prevState)相当于 componentWillUpdate componentDidUpdate(prevProps, prevState, snapshot)更新后 - 这里谨慎使用 setState() v16.3 以下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React, &#123; Component &#125; from 'react'/** * * 挂载数据： * @example constructor =&gt; componentWillMount =&gt; render =&gt; componentDidMount * * 数据变化： * @example props change: componentWillReceiveProps =&gt; shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate * @example state change: shouldComponentUpdate =&gt; componentWillUpdate =&gt; componentDidUpdate * */class LifeCycle extends React.Component &#123; constructor() &#123; super() // 声明constructor时必须调用super方法 this.state = &#123; subNum: 2 &#125; console.log('01 constructor') &#125; componentWillMount() &#123; console.log('02 componentWillMount') &#125; componentDidMount() &#123; console.log('04 componentDidMount') &#125; componentWillReceiveProps(nextProps) &#123; console.log('05 componentWillReceiveProps') &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('06 shouldComponentUpdate') return true // 记得要返回true &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('07 componentWillUpdate') &#125; componentDidUpdate(prevProps, prevState) &#123; console.log('08 componentDidUpdate') &#125; componentWillUnmount() &#123; console.log('09 componentWillUnmount') &#125; changeState = () =&gt; &#123; this.setState(prevState =&gt; (&#123; subNum: ++prevState.subNum &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;change state&lt;/button&gt; &lt;h2&gt;&#123;this.state.subNum&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;class App extends Component &#123; state = &#123; num: 1 &#125; changeProps = () =&gt; &#123; // this.setState((prevState, props) =&gt; (&#123;&#125;)) this.setState(prevState =&gt; (&#123; num: ++prevState.num &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.changeProps&#125;&gt;change props&lt;/button&gt; &lt;hr /&gt; &lt;LifeCycle num=&#123;this.state.num&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"react 入门","slug":"react-basic","date":"2018-07-28T15:03:29.000Z","updated":"2019-01-03T15:08:24.720Z","comments":true,"path":"2018/07/28/react-basic/","link":"","permalink":"https://gershonv.github.io/2018/07/28/react-basic/","excerpt":"123456789101112&lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境中不建议使用 --&gt;&lt;script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example'));&lt;/script&gt; react.min.js - React 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码","text":"123456789101112&lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境中不建议使用 --&gt;&lt;script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example'));&lt;/script&gt; react.min.js - React 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码 使用 create-react-app 快速构建 React 开发环境123cnpm install -g create-react-appcreate-react-app my-appnpm run eject TodoList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123;Component&#125; from 'react';class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; list: [], inputValue: '' &#125; this.handleChange = this.handleChange.bind(this) this.handleBtnClick = this.handleBtnClick.bind(this) &#125; handleChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState( &#123; list: [...this.state.list, this.state.inputValue], inputValue: '' &#125; ) &#125; handleItemClick(index) &#123; let list = [...this.state.list] list.splice(index, 1) this.setState(&#123; list &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleBtnClick&#125; className='btn'&gt;add&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList 组件化todoList 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123;Component&#125; from 'react';import TodoItem from './TodoItem'class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; list: [], inputValue: '' &#125; this.handleChange = this.handleChange.bind(this) this.handleBtnClick = this.handleBtnClick.bind(this) &#125; handleChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState( &#123; list: [...this.state.list, this.state.inputValue], inputValue: '' &#125; ) &#125; handleItemClick(index) &#123; let list = [...this.state.list] list.splice(index, 1) this.setState(&#123;list&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleBtnClick&#125; className='btn'&gt;add&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; // return ( // &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt; // ) return ( &lt;TodoItem key=&#123;index&#125; content=&#123;item&#125; index=&#123;index&#125; delete=&#123;this.handleItemClick.bind(this, index)&#125; /&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList todoItem12345678910111213141516171819import React, &#123;Component&#125; from 'react'; class TodoItem extends Component &#123; constructor(props) &#123; super(props) this.handleDelete = this.handleDelete.bind(this) &#125; // 子组件想要和父组件通信，要调用父组件传递过来的方法 handleDelete(index) &#123; this.props.delete(index) &#125; // 父组件通过属性的形式向子组件传递参数 // 子组件通过props接受父组件传递过来的参数 render() &#123; return ( &lt;li onClick=&#123;this.handleDelete&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt; ) &#125;&#125; export default TodoItem","categories":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://gershonv.github.io/tags/React/"}]},{"title":"实现简易的 VUE-MVVM","slug":"vue-mvvm","date":"2018-07-16T14:19:09.000Z","updated":"2019-01-03T15:13:23.318Z","comments":true,"path":"2018/07/16/vue-mvvm/","link":"","permalink":"https://gershonv.github.io/2018/07/16/vue-mvvm/","excerpt":"前言这是本人的学习的记录，因为最近在准备面试，很多情况下会被提问到：请简述 mvvm ?一般情况下我可能这么答：mvvm 是视图和逻辑的一个分离，是model view view-model 的缩写，通过虚拟dom的方式实现双向数据绑定（我随便答得） 那么问题来了，你知道 mvvm 是怎么实现的？回答: mvvm 主要通过 Object 的 defineProperty 属性，重写 data 的 set 和get 函数来实现。 ok，回答得60分，那么你知道具体实现过程么？想想看，就算他没问到而你答了出来是不是更好？前提下，一定要手撸一下简单的mvvm才会对它有印象~ 话不多说，接下来是参考自张仁阳老师的教学视频而作，采用的是ES6语法，其中也包含了我个人的理解，如果能帮助到您，我将十分高兴。如有错误之处，请各位大佬指正出来，不胜感激~~~ 在实现之前，请先了解基本的mvvm的编译过程以及使用 编译的流程图 整体分析 可以发现new MVVM()后的编译过程主体分为两个部分： 一部分是模板的编译 Compile 编译元素和文本，最终渲染到页面中 其中标签中有模板指令的标签才执行编译 例如&lt;div&gt;我很帅&lt;/div&gt; 不执行编译 一部分是数据劫持 Observer Dep 发布订阅，将所有需要通知变化的data添加到一个数组中 Watcher 如果数据发生改变，在Object的defineProperty的set函数中调用Watcher的update方法 明确本文需要实现的目标 实现模板编译的过程 完成Vue实例中的属性可以正确绑定在标签中，并且渲染在页面中 工作：指令的解析，正则替换双大括号 将节点的内容node.textContent或者input的value编译出来 完成数据的双向绑定 工作：通过observe类劫持数据变化 添加发布与订阅：Object.defineProperty 在get钩子中addSub,set钩子中通知变化dep.notify() dep.notify()调用的是Watcher的update方法，也就是说需要在input变化时调用更新","text":"前言这是本人的学习的记录，因为最近在准备面试，很多情况下会被提问到：请简述 mvvm ?一般情况下我可能这么答：mvvm 是视图和逻辑的一个分离，是model view view-model 的缩写，通过虚拟dom的方式实现双向数据绑定（我随便答得） 那么问题来了，你知道 mvvm 是怎么实现的？回答: mvvm 主要通过 Object 的 defineProperty 属性，重写 data 的 set 和get 函数来实现。 ok，回答得60分，那么你知道具体实现过程么？想想看，就算他没问到而你答了出来是不是更好？前提下，一定要手撸一下简单的mvvm才会对它有印象~ 话不多说，接下来是参考自张仁阳老师的教学视频而作，采用的是ES6语法，其中也包含了我个人的理解，如果能帮助到您，我将十分高兴。如有错误之处，请各位大佬指正出来，不胜感激~~~ 在实现之前，请先了解基本的mvvm的编译过程以及使用 编译的流程图 整体分析 可以发现new MVVM()后的编译过程主体分为两个部分： 一部分是模板的编译 Compile 编译元素和文本，最终渲染到页面中 其中标签中有模板指令的标签才执行编译 例如&lt;div&gt;我很帅&lt;/div&gt; 不执行编译 一部分是数据劫持 Observer Dep 发布订阅，将所有需要通知变化的data添加到一个数组中 Watcher 如果数据发生改变，在Object的defineProperty的set函数中调用Watcher的update方法 明确本文需要实现的目标 实现模板编译的过程 完成Vue实例中的属性可以正确绑定在标签中，并且渲染在页面中 工作：指令的解析，正则替换双大括号 将节点的内容node.textContent或者input的value编译出来 完成数据的双向绑定 工作：通过observe类劫持数据变化 添加发布与订阅：Object.defineProperty 在get钩子中addSub,set钩子中通知变化dep.notify() dep.notify()调用的是Watcher的update方法，也就是说需要在input变化时调用更新 分解 Vue 实例如何入手？首先从怎么使用Vue开始。让我们一步步解析Vue的使用： 123456let vm = new Vue(&#123; el: '#app' data: &#123; message: 'hello world' &#125;&#125;) 上面代码可以看出使用Vue,我们是先new 一个Vue 实例，传一个对象参数，包含 el 和 data。 ok，以上得到了信息，接下来让我们实现目标1：将Vue实例的data编译到页面中 实现 Complie 编译模板的过程先看看页面的使用：index.html1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"jsonText.text\"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &#123;&#123;jsonText.text&#125;&#125;&lt;/div&gt;&lt;script src=\"./watcher.js\"&gt;&lt;/script&gt;&lt;script src=\"./observer.js\"&gt;&lt;/script&gt;&lt;script src=\"./compile.js\"&gt;&lt;/script&gt;&lt;script src=\"./vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; message: 'gershonv', jsonText:&#123; text: 'hello Vue' &#125; &#125; &#125;)&lt;/script&gt; 第一步当然是添加Vue类作为一个入口文件。 vue 类-入口文件的添加新建一个vue.js文件，其代码如下构造函数中定义$el和$data，因为后面的编译要使用到 123456789101112class Vue &#123; constructor(options) &#123; this.$el = options.el; // 挂载 this.$data = options.data; // 如果有要编译的模板就开始编译 if (this.$el) &#123; // 用数据和元素进行编译 new Compile(this.$el, this) &#125; &#125;&#125; 这里暂时未添加数据劫持obeserve，实现目标1暂时未用到，后续再添加 编译需要 el 和相关数据，上面代码执行后会有编译，所以我们新建一个执行编译的类的文件 这里在入口文件vue.js中new了一个Compile实例，所以接下来新建compile.js Compile 类-模板编译的添加Compile 需要做什么？我们知道页面中操作dom会消耗性能，所以可以把dom移入内存处理： 先把真实的 dom 移入到内存中 （在内存中操作dom速度比较快） 怎么放在内存中？可以利用文档碎片 fragment 编译 compile(fragment){} 提取想要的元素节点和文本节点 v-model 双大括号，然后进行相关操作。 把编译好的fragment塞回页面里去12345678910111213141516171819202122232425262728293031323334class Compile &#123; constructor(el, vm) &#123; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; if (this.el) &#123;// 如果这个元素能获取到 我们才开始编译 // 1.先把这些真实的DOM移入到内存中 fragment[文档碎片] let fragment = this.node2fragment(this.el) // 2.编译 =&gt; 提取想要的元素节点 v-model 和文本节点 &#123;&#123;&#125;&#125; this.compile(fragment) // 3.编译好的fragment在塞回页面里去 this.el.appendChild(fragment) &#125; &#125; /* 专门写一些辅助的方法 */ isElementNode(node) &#123; // 判断是否为元素及节点，用于递归遍历节点条件 return node.nodeType === 1; &#125; /* 核心方法 */ node2fragment(el) &#123; // 将el的内容全部放入内存中 // 文档碎片 let fragment = document.createDocumentFragment(); let firstChild; while (firstChild = el.firstChild) &#123; // 移动DOM到文档碎片中 fragment.appendChild(firstChild) &#125; return fragment; &#125; compile(fragment) &#123; &#125;&#125; 编译的过程就是把我们的数据渲染好，表现在视图中 编译过程 compile(fragment) 第一步：获取元素的节点，提取其中的指令或者模板双大括号 首先需要遍历节点，用到了递归方法，因为有节点嵌套的关系，isElementNode 代表是节点元素，也是递归的终止的判断条件。 第二步：分类编译指令的方法compileElement 和 编译文本双大括号的方法 compileElement 对v-model、v-text等指令的解析 compileText 编译文本节点 双大括号12345678910111213141516171819class Compile&#123; // ... compile(fragment) &#123; // 遍历节点 可能节点套着又一层节点 所以需要递归 let childNodes = fragment.childNodes Array.from(childNodes).forEach(node =&gt; &#123; if (this.isElementNode(node)) &#123; // 是元素节点 继续递归 // 这里需要编译元素 this.compileElement(node); this.compile(node) &#125; else &#123; // 文本节点 // 这里需要编译文本 this.compileText(node) &#125; &#125;) &#125;&#125; compileElement &amp;&amp; compileText 取出元素的属性 node.attributes 先判断是否包含指令 判断指令类型(v-html v-text v-model...) 调用不一样的数据更新方法 这里提取了编译的工具对象 CompileUtil 调用方法: CompileUtil[type](node, this.vm, expr) CompileUtil.类型(节点，实例，v-XX 绑定的属性值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Compile&#123; // ... // 判断是否是指令 ==&gt; compileElement 中递归标签属性中使用 isDirective(name) &#123; return name.includes('v-') &#125; compileElement(node) &#123; // v-model 编译 let attrs = node.attributes; // 取出当前节点的属性 Array.from(attrs).forEach(attr =&gt; &#123; let attrName = attr.name; // 判断属性名是否包含 v- if (this.isDirective(attrName)) &#123; // 取到对应的值，放到节点中 let expr = attr.value; // v-model v-html v-text... let [, type] = attrName.split('-') CompileUtil[type](node, this.vm, expr); &#125; &#125;) &#125; compileText(node) &#123; // 编译 &#123;&#123;&#125;&#125; let expr = node.textContent; //取文本中的内容 let reg = /\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g; if (reg.test(expr)) &#123; CompileUtil['text'](node, this.vm, expr) &#125; &#125; // compile(fragment)&#123;...&#125;&#125;CompileUtil = &#123; getVal(vm, expr) &#123; // 获取实例上对应的数据 expr = expr.split('.'); // 处理 jsonText.text 的情况 return expr.reduce((prev, next) =&gt; &#123; return prev[next] // 譬如 vm.$data.jsonText.text、vm.$data.message &#125;, vm.$data) &#125;, getTextVal(vm, expr) &#123; // 获取文本编译后的结果 return expr.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g, (...arguments) =&gt; &#123; return this.getVal(vm, arguments[1]) &#125;) &#125;, text(node, vm, expr) &#123; // 文本处理 参数 [节点, vm 实例, 指令的属性值] let updateFn = this.updater['textUpdater']; let value = this.getTextVal(vm, expr) updateFn &amp;&amp; updateFn(node, value) &#125;, model(node, vm, expr) &#123; // 输入框处理 let updateFn = this.updater['modelUpdater']; updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) &#125;, updater: &#123; // 文本更新 textUpdater(node, value) &#123; node.textContent = value &#125;, // 输入框更新 modelUpdater(node, value) &#123; node.value = value; &#125; &#125;&#125; 到现在为止 就完成了数据的绑定，也就是说new Vue 实例中的 data 已经可以正确显示在页面中了，现在要解决的就是如何实现双向绑定 结合开篇的vue编译过程的图可以知道我们还少一个observe 数据劫持，Dep通知变化,添加Watcher监听变化, 以及最终重写data属性 实现双向绑定Observer 类-观察者的添加 在vue.js 中劫持数据 1234567class Vue&#123; //... if(this.$el)&#123; new Observer(this.$data); // 数据劫持 new Compile(this.$el, this); // 用数据和元素进行编译 &#125; &#125; 新建 observer.js 文件 代码步骤： 构造器中添加直接进行 observe 判断data 是否存在, 是否是个对象（new Vue 时可能不写data属性） 将数据一一劫持，获取data中的key和value123456789101112131415161718192021222324252627282930313233343536class Observer &#123; constructor(data) &#123; this.observe(data) &#125; observe(data) &#123; // 要对这个数据将原有的属性改成 set 和 get 的形式 if (!data || typeof data !== 'object') &#123; return &#125; // 将数据一一劫持 Object.keys(data).forEach(key =&gt; &#123; // 劫持 this.defineReactive(data, key, data[key]) this.observe(data[key]) //递归深度劫持 &#125;) &#125; defineReactive(obj, key, value) &#123; let that = this Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; // 取值时调用的方法 return value &#125;, set(newValue) &#123; // 当给data属性中设置的时候，更改属性的值 if (newValue !== value) &#123; // 这里的this不是实例 that.observe(newValue) // 如果是对象继续劫持 value = newValue &#125; &#125; &#125;) &#125;&#125; 虽然有了observer，但是并未关联,以及通知变化。下面就添加Watcher类 Watcher 类的添加新建watcher.js文件 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法 先回忆下watch的用法：this.$watch(vm, &#39;a&#39;, function(){...})我们在添加发布订阅者时需要传入参数有: vm实例，v-XX绑定的属性, cb回调函数（getVal 方法拷贝了之前 CompileUtil 的方法，其实可以提取出来的…） 12345678910111213141516171819202122232425262728293031323334class Watcher &#123; // 观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法 // this.$watch(vm, 'a', function()&#123;...&#125;) constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; // 先获取下老的值 this.value = this.get(); &#125; getVal(vm, expr) &#123; // 获取实例上对应的数据 expr = expr.split('.'); return expr.reduce((prev, next) =&gt; &#123; //vm.$data.a return prev[next] &#125;, vm.$data) &#125; get() &#123; let value = this.getVal(this.vm, this.expr); return value &#125; // 对外暴露的方法 update()&#123; let newValue = this.getVal(this.vm, this.expr); let oldValue = this.value if(newValue !== oldValue)&#123; this.cb(newValue); // 对应 watch 的callback &#125; &#125;&#125; Watcher 定义了但是还没有调用，模板编译的时候，需要调观察的时候观察一下Compile1234567891011121314151617181920212223242526272829303132333435class Compile&#123; //...&#125;CompileUtil = &#123; //... text(node, vm, expr) &#123; // 文本处理 参数 [节点, vm 实例, 指令的属性值] let updateFn = this.updater['textUpdater']; let value = this.getTextVal(vm, expr) updateFn &amp;&amp; updateFn(node, value) expr.replace(/\\&#123;\\&#123;([^&#125;]+)\\&#125;\\&#125;/g, (...arguments) =&gt; &#123; new Watcher(vm, arguments[1], () =&gt; &#123; // 如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容 updateFn &amp;&amp; updateFn(node, this.getTextVal(vm, expr)) &#125;) &#125;) &#125;, //... model(node, vm, expr) &#123; // 输入框处理 let updateFn = this.updater['modelUpdater']; // 这里应该加一个监控，数据变化了，应该调用watch 的callback new Watcher(vm, expr, (newValue) =&gt; &#123; // 当值变化后会调用cb 将newValue传递过来（） updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) &#125;); node.addEventListener('input', e =&gt; &#123; let newValue = e.target.value; this.setVal(vm, expr, newValue) &#125;) updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) &#125;, //...&#125; 实现了监听后发现变化并没有通知到所有指令绑定的模板或是双大括号，所以我们需要Dep 监控、实例的发布订阅属性的一个类，我们可以添加到observer.js中 Dep 类的添加注意 第一次编译的时候不会调用Watcher，dep.target不存在,new Watcher的时候target才有值有点绕，看下面代码：123456789101112131415161718192021222324class Watcher &#123; constructor(vm, expr, cb) &#123; //... this.value = this.get() &#125; get()&#123; Dep.target = this; let value = this.getVal(this.vm, this.expr); Dep.target = null; return value &#125; //...&#125;// compile.jsCompileUtil = &#123; model(node, vm, expr) &#123; // 输入框处理 //... new Watcher(vm, expr, (newValue) =&gt; &#123; // 当值变化后会调用cb 将newValue传递过来（） updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)) &#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536class Observer&#123; //... defineReactive(obj, key, value)&#123; let that = this; let dep = new Dep(); // 每个变化的数据 都会对应一个数组，这个数组存放所有更新的操作 Object.defineProperty(obj, key, &#123; //... get()&#123; Dep.target &amp;&amp; dep.addSub(Dep.target) //... &#125; set(newValue)&#123; if (newValue !== value) &#123; // 这里的this不是实例 that.observe(newValue) // 如果是对象继续劫持 value = newValue; dep.notify(); //通知所有人更新了 &#125; &#125; &#125;) &#125;&#125;class Dep &#123; constructor() &#123; // 订阅的数组 this.subs = [] &#125; addSub(watcher) &#123; this.subs.push(watcher) &#125; notify() &#123; this.subs.forEach(watcher =&gt; watcher.update()) &#125;&#125; 以上代码 就完成了发布订阅者模式,简单的实现。。也就是说双向绑定的目标2已经完成了 结语板门弄斧了，本人无意哗众取宠，这只是一篇我的学习记录的文章。想分享出来，这样才有进步。如果这篇文章帮助到您，我将十分高兴。有问题可以提issue，有错误之处也希望大家能提出来，非常感激。 具体源码我放在了我的github了，有需要的自取。源码链接","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/tags/Vue-js/"},{"name":"MVVM","slug":"MVVM","permalink":"https://gershonv.github.io/tags/MVVM/"}]},{"title":"ES6 - Class","slug":"es6-class","date":"2018-07-16T14:19:09.000Z","updated":"2019-01-03T15:03:39.418Z","comments":true,"path":"2018/07/16/es6-class/","link":"","permalink":"https://gershonv.github.io/2018/07/16/es6-class/","excerpt":"简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function() &#123; return '(' + this.x + ', ' + this.y + ')'&#125;var p = new Point(1, 2) ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x // this 代表实例对象 this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125;","text":"简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function() &#123; return '(' + this.x + ', ' + this.y + ')'&#125;var p = new Point(1, 2) ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x // this 代表实例对象 this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125; constructor: 构造方法，类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。 一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。 this: 关键对象 定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 12345678910111213141516class Point &#123; // ...&#125;typeof Point // \"function\" ==&gt; 类的数据类型就是函数Point === Point.prototype.constructor // true ==&gt; 类本身就指向构造函数// 定义与使用class Bar &#123; doStuff() &#123; console.log('stuff') &#125;&#125;var b = new Bar() // new 默认执行Bar类的 constructor 方法，该方法默认返回实例对象 即thisb.doStuff() // \"stuff\" 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 1234567891011121314151617181920class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;&#125; 在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B()b.constructor === B.prototype.constructor // true 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。 123456789101112131415class Point &#123; constructor() &#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString() &#123;&#125;, toValue() &#123;&#125;&#125;)// prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的Point.prototype.constructor === Point // trueObject.keys(Point.prototype) // [] ==&gt; 类的内部所有定义的方法，都是不可枚举的（non-enumerable）这一点与 ES5 的行为不一致 类的属性名，可以采用表达式。 1234567891011let methodName = 'getArea'class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 类的实例对象与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 1234567891011121314151617181920//定义类class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125;var point = new Point(2, 3)point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true hasOwnProperty: 查找对象原型上是否有某属性 （上面代码表示 toString 保存在Point类中，point 是通过原型链获得 toString 方法） Class 表达式与函数一样，类也可以使用表达式的形式定义。 12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name // 内部可以使用到这个类Me &#125;&#125;// 这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类let inst = new MyClass()inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 123const MyClass = class &#123; /* ... */&#125; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; console.log(this.name) &#125;&#125;('张三')person.sayName() // \"张三\" 私有方法和私有属性私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 在命名上加以区别: 123456789101112131415lass Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125;// 不保险的，在类的外部，还是可以调用到这个方法 将私有方法移出模块，因为模块内部的所有方法都是对外可见的: 1234567891011class Widget &#123; foo(baz) &#123; bar.call(this, baz) &#125; // ...&#125;function bar(baz) &#123; return (this.snaf = baz)&#125; 上面代码中，foo 是公有方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法。 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值: 1234567891011121314151617onst bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar 和 snaf 都是 Symbol 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 123456789101112131415class Logger &#123; printName(name = 'there') &#123; // this 默认指向 Logger this.print(`Hello $&#123;name&#125;`) &#125; print(text) &#123; console.log(text) &#125;&#125;const logger = new Logger()const &#123; printName &#125; = loggerprintName() // TypeError: Cannot read property 'print' of undefined// this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 解决办法 在构造方法中绑定this 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this) &#125; // ...&#125; 箭头函数 12345678class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`) &#125; &#125; // ...&#125; 使用Proxy，获取方法的时候，自动绑定this 12345678910111213141516171819unction selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); getter setter与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter' &#125; set prop(value) &#123; console.log('setter: ' + value) &#125;&#125;let inst = new MyClass()inst.prop = 123// setter: 123inst.prop// 'getter' 存值函数和取值函数是设置在属性的 Descriptor 对象上的 Class 的 Generator 方法todo // 对 Generator 不熟悉，待下次理解了在写 Class 的静态方法静态方法：不会被实例继承，而是直接通过类来调用。 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用 1234567891011class Foo &#123; static classMethod() &#123; return 'hello' &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo()foo.classMethod()// TypeError: foo.classMethod is not a function 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 12345678910111213class Foo &#123; static bar() &#123; this.baz() &#125; static baz() &#123; console.log('hello') &#125; baz() &#123; console.log('world') &#125;&#125;Foo.bar() // hello 父类的静态方法，可以被子类继承。 123456789class Foo &#123; static classMethod() &#123; return 'hello' &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 静态方法也是可以从super对象上调用的 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello' &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too' &#125;&#125;Bar.classMethod() // \"hello, too\" Class 的静态属性和实例属性静态属性：Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 1234class Foo &#123;&#125;Foo.prop = 1Foo.prop // 1 ES6 明确规定，Class 内部只有静态方法，没有静态属性 写法无效如下： 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 类的实例属性类的实例属性可以用等式，写入类的定义之中 1234567class MyClass &#123; myProp = 42 constructor() &#123; console.log(this.myProp) // 42 &#125;&#125; 类的静态属性类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 12345678class MyClass &#123; static myStaticProp = 42 constructor() &#123; console.log(MyClass.myStaticProp) // 42 &#125;&#125;var p = new MyClass() // p 中实例属性没有 myStaticProp","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://gershonv.github.io/tags/ES6/"}]},{"title":"面试题积累","slug":"随笔-面试","date":"2018-07-16T12:46:54.000Z","updated":"2019-01-03T15:14:26.103Z","comments":true,"path":"2018/07/16/随笔-面试/","link":"","permalink":"https://gershonv.github.io/2018/07/16/随笔-面试/","excerpt":"Javascript正则 匹配正整数 1234567var str = '102'// 1. ^(-|\\+) 以 - 或者 + 开头// 2. ? 表示出现或者不出现// 3. [1-9] 取值范围，也是首字符的取值范围// 4. \\d*$ ：* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。var reg = /^(-|\\+)?[1-9]\\d*$/reg.test(str) 用正则吧[1,2,3,4]转换成 &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;","text":"Javascript正则 匹配正整数 1234567var str = '102'// 1. ^(-|\\+) 以 - 或者 + 开头// 2. ? 表示出现或者不出现// 3. [1-9] 取值范围，也是首字符的取值范围// 4. \\d*$ ：* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。var reg = /^(-|\\+)?[1-9]\\d*$/reg.test(str) 用正则吧[1,2,3,4]转换成 &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39; 1;[1, 2, 3, 4].join().replace(/([^,])/g, \"'$1'\") // 逗号结尾的字符分组，加引号 dgfhfgh254bhku289fgdhdy675gfh 输出 [254,289,675] 12345var str = 'dgfhfgh254bhku289fgdhdy675gfh'str.replace(/\\d&#123;3&#125;/g, $1 =&gt; arr.push(+$1)) // 匹配出现3个数字的字符，+$1 转化为整数// question 假如要匹配连续出现的数字呢？ ↓↓↓str.replace(/\\d+/g, $1 =&gt; arr.push(+$1)) // + 匹配至少出现一次的数字 匹配数字范围 12// 限制 1000-2000，整数const reg = /^-?(?:[0-9]&#123;1,3&#125;|1000)$/ 字符串去重，把 aaacabbbccc 变成 abc 1234567var str = 'aaacabbbbcccc'var reg = /(.).*\\1/gstr.replace(reg, '$1')// \\1 表示的引用之前的那个分组 不管它匹配到什么（比如-），\\1都匹配那个同样的具体某个字符。var reg = /(\\w)\\1+/g // 匹配连续出现的字符 匹配一年中的 12 个月 123456var str = '12'var reg = /^(0?[1-9]|1[0-2])$/gconsole.log(reg.test(str))// 首位 0 时，第二位 1-9// 首位 1 时，第二位 0-2 理论补充 非捕获分组 ?: (?:)会作为匹配校验，并出现在匹配结果字符里面，但不作为子匹配返回。 12345var reg1 = /1(2)/var reg2 = /1(?:2)/'12'.match(reg1) // \"12\", \"2\"...'12'.match(reg2) // \"12\", ... 作用域， eventLoop，异步… 经典题 12345678910111213for (var i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000)&#125; // 结果：每一秒输出一个5// settimeout 是异步, 每一秒在任务队列中添加任务。等主线执行完成后再执行任务队列里的任务var =&gt; let // 解决变量作用域// 为for循环头部的let不仅将i绑定到for循环快中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值。// setTimeout里面的function()属于一个新的域，通过 var 定义的变量是无法传入到这个函数执行域中的，通过使用 let 来声明块变量，// 这时候变量就能作用于这个块，所以 function就能使用 i 这个变量了 this 的考察 123456789101112function f() &#123; y = function() &#123; x = 2 &#125; return function() &#123; var x = 3 y() console.log(this.x) &#125;.apply(this, arguments)&#125;f() // 2 变量提升 12345678910111213var a = 1function outer() &#123; var a = 2 function inner() &#123; a++ console.log(a) var a = 3 console.log(a) &#125; inner()&#125;outer() // NaN 3 其他 遍历 html 中所有 dom 节点，并计算 dom 节点数 12345678910111213141516var doms = []function getChildren(parent) &#123; if (parent.children.length &gt; 0) &#123; for (let i = 0; i &lt; parent.children.length; i++) &#123; getChildren(parent.children[i]) &#125; &#125; if (parent.nodeType === 1) &#123; // parent.nodeType === 1：节点是一个元素节点 doms.push(parent) &#125;&#125;getChildren(document)console.log(doms) 随机数 123var random = (m, n) =&gt; m + Math.floor(Math.random() * (n - m))random(1, 4) // 产生 1-4 之间的随机数 实现数组乱序 123456789101112function shuffle(array) &#123; let len = array.length let temp while (len) &#123; const i = Math.floor(Math.random() * len--) temp = array[len] array[len] = array[i] array[i] = temp &#125; return array&#125;shuffle([1, 3, 4, 5, 7])","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://gershonv.github.io/categories/开发随笔/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"https://gershonv.github.io/tags/面试系列/"}]},{"title":"flex 布局","slug":"css-flex","date":"2018-07-11T12:49:40.000Z","updated":"2019-01-03T15:02:55.852Z","comments":true,"path":"2018/07/11/css-flex/","link":"","permalink":"https://gershonv.github.io/2018/07/11/css-flex/","excerpt":"Flex 基本概念 Flex 容器相关属性123.container&#123; display: flex | inline-flex; //可以有两种取值&#125; 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。有下面六种属性可以设置在容器上，它们分别是： flex-direction 功能：决定水平方向的排列方向 参数：row | row-reverse | column | column-reverse flex-wrap 功能：决定容器内项目是否可以换行 参数：nowrap | wrap | wrap-reverse flex-flow 功能：flex-direction、flex-wrap 的简写形式 —&gt; 没什么卵用 参数：&lt;flex-direction&gt; | &lt;flex-wrap&gt; justify-content 功能：定义在水平方向的对齐方式 参数：flex-start | flex-end | center | space-between | space-around align-items 功能：定义了容器内项目的对齐方式 参数：stretch | flex-start | flex-end | center | baseline align-content 功能：定义了多根轴线的对齐方式，如果项目只有一根轴线，则该属性将不起作用 参数：stretch | flex-start | flex-end | center | space-between | space-around 说明 ：参数首位为默认值 ；参数中含有 reverse 的表示反方向","text":"Flex 基本概念 Flex 容器相关属性123.container&#123; display: flex | inline-flex; //可以有两种取值&#125; 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。有下面六种属性可以设置在容器上，它们分别是： flex-direction 功能：决定水平方向的排列方向 参数：row | row-reverse | column | column-reverse flex-wrap 功能：决定容器内项目是否可以换行 参数：nowrap | wrap | wrap-reverse flex-flow 功能：flex-direction、flex-wrap 的简写形式 —&gt; 没什么卵用 参数：&lt;flex-direction&gt; | &lt;flex-wrap&gt; justify-content 功能：定义在水平方向的对齐方式 参数：flex-start | flex-end | center | space-between | space-around align-items 功能：定义了容器内项目的对齐方式 参数：stretch | flex-start | flex-end | center | baseline align-content 功能：定义了多根轴线的对齐方式，如果项目只有一根轴线，则该属性将不起作用 参数：stretch | flex-start | flex-end | center | space-between | space-around 说明 ：参数首位为默认值 ；参数中含有 reverse 的表示反方向 Justify-contentspace-between 两端对齐两端对齐，项目之间的间隔相等，即剩余空间等分成间隙 space-around 项目之间间隔相等每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 align-items建立在主轴为水平方向时测试，即 flex-direction: row ( 默认值 ) stretch 默认值 占满整个容器的高度即如果项目未设置高度或者设为 auto，将占满整个容器的高度。 假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。 flex-start 交叉轴的起点对齐假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如下图显示 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对齐 Flex 项目属性 order 功能：定义项在容器中的排列顺序 参数：Number 即数字 flex-basis 参数: length | auto; flex-grow 功能：定义项目的放大比例 参数：Number flex-shrink 功能：定义了项目的缩小比例 参数：Number flex 功能：flex-grow, flex-shrink 和 flex-basis的简写 none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] align-self 功能：允许单个项目有与其他项目不一样的对齐方式 auto | flex-start | flex-end | center | baseline | stretch order 定义项目在容器中的排列顺序定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。 flex-basis 算主轴是否有多余空间定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间 当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。 flex-grow 定义项目的放大比例默认值为 0，即如果存在剩余空间，也不放大 当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。 flex-shrink 定义了项目的缩小比例默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。 这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。 同理可得： 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小 flex flex-grow, flex-shrink 和 flex-basis的简写flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。同理，如下是等同的：123456.item &#123;flex: 2333 3222 234px;&#125;.item &#123; flex-grow: 2333; flex-shrink: 3222; flex-basis: 234px;&#125; 当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的：123456.item &#123;flex: none;&#125;.item &#123; flex-grow: 0; flex-shrink: 0; flex-basis: auto;&#125; 当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的：123456.item &#123;flex: auto;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: auto;&#125; 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的： flex:1相当于width:100%，就是撑开123456.item &#123;flex: 1;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; align-self: 允许单个项目有与其他项目不一样的对齐方式","categories":[{"name":"HTML-CSS","slug":"HTML-CSS","permalink":"https://gershonv.github.io/categories/HTML-CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://gershonv.github.io/tags/CSS/"},{"name":"flex","slug":"flex","permalink":"https://gershonv.github.io/tags/flex/"}]},{"title":"js - 笔试题收集","slug":"随笔-面试2","date":"2018-07-11T11:57:47.000Z","updated":"2019-01-03T15:14:35.221Z","comments":true,"path":"2018/07/11/随笔-面试2/","link":"","permalink":"https://gershonv.github.io/2018/07/11/随笔-面试2/","excerpt":"提取 get 请求参数有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如`{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}`。 12345678910111213141516171819let str = 'http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2'function test(str) &#123; let params = &#123;&#125; const paramsStr = str.replace(/.*\\?/, '') // 提取参数字符串 // [ 'a=1', 'b=2', 'c=', 'd=xxx', 'e' ] paramsStr.split('&amp;').forEach(v =&gt; &#123; d = v.split('=') // [a, 1] [b, 2] [c, ''] [d, xxx] [e] if (d[0] in params) &#123; Array.isArray(params[d[0]]) ? params[d[0]].push(d[1]) : (params[d[0]] = [params[d[0]], d[1]]) &#125; else &#123; params[d[0]] = d[1] &#125; &#125;) return params&#125;console.log(test(str)) // &#123; a: [ '1', '2' ], b: '2', c: '', d: 'xxx', e: undefined &#125; 数组降维","text":"提取 get 请求参数有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如`{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}`。 12345678910111213141516171819let str = 'http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2'function test(str) &#123; let params = &#123;&#125; const paramsStr = str.replace(/.*\\?/, '') // 提取参数字符串 // [ 'a=1', 'b=2', 'c=', 'd=xxx', 'e' ] paramsStr.split('&amp;').forEach(v =&gt; &#123; d = v.split('=') // [a, 1] [b, 2] [c, ''] [d, xxx] [e] if (d[0] in params) &#123; Array.isArray(params[d[0]]) ? params[d[0]].push(d[1]) : (params[d[0]] = [params[d[0]], d[1]]) &#125; else &#123; params[d[0]] = d[1] &#125; &#125;) return params&#125;console.log(test(str)) // &#123; a: [ '1', '2' ], b: '2', c: '', d: 'xxx', e: undefined &#125; 数组降维 可以使用 Array.prototype.flat() es6+ 123456let arr = [[1, 2], [3, 4]]let newArr = arr.flat() // [1, 2, 3, 4] 默认降维一层// 手写let newArr2 = Array.prototype.concat.apply([], arr) // [1, 2, 3, 4] js 计算 1234567891011121314const arr = [1, 8, 6, 2, 5, 4, 8, 3, 7]function maxArea(arr) &#123; let [start, area] = [0, 0] let end = arr.length - 1 while (start &lt; end) &#123; const h = Math.min(arr[start], arr[end]) const result = h * (end - start) area = result &gt; area ? result : area arr[start] &gt; arr[end] ? end-- : start++ &#125; return area&#125;console.log(maxArea(arr)) // 49 返回 1 到 400 所有自然数中一共出现过多少次“1”，如 1 到 21 一共出现过 13 次“1” 1234567let count = 0for (let num = 1; num &lt;= number; num++) &#123; ;`$&#123;num&#125;`.replace(/1/g, () =&gt; count++)&#125;console.log(count) // 180 正则给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 123456let str = 'adfdsaccsdd'function containsRepeatingLetter(str) &#123; return /([a-zA-Z])\\1/.test(str) // // \\1指代第一个括号的匹配项&#125;console.log(containsRepeatingLetter(str)) // true 在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\\1 就是引用第一个分组，\\2 就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。 字符串转驼峰例如：border-bottom-color —-&gt; borderBottomColor 1234567891011let str = 'border-bottom-color'function toHump(params) &#123; let newStr = '' params.split('-').forEach((d, i) =&gt; &#123; newStr += i === 0 ? d : `$&#123;d.charAt(0).toUpperCase()&#125;$&#123;d.substring(1)&#125;` &#125;) return newStr&#125;console.log(toHump(str)) // borderBottomColor","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://gershonv.github.io/categories/开发随笔/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"https://gershonv.github.io/tags/面试系列/"}]},{"title":"git 实用指南","slug":"git-command","date":"2018-07-10T13:30:04.000Z","updated":"2019-01-08T12:34:04.383Z","comments":true,"path":"2018/07/10/git-command/","link":"","permalink":"https://gershonv.github.io/2018/07/10/git-command/","excerpt":"commit 规范速查 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 revert: 撤销以前的 commit 1revert: feat(pencil): add 'graphiteWidth' option","text":"commit 规范速查 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 revert: 撤销以前的 commit 1revert: feat(pencil): add 'graphiteWidth' option 本地创建、连接远程仓库123456789# 创建并连接远程仓库mkdir git-democd git-demo/git init# 连接远程仓库git remote add origin https://github.com/gershonv/git-demo.git 新建文件并推向远端1234567891011# 创建 a.jstouch a.js# 添加到暂存区（见下文）git add .# commit 记录（见下文）git commit -m 'feat: 新增 a.js 文件'# 推向远端 master 分支（见下文）git push origin master git add git add [file1 file2 file3...]: 添加多个文件 git add . : 暂存所有文件 git status M - 被修改，A - 被添加，D - 被删除，R - 重命名，?? - 未被跟踪 撤销操作撤销 git add123456789# 新建 b.js 文件touch b.jsgit add .git statis# 撤销 git addgit reset head b.js git reset head : 如果后面什么都不跟的话 就是上一次 add 里面的全部撤销了 git reset head file: 对某个文件进行撤销了 撤销本地修改12345678910111213141516# 修改文件vim a.js# 插入数据shift + i# 保存退出shift + : wq# 加入暂存区git add .git commit -m 'refactor: 修改 a.js 文件'# 撤销修改git checkout -- a.js 撤销 git commit12345# 查看 commit 记录git log# 重置到某个节点。git reset --hard ea794cf0dcf934b594 分支新建分支并推向远程1234567891011# 新建并切换本地分支git checkout -b dev# 查看当前分支git branch# 查看远程分支git branch -r# 推送到远程git push origin dev 合并分支12345678# 开发完 dev 分支后git checkout master# 合并 dev 分支到主分支git merge dev# 推送git push origin master 分支管理123456789# 查看所有分支 远程+本地git branch -a# 删除远程分支git push origin -d dev# 删除本地分支git checkout mastergit branch -d dev","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://gershonv.github.io/categories/开发工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://gershonv.github.io/tags/Git/"}]},{"title":"JavaScript 运行原理解析 - eventLoop 机制","slug":"js-运行原理解析","date":"2018-07-10T13:05:05.000Z","updated":"2019-01-03T15:08:35.723Z","comments":true,"path":"2018/07/10/js-运行原理解析/","link":"","permalink":"https://gershonv.github.io/2018/07/10/js-运行原理解析/","excerpt":"说到JavaScript的运行原理，自然绕不开JS引擎，运行上下文，单线程，事件循环，事件驱动，回调函数等概念。 为了更好的理解JavaScript如何工作的，首先要理解以下几个概念。 JS Engine（JS引擎） Runtime（运行上下文） Call Stack (调用栈) Event Loop（事件循环） Callback (回调)","text":"说到JavaScript的运行原理，自然绕不开JS引擎，运行上下文，单线程，事件循环，事件驱动，回调函数等概念。 为了更好的理解JavaScript如何工作的，首先要理解以下几个概念。 JS Engine（JS引擎） Runtime（运行上下文） Call Stack (调用栈) Event Loop（事件循环） Callback (回调) JS Engine（JS引擎）简单来说，JS引擎主要是对JS代码进行词法、语法等分析，通过编译器将代码编译成可执行的机器码让计算机去执行。 目前最流行的JS引擎非V8莫属了，Chrome浏览器和Node.js采用的引擎就是V8引擎。引擎的结构可以简单由下图表示： 就如JVM虚拟机一样，JS引擎中也有堆(Memory Heap)和栈(Call Stack)的概念。 栈。用来存储方法调用的地方，以及基础数据类型(如var a = 1)也是存储在栈里面的，会随着方法调用结束而自动销毁掉(入栈–&gt;方法调用后–&gt;出栈)。 堆。JS引擎中给对象分配的内存空间是放在堆中的。如var foo = {name: ‘foo’} 那么这个foo所指向的对象是存储在堆中的。 此外，JS中存在闭包的概念，对于基本类型变量如果存在与闭包当中，那么也将存储在堆中。 关于闭包的情况，就涉及到Captured Variables。我们知道Local Variables是最简单的情形，是直接存储在栈中的。而Captured Variables是对于存在闭包情况和with,try catch情况的变量。 1234567891011function foo () &#123; var x; // local variables var y; // captured variable, bar中引用了y function bar () &#123; // bar 中的context会capture变量y use(y); &#125; return bar;&#125; 如上述情况，变量y存在于bar()的闭包中，因此y是captured variable，是存储在堆中的。 Runtime（运行上下文）JS在浏览器中可以调用浏览器提供的API，如window对象，DOM相关API等。这些接口并不是由V8引擎提供的，是存在与浏览器当中的。因此简单来说，对于这些相关的外部接口，可以在运行时供JS调用，以及JS的事件循环(Event Loop)和事件队列(Callback Queue)，把这些称为RunTime。有些地方也把JS所用到的core lib核心库也看作RunTime的一部分。 同样，在Node.js中，可以把Node的各种库提供的API称为RunTime。所以可以这么理解，Chrome和Node.js都采用相同的V8引擎，但拥有不同的运行环境(RunTime Environments) Call Stack (调用栈)JS被设计为单线程运行的，这是因为JS主要用来实现很多交互相关的操作，如DOM相关操作，如果是多线程会造成复杂的同步问题。因此JS自诞生以来就是单线程的，而且主线程都是用来进行界面相关的渲染操作 (为什么说是主线程，因为HTML5 提供了Web Worker，独立的一个后台JS，用来处理一些耗时数据操作。因为不会修改相关DOM及页面元素，因此不影响页面性能)，如果有阻塞产生会导致浏览器卡死。如果一个递归调用没有终止条件，是一个死循环的话，会导致调用栈内存不够而溢出，如： 1234function foo() &#123; foo();&#125;foo(); 例子中foo函数循环调用其本身，且没有终止条件，浏览器控制台输出调用栈达到最大调用次数。 JS线程如果遇到比较耗时操作，如读取文件，AJAX请求操作怎么办？这里JS用到了Callback回调函数来处理。 对于Call Stack中的每个方法调用，都会形成它自己的一个执行上下文Execution Context，关于执行上下文的详细阐述请看这篇文章 Event Loop &amp; CallbackJS通过回调的方式，异步处理耗时的任务。一个简单的例子： 12var result = ajax('...');console.log(result); 此时并不会得到result的值，result是undefined。这是因为ajax的调用是异步的，当前线程并不会等到ajax请求到结果后才执行console.log语句。而是调用ajax后请求的操作交给回调函数，自己是立刻返回。正确的写法应该是： 123ajax('...', function(result) &#123; console.log(result);&#125;) 此时才能正确输出请求返回的结果。 JS引擎其实并不提供异步的支持，异步支持主要依赖于运行环境(浏览器或Node.js)。 所以什么是Event Loop?vent Loop只做一件事情，负责监听Call Stack和Callback Queue。当Call Stack里面的调用栈运行完变成空了，Event Loop就把Callback Queue里面的第一条事件(其实就是回调函数)放到调用栈中并执行它，后续不断循环执行这个操作。 一个setTimeout的例子以及对应的Event Loop动态图： setTimeout有个要注意的地方，如上述例子延迟5s执行，不是严格意义上的5s，正确来说是至少5s以后会执行。因为Web API会设定一个5s的定时器，时间到期后将回调函数加到队列中，此时该回调函数还不一定会马上运行，因为队列中可能还有之前加入的其他回调函数，而且还必须等到Call Stack空了之后才会从队列中取一个回调执行。 所以常见的setTimeout(callback, 0) 的做法就是为了在常规的调用介绍后马上运行回调函数。 123456789console.log('Hi');setTimeout(function() &#123; console.log('callback');&#125;, 0);console.log('Bye');// 输出// Hi// Bye// callback 在说一个容易犯错的栗子：1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; // 输出：5 5 5 5 5 上面这个栗子并不是输出0，1，2，3，4，第一反应觉得应该是这样。但梳理了JS的时间循环后，应该很容易明白。 总结最后总结一下，JS的运行原理主要有以下几个方面： JS引擎主要负责把JS代码转为机器能执行的机器码，而JS代码中调用的一些WEB API则由其运行环境提供，这里指的是浏览器。 JS是单线程运行，每次都从调用栈出取出代码进行调用。如果当前代码非常耗时，则会阻塞当前线程导致浏览器卡顿。 回调函数是通过加入到事件队列中，等待Event Loop拿出并放到调用栈中进行调用。只有Event Loop监听到调用栈为空时，才会从事件队列中从队头拿出回调函数放进调用栈里。 调用栈先执行 for(var i = 0; i &lt; 5; i++) {...}方法，里面的定时器会到时间后会直接把回调函数放到事件队列中，等for循环执行完在依次取出放进调用栈。当for循环执行完时，i的值已经变成5，所以最后输出全都是5。 文章参考自 https://juejin.im/post/5a5d64fbf265da3e243b831f?utm_medium=fe&amp;utm_source=weixinqun","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gershonv.github.io/tags/Javascript/"},{"name":"eventLoop","slug":"eventLoop","permalink":"https://gershonv.github.io/tags/eventLoop/"}]},{"title":"页面重绘和回流以及优化","slug":"随笔-重排和重绘","date":"2018-07-10T12:51:52.000Z","updated":"2019-01-03T15:14:15.780Z","comments":true,"path":"2018/07/10/随笔-重排和重绘/","link":"","permalink":"https://gershonv.github.io/2018/07/10/随笔-重排和重绘/","excerpt":"重绘 redraw &amp; 重排 reflow浏览器运行机制图： 浏览器的运行机制 1.构建DOM树（parse）： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 2.构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）； 3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 4.绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。","text":"重绘 redraw &amp; 重排 reflow浏览器运行机制图： 浏览器的运行机制 1.构建DOM树（parse）： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 2.构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）； 3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 4.绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。 重绘（repaint或redraw）当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。触发重绘的条件：改变元素外观属性。如：color，background-color等。 注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。 重排（重构/回流/reflow）当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如： 页面渲染初始化；(无法避免) 添加或删除可见的DOM元素； 元素位置的改变，或者使用动画； 元素尺寸的改变——大小，外边距，边框； 浏览器窗口尺寸的变化（resize事件发生时）； 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变； 读取某些元素属性：（offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE) ) 重绘重排的代价：耗时，导致浏览器卡慢。 优化 浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改。并减少对style样式的请求。 直接改变元素的className display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排； 不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素； 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document； 尽量不要使用table布局。","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://gershonv.github.io/categories/开发随笔/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://gershonv.github.io/tags/DOM/"}]},{"title":"v-model 浅析","slug":"v-model","date":"2018-07-08T05:45:31.000Z","updated":"2019-01-03T15:13:00.026Z","comments":true,"path":"2018/07/08/v-model/","link":"","permalink":"https://gershonv.github.io/2018/07/08/v-model/","excerpt":"v-model 介绍v-model 只是个语法糖，用于实现数据的双向绑定，实现的原理为 v-bind 绑定value v-on 监听 input 事件 绑定的值发生改变时触发 重新复制给value 如果不理解，请看组件之间的通信。接下来看一段代码 1234&lt;input v-model=\"searchText\"&gt;&lt;!--相当于以下代码--&gt;&lt;input :value=\"searchText\" @input=\"searchText = $event.target.value\"&gt; 同理我们在封装组件时可以利用这个原理 构造 v-model 语法糖，下例我们封装一个my-input 组件：","text":"v-model 介绍v-model 只是个语法糖，用于实现数据的双向绑定，实现的原理为 v-bind 绑定value v-on 监听 input 事件 绑定的值发生改变时触发 重新复制给value 如果不理解，请看组件之间的通信。接下来看一段代码 1234&lt;input v-model=\"searchText\"&gt;&lt;!--相当于以下代码--&gt;&lt;input :value=\"searchText\" @input=\"searchText = $event.target.value\"&gt; 同理我们在封装组件时可以利用这个原理 构造 v-model 语法糖，下例我们封装一个my-input 组件： 123456789101112131415161718192021&lt;template&gt; &lt;input :value=\"content\" @input=\"handleChange($event)\"&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; value: String &#125;, data() &#123; return &#123; content: this.value &#125; &#125;, methods: &#123; handleChange($event) &#123; this.$emit('input', $event.target.value) &#125; &#125; &#125;&lt;/script&gt; ok，简单的封装完成。说明一点，props 的类型为基本类型 如 String、Number、Boolean 等在my-input 组件是不允许修改，而 props 类型为Object、Array等引用类型时可以修改，但是此时数据不再是单向流动。也就是说，你在修改props时也会修改到父组件中的值，简单一句话概括：父子组件数据双向绑定。 .sync 实现父子组件间的双向数据绑定 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。这也是为什么我们推荐以 update:my-prop-name 的模式触发事件取而代之。接着上个例子，在一个包含 value prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：1this.$emit('update:value', newValue) 然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：123456&lt;my-input :value=\"searchText\" @update:value=\"searchText = $event\"&gt;&lt;/my-input&gt;&lt;!--等同于--&gt;&lt;my-input :value.sync=\"searchText\"&gt;&lt;/my-input&gt; my-input 组件的代码12345678910111213141516&lt;template&gt; &lt;input :value=\"value\" @input=\"handleChange($event)\"&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; value: String &#125;, methods: &#123; handleChange($event) &#123; this.$emit('update:value', $event.target.value) &#125; &#125; &#125;&lt;/script&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 自定义单选框：123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;base-checkbox v-model=\"isCheck\"&gt;&lt;/base-checkbox&gt; &#123;&#123;isCheck&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; components: &#123; 'base-checkbox': &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: `&lt;input type=\"checkbox\" :checked=\"checked\" @change=\"$emit('change', $event.target.checked)\"&gt;` &#125; &#125;, data() &#123; return &#123; isCheck: true &#125; &#125;, &#125;&lt;/script&gt; 这里的 isCheck 的值将会传入这个名为 checked 的 prop。同时当 触发一个 change 事件并附带一个新的值的时候，这个 isCheck 的属性将会被更新。","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/tags/Vue-js/"}]},{"title":"封装组件系列 - el 分页表格","slug":"vue-element-table","date":"2018-07-06T16:44:38.000Z","updated":"2019-01-03T15:13:16.461Z","comments":true,"path":"2018/07/07/vue-element-table/","link":"","permalink":"https://gershonv.github.io/2018/07/07/vue-element-table/","excerpt":"前言本次封装基于 antd 风格, 实现高度可配置的表格封装配置。本来想通过 vue.extends 去封装的，奈何几个月没写过 vue ，而且对 vue 的 extends 不熟悉所以放弃了… 之前有小伙伴确实引用了我的代码，发现封装出现了一些纰漏，对此十分抱歉，之前封装的太仓促了。几个月前的代码，现在重新封装又有了新的体会。 更新时间 【2018.11.09】，效果如下： API 说明 columns : 必选, 列描述数据对象， Array dataSource : 必选, 数据数组 options : 必选, 表格参数控制, maxHeight、stripe 等等.. fetch : 获取数据的 Function pagination : 分页信息，不传则不显示分页 row-click ：当某一行被点击时会触发该事件 selection-change : 当选择项发生变化时会触发该事件 其他的 api 可以自行添加 其他说明我在代码注释中写的很清楚了，请自行查看。 根据条件渲染: 只通过 render 去判断参数不同而渲染不一样的表格数据。 render 函数可以渲染任何你想要的组件 值得注意的是，this 对象的绑定不要出错了,如果需要更多增强的功能，各位可以自行添加…","text":"前言本次封装基于 antd 风格, 实现高度可配置的表格封装配置。本来想通过 vue.extends 去封装的，奈何几个月没写过 vue ，而且对 vue 的 extends 不熟悉所以放弃了… 之前有小伙伴确实引用了我的代码，发现封装出现了一些纰漏，对此十分抱歉，之前封装的太仓促了。几个月前的代码，现在重新封装又有了新的体会。 更新时间 【2018.11.09】，效果如下： API 说明 columns : 必选, 列描述数据对象， Array dataSource : 必选, 数据数组 options : 必选, 表格参数控制, maxHeight、stripe 等等.. fetch : 获取数据的 Function pagination : 分页信息，不传则不显示分页 row-click ：当某一行被点击时会触发该事件 selection-change : 当选择项发生变化时会触发该事件 其他的 api 可以自行添加 其他说明我在代码注释中写的很清楚了，请自行查看。 根据条件渲染: 只通过 render 去判断参数不同而渲染不一样的表格数据。 render 函数可以渲染任何你想要的组件 值得注意的是，this 对象的绑定不要出错了,如果需要更多增强的功能，各位可以自行添加… Home.vue 组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;template&gt; &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;CommonTable :columns=\"columns\" :dataSource=\"tableData\" :options=\"options\" :fetch=\"fetchTableData\" :pagination=\"pagination\" @row-click=\"handleRowClick\" @selection-change=\"handleSelectionChange\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'import CommonTable from '../components/Table'export default&#123; components:&#123; CommonTable &#125;, data()&#123; return &#123; columns: [ &#123; prop: 'id', label: '编号', width: 60 &#125;, &#123; prop: 'title', label: '标题', // render 可以根据你想要渲染的方式渲染 // jsx 不提供 v-model 指令，若你想要使用，，推荐使用插件 babel-plugin-jsx-v-model // jsx https://github.com/vuejs/babel-plugin-transform-vue-jsx render: (row, index) =&gt; &#123; return ( &lt;span style=\"color: blue\" onClick=&#123;e =&gt; this.handleClick(e, row)&#125;&gt;&#123;row.title&#125;&lt;/span&gt; ) &#125; &#125;, &#123; prop: 'author', label: '作者' &#125;, &#123; button: true, label: '按钮组', group: [&#123; // you can props =&gt; type size icon disabled plain name: '编辑', type: 'warning', icon: 'el-icon-edit', plain: true, onClick: (row, index) =&gt; &#123; // 箭头函数写法的 this 代表 Vue 实例 console.log(row, index) &#125; &#125;, &#123; name: '删除', type: 'danger', icon: 'el-icon-delete', disabled: false, onClick(row) &#123; // 这种写法的 this 代表 group 里的对象 this.disabled = true console.log(this) &#125; &#125;] &#125; ], tableData: [ &#123; id: 1, title: '标题1', author: '郭大大' &#125;, &#123; id: 2, title: '标题2', author: '郭大大2' &#125; ], pagination: &#123; total: 0, pageIndex: 1, pageSize: 15 &#125;, options: &#123; mutiSelect: true, index: true, // 显示序号， 多选则 mutiSelect loading: false, // 表格动画 initTable: true, // 是否一挂载就加载数据 &#125; &#125; &#125;, methods: &#123; handleClick(e, row)&#123; //transform-vue-jsx 的nativeOnClick 失效 , 所以采用 event.cancelBubble 控制点击事件的冒泡... 如果点击事件不影响你的点击行事件，可以不传 e.cancelBubble = true // 停止冒泡，否则会触发 row-click console.log(row) &#125;, fetchTableData() &#123; this.options.loading = true axios.post('https://www.easy-mock.com/mock/5b3f80edfa972016b39fefbf/example/tableData', &#123; pageIndex: this.pagination.pageIndex, pageSize: this.pagination.pageSize &#125;).then(res =&gt; &#123; const &#123; list, total &#125; = res.data.data this.tableData = list this.pagination.total = total this.options.loading = false &#125;).catch((error) =&gt; &#123; console.log(error) this.options.loading = false &#125;) &#125;, handleRowClick(row, event, column)&#123; // 点击行的事件，同理可以绑定其他事件 console.log('click row:',row, event, column) &#125;, handleSelectionChange(selection)&#123; console.log(selection) &#125; &#125;&#125;&lt;/script&gt; Table.vue 组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;template&gt; &lt;div&gt; &lt;el-table v-loading=\"options.loading\" :data=\"dataSource\" :max-height=\"options.maxHeight\" :stripe=\"options.stripe\" :border=\"options.border\" @row-click=\"handleRowClick\" @selection-change=\"handleSelectionChange\" header-row-class-name=\"table-header-row\"&gt; &lt;!--selection选择框--&gt; &lt;el-table-column v-if=\"options.mutiSelect\" type=\"selection\" style=\"width:50px\" align=\"center\"&gt;&lt;/el-table-column&gt; &lt;!--序号--&gt; &lt;el-table-column v-if=\"options.index\" label=\"序号\" type=\"index\" width=\"50\" align=\"center\"&gt;&lt;/el-table-column&gt; &lt;!--数据列--&gt; &lt;template v-for=\"(column, index) in columns\"&gt; &lt;el-table-column :key=\"index\" :prop=\"column.prop\" :label=\"column.label\" :align=\"column.align||'center'\" :width=\"column.width\" :fixed=\"column.fixed\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;template v-if=\"!column.render\"&gt; &#123;&#123;scope.row[column.prop]&#125;&#125; &lt;/template&gt; &lt;!-- render --&gt; &lt;template v-else&gt; &lt;RenderDom :row=\"scope.row\" :index=\"index\" :render=\"column.render\" /&gt; &lt;/template&gt; &lt;!-- render button --&gt; &lt;template v-if=\"column.button\"&gt; &lt;template v-for=\"(btn, i) in column.group\"&gt; &lt;el-button :key=\"i\" :type=\"btn.type\" :size=\"btn.size || 'mini'\" :icon=\"btn.icon\" :disabled=\"btn.disabled\" :plain=\"btn.plain\" @click.stop=\"btn.onClick(scope.row, scope.$index)\" &gt;&#123;&#123;btn.name&#125;&#125;&lt;/el-button&gt; &lt;/template&gt; &lt;/template&gt; &lt;!-- slot 你可以其他常用项 --&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/template&gt; &lt;/el-table&gt; &lt;!-- 分页 --&gt; &lt;el-pagination v-if=\"pagination\" :total=\"pagination.total\" :page-sizes=\"[20, 50, 100, 500, 5000]\" layout=\"total, sizes, prev, pager, next, jumper\" @size-change=\"handleSizeChange\" @current-change=\"handleIndexChange\" style=\"margin-top: 20px;text-align: right\" &gt;&lt;/el-pagination&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; components: &#123; RenderDom: &#123; functional: true, // 函数式组件 - 无 data 和 this 上下文 =&gt; better render props: &#123; row: Object, index: Number, render: Function &#125;, /** * @param &#123;Function&#125; createElement - 原生创建dom元素的方法， 弃用，推荐使用 jsx * @param &#123;Object&#125; ctx - 渲染的节点的this对象 * @argument 传递参数 row index */ render(createElement, ctx)&#123; const &#123; row, index &#125; = ctx.props return ctx.props.render(row, index) &#125; &#125; &#125;, props:&#123; dataSource: Array, options: Object, // 表格参数控制 maxHeight、stripe 等等... columns: Array, fetch: Function, // 获取数据的函数 pagination: Object // 分页，不传则不显示 &#125;, created() &#123; // 传入的options覆盖默认设置 this.$parent.options = Object.assign(&#123; maxHeight: 500, stripe: true, // 是否为斑马纹 border: true &#125;, this.options) this.options.initTable &amp;&amp; this.fetch() &#125;, methods: &#123; handleSizeChange(size) &#123; // 切换每页显示的数量 this.pagination.pageSize = size this.fetch() &#125;, handleIndexChange(current) &#123; // 切换页码 this.pagination.pageIndex = current this.fetch() &#125;, handleSelectionChange(selection) &#123; this.$emit('selection-change', selection) &#125;, handleRowClick(row, event, column) &#123; this.$emit('row-click', row, event, column) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.el-table th,.el-table tr.table-header-row &#123; background: #e5c5d2; /* 示例， 对表格样式上的修饰 */&#125;&lt;/style&gt; 结语上述代码封装完整性可能不是这么高，但思路在呢，如果需要更多配置，各位可以在进行加强… 吐槽一下，本来是想 props 数据来重写 table 参数，类似 react: 1234567&lt;Home&gt; &lt;ComonTable &#123;...props&#125; &gt;&lt;/Home&gt;// ComonTable&lt;el-table &#123;...props.options&#125;&gt;&lt;/el-table&gt; 所以想到继承，自己又不熟悉。 而且发现 vue 展开绑定多个属性是不可以的： 可能是我没 google 到。如果可以，请大佬告知一声，谢谢 jsx 语法快速入门","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/tags/Vue-js/"},{"name":"element-ui","slug":"element-ui","permalink":"https://gershonv.github.io/tags/element-ui/"}]},{"title":"学习资源集合","slug":"resource","date":"2018-07-05T13:05:05.000Z","updated":"2019-01-03T14:17:53.588Z","comments":true,"path":"2018/07/05/resource/","link":"","permalink":"https://gershonv.github.io/2018/07/05/resource/","excerpt":"","text":"学习链接你不知道的 JavaScript阮一峰的博客廖雪峰的网站大漠追梦子的博客DevOpen.Club - DevOpen.Club 坚持创作并分享原创高质量的软件开发视频教程印记中文webpack 中文网2018 上半年掘金微信群日报优质文章合集：前端篇event Loop解析youtobe视频 - youtube奔三路 面试系列面试图谱 react 小书 常用网站/工具阮一峰ES6入门 - ES6语法速查easy-mock - 模拟数据codelf - 变量命名iconfont - 阿里图标库regexper - 正则可视化 个人常逛网站掘金 - 技术干货segmentfault - 思否，很多很棒的文章简书 - 曾经写过一些学习记录文，觉得更适合写纪实、散文 TODO 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 阿里大神 2018阿里巴巴前端面试总结(题目+答案) Promise之你看得懂的Promise - Promise源码详解 [面试专题]JS设计模式 Vue 2.0 入门系列（15）学习 Vue.js 需要掌握的 es6 (2) 2018前端面试准备 从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ 面试官:请你实现一个深克隆 不要用JWT替代session管理（上）：全面了解Token,JWT,OAuth,SAML,SSO","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://gershonv.github.io/categories/开发工具/"}],"tags":[{"name":"学习资源","slug":"学习资源","permalink":"https://gershonv.github.io/tags/学习资源/"}]},{"title":"Vue render 函数解析","slug":"vue-render","date":"2018-07-04T14:30:48.000Z","updated":"2019-01-03T15:13:35.224Z","comments":true,"path":"2018/07/04/vue-render/","link":"","permalink":"https://gershonv.github.io/2018/07/04/vue-render/","excerpt":"Vue的一些基本概念使用 Vue 编写可复用组件，那么要对 render 函数有所了解。今天我们学习的目的是了解和学习Vue的render函数。如果想要更好的学习Vue的render函数相关的知识，我们有必要重温一下Vue中的一些基本概念。那么先上一张图，这张图从宏观上展现了Vue整体流程：从上图中，不难发现一个Vue的应用程序是如何运行起来的，模板通过编译生成AST，再由AST生成Vue的render函数（渲染函数），渲染函数结合数据生成Virtual DOM树，Diff和Patch后生成新的UI。从这张图中，可以接触到Vue的一些主要概念： 模板：Vue的模板基于纯HTML，基于Vue的模板语法，我们可以比较方便地声明数据和UI的关系。 AST：AST是Abstract Syntax Tree的简称，Vue使用HTML的Parser将HTML模板解析为AST，并且对AST进行一些优化的标记处理，提取最大的静态树，方便Virtual DOM时直接跳过Diff。 渲染函数：渲染函数是用来生成VirtualDOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制 Virtual DOM：虚拟DOM树，Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。 Watcher：每个Vue组件都有一个对应的watcher，这个watcher将会在组件render的时候收集组件所依赖的数据，并在依赖有更新的时候，触发组件重新渲染。你根本不需要写shouldComponentUpdate，Vue会自动优化并更新要更新的UI。","text":"Vue的一些基本概念使用 Vue 编写可复用组件，那么要对 render 函数有所了解。今天我们学习的目的是了解和学习Vue的render函数。如果想要更好的学习Vue的render函数相关的知识，我们有必要重温一下Vue中的一些基本概念。那么先上一张图，这张图从宏观上展现了Vue整体流程：从上图中，不难发现一个Vue的应用程序是如何运行起来的，模板通过编译生成AST，再由AST生成Vue的render函数（渲染函数），渲染函数结合数据生成Virtual DOM树，Diff和Patch后生成新的UI。从这张图中，可以接触到Vue的一些主要概念： 模板：Vue的模板基于纯HTML，基于Vue的模板语法，我们可以比较方便地声明数据和UI的关系。 AST：AST是Abstract Syntax Tree的简称，Vue使用HTML的Parser将HTML模板解析为AST，并且对AST进行一些优化的标记处理，提取最大的静态树，方便Virtual DOM时直接跳过Diff。 渲染函数：渲染函数是用来生成VirtualDOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制 Virtual DOM：虚拟DOM树，Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。 Watcher：每个Vue组件都有一个对应的watcher，这个watcher将会在组件render的时候收集组件所依赖的数据，并在依赖有更新的时候，触发组件重新渲染。你根本不需要写shouldComponentUpdate，Vue会自动优化并更新要更新的UI。 渲染函数的基础Vue推荐在绝大多数情况下使用template来创建你的HTML。然而在一些场景中，需要使用JavaScript的编程能力和创建HTML，这就是render函数，它比template更接近编译器。 12345&lt;h1&gt; &lt;a name=\"hello-world\" href=\"#hello-world\"&gt; Hello world! &lt;/a&gt;&lt;/h1&gt; 在 HTML 层，我们决定这样定义组件接口：1&lt;anchored-heading :level=\"1\"&gt;Hello world!&lt;/anchored-heading&gt; 当我们开始写一个通过 level prop 动态生成 heading 标签的组件，你可能很快想到这样实现：1234567891011121314151617181920212223242526272829303132&lt;!-- HTML --&gt;&lt;script type=\"text/x-template\" id=\"anchored-heading-template\"&gt; &lt;h1 v-if=\"level === 1\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if=\"level === 2\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-else-if=\"level === 3\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-else-if=\"level === 4\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-else-if=\"level === 5\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-else-if=\"level === 6\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt;&lt;/script&gt;&lt;!-- Javascript --&gt;Vue.component('anchored-heading', &#123; template: '#anchored-heading-template', props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 在这种场景中使用 template 并不是最好的选择：首先代码冗长，为了在不同级别的标题中插入锚点元素，我们需要重复地使用 &lt;slot&gt;&lt;/slot&gt;。虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 render 函数重写上面的例子： 1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name 标签名称 this.$slots.default // 子组件中的阵列 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 节点、树以及虚拟DOM在深入渲染函数之前，了解一些浏览器的工作原理是很重要的。以下面这段 HTML 为例： 12345&lt;div&gt; &lt;h1&gt;My title&lt;/h1&gt; Some text content &lt;!-- TODO: Add tagline --&gt;&lt;/div&gt; 当浏览器读到这些代码时，它会建立一个DOM节点树来保持追踪，如果你会画一张家谱树来追踪家庭成员的发展一样。HTML 的 DOM 节点树如下图所示：每个元素都是一个节点。每片文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。高效的更新所有这些节点会是比较困难的，不过所幸你不必再手动完成这个工作了。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里： 1&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt; 或者一个渲染函数里： 123render: function (createElement) &#123; return createElement('h1', this.blogTitle)&#125; 在这两种情况下，Vue 都会自动保持页面的更新，即便 blogTitle 发生了改变。 虚拟 DOMVue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个虚拟DOM的树。当我们有了这个虚拟的树之后，再交给一个Patch函数，负责把这些虚拟DOM真正施加到真实的DOM上。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到数据来源之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新的树与旧的树进行对比，就可以最终得出应施加到真实DOM上的改动。最后再通过Patch函数施加改动。 简单点讲，在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在应该状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上。Vue支持我们通过data参数传递一个JavaScript对象做为组件数据，然后Vue将遍历此对象属性，使用Object.defineProperty方法设置描述对象，通过存取器函数可以追踪该属性的变更，Vue创建了一层Watcher层，在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知Watcher重新计算，从而使它关联的组件得以更新,如下图： 有关于Vue的响应式相关的内容，可以阅读下列文章： 深入理解Vue.js响应式原理 Vue双向绑定的实现原理Object.defineproperty Vue的双向绑定原理及实现 Vue中的响应式 从JavaScript属性描述器剖析Vue.js响应式视图 对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM的一个过程 Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。请仔细看这行代码： 1return createElement('h1', this.blogTitle) createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 Vue组件树建立起来的整个VNode树是唯一的。这意味着，下面的render函数是无效的： 1234567render: function (createElement) &#123; var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ])&#125; 如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落： 1234567render: function (createElement) &#123; return createElement('div', Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement('p', 'hi') &#125;) )&#125; Vue的渲染机制上图展示的是独立构建时的一个渲染流程图。 继续使用上面用到的模板到真实DOM过程的一个图： 这里会涉及到Vue的另外两个概念： 独立构建：包含模板编译器，渲染过程HTML字符串 → render函数 → VNode → 真实DOM节点 运行时构建：不包含模板编译器，渲染过程render函数 → VNode → 真实DOM节点 运行时构建的包，会比独立构建少一个模板编译器。在$mount函数上也不同。而$mount方法又是整个渲染过程的起始点。用一张流程图来说明：由此图可以看到，在渲染过程中，提供了三种渲染模式，自定义render函数、template、el均可以渲染页面，也就是对应我们使用Vue时，三种写法：自定义render函数 1234567891011121314Vue.component('anchored-heading', &#123; render: function(createElement) &#123; return createElement( 'h' + this.level, // tag name标签名称 this.$slots.default // 子组件中的阵列 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) template写法 12345678let app = new Vue(&#123; template: `&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`, data() &#123; return &#123; msg: '' &#125; &#125;&#125;) el写法 12345678let app = new Vue(&#123; el: '#app', data() &#123; return &#123; msg: '' &#125; &#125;&#125;) 这三种渲染模式最终都是要得到render函数。只不过用户自定义的render函数省去了程序分析的过程，等同于处理过的render函数，而普通的template或者el只是字符串，需要解析成AST，再将AST转化为render函数。 记住一点，无论哪种方法，都要得到render函数 理解createElement 参数第一个参数：{String | Object | Function}第一个参数对于createElement而言是一个必须的参数，这个参数可以是字符串string、是一个对象object，也可以是一个函数function。 12345678910111213&lt;div id=\"app\"&gt; &lt;custom-element&gt;&lt;/custom-element&gt;&lt;/div&gt;Vue.component('custom-element', &#123; render: function (createElement)&#123; return createElement('div') &#125;&#125;)let app = new Vue(&#123; el: '#app'&#125;) 上面的示例，给createElement传了一个String参数’div’，即传了一个HTML标签字符。最后会有一个div元素渲染出来。 接着把上例中的String换成一个Object，比如： 1234567Vue.component('custom-element', &#123; render: function (createElement)&#123; return createElement(&#123; template: `&lt;div&gt;Hello Vue&lt;/div&gt;` &#125;) &#125;&#125;) 上例传了一个{template: ‘Hello Vue!‘}对象。此时custom-element组件渲染出来的结果如下： 除此之外，还可以传一个Function，比如： 12345678910Vue.component('custom-element', &#123; render: function (createElement)&#123; var eleFun = function () &#123; return &#123; template: `&lt;div&gt;hello&lt;/div&gt;` &#125; &#125; return createElement(eleFun) &#125;&#125;) 最终得到的结果和上图是一样的。这里传了一个eleFun()函数给createElement，而这个函数返回的是一个对象。第二个参数: {Object}createElement是一个可选参数，这个参数是一个Object。来看一个小示例： 123456789101112131415161718192021222324252627282930&lt;div id=\"app\"&gt; &lt;custom-element&gt;&lt;/custom-element&gt;&lt;/div&gt;Vue.component('custom-element', &#123; render: function (createElement)&#123; // 第一个参数是一个简单的HTML标签字符 “必选” // 第二个参数是一个包含模板相关属性的数据对象 “可选” return createElement('div', &#123; 'class': &#123; foo: true, bar: false &#125;, style: &#123; color: 'red', fontSize: '14px' &#125;, attrs: &#123; id: 'boo' &#125;, domProps: &#123; innerHTML: 'Hello Vue!' &#125; &#125;) &#125;&#125;)let app = new Vue(&#123; el: '#app'&#125;) 最终生成的DOM，将会带一些属性和内容的div元素，如下图所示： 第三个参数：{String | Array}createElement还有第三个参数，这个参数是可选的，可以给其传一个String或Array。比如下面这个小示例： 123456789101112131415161718192021222324252627&lt;div&gt; &lt;custom-element&gt;&lt;/custom-element&gt; &lt;/div&gt;Vue.component('custom-element', &#123; render: function (createElemen) &#123; var self = this return createElement( 'div', // 第一个参数是一个简单的HTML标签字符 “必选” &#123; class: &#123; title: true &#125;, style: &#123; border: '1px solid', padding: '10px' &#125; &#125;, // 第二个参数是一个包含模板相关属性的数据对象 “可选” [ createElement('h1', 'Hello Vue!'), createElement('p', '开始学习Vue') ] // 第三个参数是传了多个子元素的一个数组 “可选” ) &#125;&#125;)let app = new Vue(&#123; el: '#app' &#125;) 最终的效果如下：其实从上面这几个小例来看，不难发现，以往我们使用Vue.component()创建组件的方式，都可以用render函数配合createElement来完成。你也会发现，使用Vue.component()和render各有所长，正如文章开头的一个示例代码，就不适合Vue.component()的template，而使用render更方便。 接下来看一个小示例，看看template和render方式怎么创建相同效果的一个组件: 123456789101112131415161718&lt;div&gt; &lt;custom-element&gt;&lt;/custom-element&gt; &lt;/div&gt;Vue.component('custom-element', &#123; template: `&lt;div id='box' :class='&#123;show: show&#125;' @click='handleClick'&gt;&lt;/div&gt;`, data() &#123; return &#123; show: true &#125; &#125;, methods: &#123; handleClick()&#123; console.log('Clicked!') &#125; &#125;&#125;) 上面Vue.component()中的代码换成render函数之后，可以这样写： 12345678910111213141516171819202122232425262728Vue.component('custom-element', &#123; render: function (createElemen) &#123; return createElement('div', &#123; class: &#123; show: this.show &#125;, attrs: &#123; id: 'box' &#125;, on: &#123; click: this.handleClick &#125; &#125;, 'Hello Vue!') &#125;, data () &#123; return &#123; show: true &#125; &#125;, methods: &#123; handleClick ()&#123; console.log('Clicked!') &#125; &#125;&#125;)let app = new Vue(&#123; el: '#app'&#125;） createElement解析过程简单的来看一下createElement解析的过程，这部分需要对JS有一些功底。不然看起来有点蛋疼： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const SIMPLE_NORMALIZE = 1const ALWAYS_NORMALIZE = 2function createElement(context, tag, data, children, normalizationType, alwaysNormalize) &#123; // 兼容不传data的情况 if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data &#125; // 如果alwaysNormalize是true // 那么normalizationType应该设置为常量 ALWAYS_NORMALIZE 的值 if (alwaysNormalize) &#123; normalizationType = ALWAYS_NORMALIZE // 调用_createElement创建虚拟节点 return _createElement(context, tag, data, children, normalizationType) &#125; function_createElement(context, tag, data, children, normalizationType) &#123; /** * 如果存在data.__ob__，说明data是被Observer观察的数据 * 不能用作虚拟节点的data * 需要抛出警告，并返回一个空节点 * * 被监控的data不能被用作vnode渲染的数据的原因是： * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作 */ if (data &amp;&amp; data.__ob__) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\\n` + 'Always create fresh vnode data objects in each render!', context ) return createEmptyVNode() &#125; // 当组件的is属性被设置为一个falsy的值 // Vue将不会知道要把这个组件渲染成什么 // 所以渲染一个空节点 if (!tag) return createEmptyVNode() // 作用域插槽 if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function') &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; // 如果标签名是字符串类型 if (typeof tag === 'string') &#123; let Ctor // 获取标签名的命名空间 ns = config.getTagNamespace(tag) // ...略 &#125; else &#123; // 当tag不是字符串的时候，我们认为tag是组件的构造类 // 所以直接创建 vnode = createComponent(tag, data, context, children) &#125; if (vnode) &#123; // 如果有namespace，就应用下namespace，然后返回vnode if (ns) applyNS(vnode, ns) return vnode &#125; else &#123; return createEmptyVNode() &#125; &#125;&#125; 这部分代码和流程图来自于@JoeRay61的《Vue原理解析之Virtual DOM》一文。 使用JavaScript代替模板功能在使用Vue模板的时候，我们可以在模板中灵活的使用v-if、v-for、v-model和之类的。但在render函数中是没有提供专用的API。如果在render使用这些，需要使用原生的JavaScript来实现。 v-if和v-for在render函数中可以使用if/else和map来实现template中的v-if和v-for。 123456&lt;template&gt; &lt;ul v-if=\"items.length\"&gt; &lt;li v-for=\"item in items\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p v-else&gt;No item found.&lt;/p&gt;&lt;/template&gt; 换成 render 函数可以这么写 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;item-list :items=\"items\"&gt;&lt;/item-list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; components: &#123; 'item-list': &#123; props: ['items'], render: function (createElement)&#123; if (this.items.length)&#123; return createElement('ul', this.items.map((item)=&gt;&#123; return createElement('li', item) &#125;)) &#125; else&#123; return createElement('p', 'No items found.') &#125; &#125; &#125; &#125;, data() &#123; return &#123; items: ['Javascript', 'Vue', 'react'] &#125; &#125; &#125;&lt;/script&gt; v-modelrender函数中也没有与v-model相应的API，如果要实现v-model类似的功能，同样需要使用原生JavaScript来实现。 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;my-input :name=\"name\" @input=\"val =&gt; name = val\"&gt;&lt;/my-input&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; components: &#123; 'my-input': &#123; render: function (createElement) &#123; var self = this return createElement('input', &#123; domProps: &#123; value: self.name &#125;, on: &#123; input: function (event) &#123; self.$emit('input', event.target.value) &#125; &#125; &#125;) &#125;, props: &#123; name: String &#125; &#125; &#125;, data() &#123; return &#123; name: 'react' &#125; &#125; &#125;&lt;/script&gt; 插槽你可以从this.$slots获取VNodes列表中的静态内容： 1234render: function (createElement)&#123; // 相当于 `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', this.$slots.default)&#125; 还可以从this.$scopedSlots中获得能用作函数的作用域插槽，这个函数返回VNodes: 123456789props: ['message'],render: function (createElement)&#123; // 相当于 `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', [ this.$scopeSlots.default(&#123; text: this.message &#125;) ])&#125; 如果要用渲染函数向子组件中传递作用域插槽，可以利用VNode数据中的scopedSlots域 JSX如果写习惯了template，然后要用render函数来写，一定会感觉好痛苦，特别是面对复杂的组件的时候。不过我们在Vue中使用JSX可以让我们回到更接近于模板的语法上。 12345678910111213141516171819&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;my-con&gt;&lt;/my-con&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; components: &#123; 'myCon': &#123; render: function (h) &#123; return ( &lt;div&gt;1221&lt;/div&gt; ) &#125; &#125; &#125; &#125;&lt;/script&gt; 将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 h 失去作用，在应用中会触发报错。 总结回过头来看，Vue中的渲染核心关键的几步流程还是非常清晰的： new Vue，执行初始化 挂载$mount方法，通过自定义render方法、template、el等生成render函数 通过Watcher监听数据的变化 当数据发生变化时，render函数执行生成VNode对象 通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素 至此，整个new Vue的渲染过程完毕。 而这篇文章，主要把精力集中在render函数这一部分。学习了怎么用render函数来创建组件，以及了解了其中createElement。 参考 大漠 - Vue的render函数","categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/categories/Vue-js/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://gershonv.github.io/tags/Vue-js/"}]}]}