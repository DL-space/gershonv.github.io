---
title: 正则表达式
date: 2018-08-25 00:39:14
comments: true #是否可评论
tags:
   - Javascript
   - regexp
toc: true
categories: Javascript
---
## 引言
**正则是匹配模式，要么匹配字符，要么匹配位置。**
第1章和第2章以这个角度去讲解了正则的基础。

**在正则中可以使用括号捕获数据，要么在API中进行分组引用，要么在正则里进行反向引用。**
这是第3章的主题，讲解了正则中括号的作用。

**学习正则表达式，是需要了解其匹配原理的。**
第4章，讲解了正则了正则表达式的回溯法原理。另外在第6章里，也讲解了正则的表达式的整体工作原理。

**不仅能看懂别人的正则，还要自己会写正则。**
第5章，是从读的角度，去拆分一个正则表达式，而第6章是从写的角度，去构建一个正则表达式。

**学习正则，是为了在真实世界里应用的。**
第7章讲解了正则的用法，和相关API需要注意的地方。

## 第一章 正则表达式字符匹配攻略
> 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。

### 两种模糊匹配
如果正则只有精确匹配是没多大意义的，比如`/hello/`，也只能匹配字符串中的"hello"这个子串。

```js
var regex = /hello/;
console.log( regex.test("hello") ); // => true
```
正则表达式之所以强大，是因为其能实现模糊匹配。
而模糊匹配，有两个方向上的“模糊”：**横向模糊**和**纵向模糊**。

#### 横向模糊匹配
横向模糊指的是，一个正则可匹配的**字符串的长度不是固定的**，可以是多种情况的。
其实现的方式是使用量词。譬如`{m,n}`，表示连续出现最少m次，最多n次。
比如`/ab{2,5}c/`表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。测试如下
```js
var regex = /ab{2,5}c/g;
var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
console.log( string.match(regex) ); 
// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]

```
#### 纵向模糊匹配
纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。
其实现的方式是使用字符组。譬如`[abc]`，表示该字符是可以字符“a”、“b”、“c”中的任何一个。
比如`/a[123]b/`可以匹配如下三种字符串："a1b"、"a2b"、"a3b"。测试如下：
```js
var regex = /a[123]b/g;
var string = "a0b a1b a2b a3b a4b";
console.log( string.match(regex) ); 
// => ["a1b", "a2b", "a3b"]
```

### 字符组
需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如`[abc]`，表示匹配一个字符，它可以是“a”、“b”、“c”之一。

#### 范围表示法
如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。

比如`[123456abcdefGHIJKLM]`，可以写成`[1-6a-fG-M]`。用连字符-来省略和简写。

因为连字符有特殊用途，那么要匹配“a”、“-”、“z”这三者中任意一个字符，该怎么做呢？

不能写成`[a-z]`，因为其表示小写字符中的任何一个字符。

可以写成如下的方式：`[-az]`或`[az-]`或`[a\-z]`。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。

#### 排除字符组
纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是"a"、"b"、"c"。

此时就是排除字符组（反义字符组）的概念。例如`[^abc]`，表示是一个除"a"、"b"、"c"之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念。

#### 常见的简写形式
有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。
- `\d` `\D` : `[0-9]` / `[^0-9]` 数字/非数字 
- `\w` :  `[0-9a-zA-Z_]` 数字、大小写字母和下划线, 记忆方式：w是word的简写。
- `\s` : `[ \t\v\n\r\f]` 空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母
- `.` : 通配符，表示几乎任意字符

### 量词
量词也称重复。掌握`{m,n}`的准确含义后，只需要记住一些简写形式。

#### 简写形式
- `{m,}` 表示至少出现m次。
- `{m}` 等价于`{m,m}`，表示出现m次。
- `?` 等价于`{0,1}`，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
- `+ `等价于`{1,}`，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
- `*` 等价于`{0,}`，表示出现任意次，有可能不出现。

#### 贪婪匹配和惰性匹配
看如下的例子：

```js
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) ); 
// => ["123", "1234", "12345", "12345"]
```
其中正则`/\d{2,5}/`，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字。

但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要5个。你能给我3个，我就3要个。反正只要在能力范围内，越多越好。

我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配：

```js
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) ); 
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```
其中`/\d{2,5}?/`表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。
通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：
> `{m,n}?` 
> `{m,}?`
> `??`
> `+?`
> `*?`
对惰性匹配的记忆方式是：**量词后面加个问号，问一问你知足了吗，你很贪婪吗？**

### 多选分支
一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。
具体形式如下：`(p1|p2|p3`)，其中`p1`、`p2`和`p3`是子模式，用`|`（管道符）分隔，表示其中任何之一。
例如要匹配"good"和"nice"可以使用`/good|nice/`。测试如下：

```js
var regex = /good|nice/g;
var string = "good idea, nice try.";
console.log( string.match(regex) ); 
// => ["good", "nice"]
```
但有个事实我们应该注意，比如我用`/good|goodbye/`，去匹配"goodbye"字符串时，结果是"good"：

```js
var regex = /good|goodbye/g;
var string = "goodbye";
console.log( string.match(regex) ); 
// => ["good"]
```
而把正则改成`/goodbye|good/`，结果是：

```js
var regex = /goodbye|good/g;
var string = "goodbye";
console.log( string.match(regex) ); 
// => ["goodbye"]
```
也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。

### 案例分析
匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。

**匹配16进制颜色值** 

要求匹配：
- `#ffbbad`
- `#Fc01DF`
- `#FFF`
- `#ffE`
分析：
表示一个16进制字符，可以用字符组`[0-9a-fA-F]`。
其中字符可以出现3**或**6次，需要是用量词和**分支结构**。
使用分支结构时，需要注意顺序。
正则如下：

```js
var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) ); // => ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"]
```

**匹配时间**
以24小时制为例。
要求匹配：`23:59` `02:07`

分析：
共4位数字，第一位数字可以为`[0-2]`。
当第1位为2时，第2位可以为`[0-3]`，其他情况时，第2位为`[0-9]`。
第3位数字为`[0-5]`，第4位为`[0-9]`
正则如下：

```js
var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;
console.log( regex.test("23:59") ); // => true
console.log( regex.test("02:07") ); // => true
```

** 匹配日期**
比如yyyy-mm-dd格式为例。匹配`2017-06-10`
分析：
年，四位数字即可，可用`[0-9]{4}`。
月，共12个月，分两种情况01、02、……、09和10、11、12，可用`(0[1-9]|1[0-2])`。
日，最大31天，可用`(0[1-9]|[12][0-9]|3[01])`。
正则如下：

```js
var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
console.log( regex.test("2017-06-10") ); // => true
```
**匹配标签中的id**
要求从 `<div id="container" class="main"></div>`

提取出id="container"。
可能最开始想到的正则是：

```js
var regex = /id=".*"/
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]); // => id="container" class="main"
```
因为`.`是通配符，本身就匹配双引号的，而量词`*`又是贪婪的，当遇到container后面双引号时，不会停下来，会继续匹配，直到遇到最后一个双引号为止。
解决之道，可以使用惰性匹配：

```js
var regex = /id=".*?"/
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]); // => id="container"
```
当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：

```js
var regex = /id="[^"]*"/
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]); // => id="container"
```
## 第二章 正则表达式位置匹配攻略
> 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话
本章讲讲正则匹配位置的总总。
内容包括：
- 什么是位置？
- 如何匹配位置？
- 位置的特性
- 几个应用实例分析

### 什么是位置呢？
位置是相邻字符之间的位置。比如，下图中箭头所指的地方：
![](https://user-gold-cdn.xitu.io/2017/7/19/95d0faf6b21f9414d24c8281b3046746?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 如何匹配位置呢？
在ES5中，共有6个锚字符：
> `^` `$` `\b` `\B` `(?=p)` `(?!p)`

#### ^和$
`^`（脱字符）匹配开头，在多行匹配中匹配行开头。
`$`（美元符号）匹配结尾，在多行匹配中匹配行结尾。
比如我们把字符串的开头和结尾用"#"替换（位置可以替换成字符的！）：

```js
var result = "hello".replace(/^|$/g, '#');
console.log(result); // => "#hello#"
```

多行匹配模式时，二者是行的概念，这个需要我们的注意：

```js
var result = "I\nlove\njavascript".replace(/^|$/gm, '#');
console.log(result);
/*
#I#
#love#
#javascript#
*/
```
#### \b和\B
`\b`是单词边界，具体就是`\w`和`\W`之间的位置，也包括`\w`和`^`之间的位置，也包括`\w`和`$`之间的位置。
比如一个文件名是"[JS] Lesson_01.mp4"中的`\b`，如下：

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, '#');
console.log(result); // => "[#JS#] #Lesson_01#.#mp4#"
```
为什么是这样呢？这需要仔细看看。
首先，我们知道，`\w`是字符组`[0-9a-zA-Z_]`的简写形式，即`\w`是字母数字或者下划线的中任何一个字符。而`\W`是排除字符组`[^0-9a-zA-Z_]`的简写形式，即`\W`是`\w`以外的任何一个字符。
此时我们可以看看"[#JS#] #Lesson_01#.#mp4#"中的每一个"#"，是怎么来的。
- 第一个"#"，两边是"["与"J"，是`\W`和`\w`之间的位置。
- 第二个"#"，两边是"S"与"]"，也就是`\w`和`\W`之间的位置。
- 第三个"#"，两边是空格与"L"，也就是`\W`和`\w`之间的位置。
- 第四个"#"，两边是"1"与"."，也就是`\w`和`\W`之间的位置。
- 第五个"#"，两边是"."与"m"，也就是`\W`和`\w`之间的位置。
- 第六个"#"，其对应的位置是结尾，但其前面的字符"4"是`\w`，即`\w`和`$`之间的位置。

知道了`\b`的概念后，那么`\B`也就相对好理解了。

`\B`就是`\b`的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉`\b`，剩下的都是`\B`的。

具体说来就是`\w`与`\w`、`\W`与`\W`、`^`与`\W`，`\W`与`$`之间的位置。

比如上面的例子，把所有`\B`替换成"#"：

```js
var result = "[JS] Lesson_01.mp4".replace(/\B/g, '#');
console.log(result); // => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

#### (?=p)和(?!p) [匹配p前面的位置]
`(?=p)`，其中`p`是一个子模式，即`p`前面的位置。
比如`(?=l)`，表示'l'字符前面的位置，例如：

```js
var result = "hello".replace(/(?=l)/g, '#');
console.log(result); // => "he#l#lo"
```
而`(?!p)`就是`(?=p)`的反面意思，比如：

```js
var result = "hello".replace(/(?!l)/g, '#');
console.log(result); // => "#h#ell#o#"
```
#### 位置的特性
对于位置的理解，我们可以理解成空字符""。

比如"hello"字符串等价于如下的形式：

```js
"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "o" + "";
```
也等价于：
```js
"hello" == "" + "" + "hello"
```
因此，把`/^hello$/`写成`/^^hello$$$/`，是没有任何问题的：

```js
var result = /^^hello$$$/.test("hello");
console.log(result); // => true
```
也就是说字符之间的位置，可以写成多个。

把位置理解空字符，是对位置非常有效的理解方式。

### 相关案例
- **不匹配任何东西的正则**
让你写个正则不匹配任何东西easy，`/.^/`, 因为此正则要求只有一个字符，但该字符后面是开头。
- ** 数字的千位分隔符表示法**
比如把"12345678"，变成"12,345,678"。
可见是需要把相应的位置替换成","。
思路是什么呢？

**1. 弄出最后一个逗号**

```js
var result = "12345678".replace(/(?=\d{3}$)/g, ',')
console.log(result); // => "12345,678"
```
**2. 弄出所有的逗号**
因为逗号出现的位置，要求后面3个数字一组，也就是`\d{3}`至少出现一次。
此时可以使用量词`+：`

```js
var result = "12345678".replace(/(?=(\d{3})+$)/g, ',')
console.log(result); // => "12,345,678"
```
- **匹配其余案例**
写完正则后，要多验证几个案例，此时我们会发现问题：

```js
var result = "123456789".replace(/(?=(\d{3})+$)/g, ',')
console.log(result); // => ",123,456,789"
```
因为上面的正则，仅仅表示把从结尾向前数，一但是3的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。
怎么解决呢？我们要求匹配的到这个位置不能是开头。
我们知道匹配开头可以使用`^`，但要求这个位置不是开头怎么办？
easy，`(?!^)`，你想到了吗？测试如下：

```js
var string1 = "12345678",
string2 = "123456789";
reg = /(?!^)(?=(\d{3})+$)/g;

var result = string1.replace(reg, ',')
console.log(result); 
// => "12,345,678"

result = string2.replace(reg, ',');
console.log(result); 
// => "123,456,789"
```

#### 验证密码问题
密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。
此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。
那么，我们就来挑战一下。看看我们对位置的理解是否深刻。

**1. 简化**
不考虑“但必须至少包括2种字符”这一条件。我们可以容易写出：

```js
var reg = /^[0-9A-Za-z]{6,12}$/;
```
判断是否包含有某一种字符
假设，要求的必须包含数字，怎么办？此时我们可以使用`(?=.*[0-9])`来做。
因此正则变成：

```js
var reg = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;
```

